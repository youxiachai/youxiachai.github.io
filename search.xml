<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>国庆博客恢复更新</title>
      <link href="/2021/10/05/other/resumeupdate/"/>
      <url>/2021/10/05/other/resumeupdate/</url>
      
        <content type="html"><![CDATA[<p>最后一篇博客占坑 2019 的google io 后面也没填坑，国庆折腾了ts, flutter, node，hexo, 两年没更新博客了，我觉得是时候恢复更新了。</p><span id="more"></span><h2 id="接下来的安排"><a href="#接下来的安排" class="headerlink" title="接下来的安排"></a>接下来的安排</h2><ol><li>输出flutter的学习笔记，今年年底，尽可能写一个完备的flutter app</li><li>工作上的一些反思，也定期写一下</li><li>投资反思，也放一份在博客上吧</li></ol>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 投资九月第三十九周报</title>
      <link href="/2021/10/01/invest/invest-2021-9-27-9-30/"/>
      <url>/2021/10/01/invest/invest-2021-9-27-9-30/</url>
      
        <content type="html"><![CDATA[<p>这周，用一个词来总结：季度首亏</p><span id="more"></span><p>三季度最后一个交易周了，虽然，国庆放假前，大盘收了一个红，可惜中概的糟糕表现，还是无法挽回三季度可能会出现的亏损。</p><p>不过，我打新中的股票，在国庆前上市了，实际的盈亏数据，还得在国庆期间整理一下最后的数据。</p><p>三季度有过高光时刻，浮盈收益一度突破10个，可惜，市场的变化就是这么变幻莫测，往往在你高兴的时候，泼你一桶冰水。</p><p>不过，以我目前的资金体量，也要习惯几万收益的来回横跳，毕竟几万的来回横跳，并不是我未来的目标，未来几十万的来回横跳也很有可能发生，所以，人的level一定也要跟着提升。</p><p>以我目前的认知来看，未来几十万的来回横跳可能就是我承受能力的天花板了。人这一辈子，也算是有一天能完成段子说的一天几十万上下的日子？</p><h4 id="火币清退国内用户"><a href="#火币清退国内用户" class="headerlink" title="火币清退国内用户"></a>火币清退国内用户</h4><p>这周，国家又出文件重拳打击数字货币，火币这样的老牌厂商，直接发公告要清退国内用户了，对于我这种还有几千btc的资产来说，现阶段，我打算，放回到钱包了。</p><p>至于套现，我觉得才几千块，完全没有套现的价值，等风头过了以后，在找一个交易所来进行交易吧。</p><p>国家再次严打数字货币，也算是一个信号吧，特别，我从某些渠道获得了一些，关于外汇和国内货币的资料，我觉得把这个口子封上，对于国内金融稳定还是有一定的作用。</p><p>这里就不展开说了，做个谜语人了。</p><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><h4 id="股票"><a href="#股票" class="headerlink" title="股票"></a>股票</h4><h5 id="卖出复盘"><a href="#卖出复盘" class="headerlink" title="卖出复盘"></a>卖出复盘</h5><table><thead><tr><th>股票</th><th>操作</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>中捷精工</td><td>卖出</td><td>26</td><td>200</td></tr><tr><td>中捷精工</td><td>卖出</td><td>21.65</td><td>300</td></tr></tbody></table><p>上周，把几百页的中捷的招股书看了，老实说，我对汽车的上游零件加工信心并不是很足，所以，在中捷第二天无力上涨，我就选择了清仓了，汽车相关行业，可能还会有行情？但是，对于在我认知中把握不是很足的行业，我还是选择放弃了。</p><h5 id="买入复盘"><a href="#买入复盘" class="headerlink" title="买入复盘"></a>买入复盘</h5><table><thead><tr><th>股票</th><th>操作</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>京东方</td><td>买入</td><td>5.05</td><td>1000</td></tr><tr><td>中概互联</td><td>买入</td><td>1.387</td><td>700</td></tr></tbody></table><p>这个月，小米和京东方的表现都非常颓，特别是小米，已经颓得不能在颓了，国庆回来以后，我估计还是会筹点钱去进行加仓，未来我还是看好小米的表现。</p><p>京东方这次大跌，算是面板的周期性，首先，年年传京东方供应iPhone屏幕，然后年年没有供应给iPhone，接着就是电视面板的降价，对于接下来的京东方也算是严峻的考验了，对于京东方我的看法还是，坚持到周期来了就好了，反正这也不是第一次大跌，18年还从6块跌到了2块，只可惜那会，没有重仓，现在机会又来了，左侧走起吧。对于京东方的未来，我还是有信心，虽然持有体验可能有点糟糕，但是，在京东方的基本面没啥变化的时候，我会持续投入，等收获的一天。</p><p>中概，目前唯有支持了，还是之前的观点，战3年。</p><h5 id="本周最后收盘价"><a href="#本周最后收盘价" class="headerlink" title="本周最后收盘价"></a>本周最后收盘价</h5><table><thead><tr><th>股票</th><th>收盘价</th><th>卖出收益率</th><th>买入收益率</th></tr></thead><tbody><tr><td>中捷精工</td><td>20.62</td><td>11.99%</td><td>0%</td></tr><tr><td>京东方</td><td>5.05</td><td>0%</td><td>0%</td></tr><tr><td>中概互联</td><td>1.382</td><td>0%</td><td>-0.36%</td></tr></tbody></table><h4 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h4><p>美股居然跌了！纳指这周回调了一些，所以，导致我海外基金的收益一般，还好石油争气，对冲了纳指的下跌。</p><p>国内的基金，已经没有什么盈利特别突出的基了，所以下个月我的套现4千的目标，连续9个月实现每个月基金至少提现4千，可能在10月份要中断了。</p><p>这个实验暂时说明，目前我的操作模型，就算有50万资金做板块轮转，要维持每个月至少套现4千（只计算基金）还是不够稳定。</p><p>所以，现阶段，还是好好打工，多积攒一些本金，短期内不要指望投资收入能覆盖生活成本。</p><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><p>这周套现</p><table><thead><tr><th>类型</th><th>金额</th></tr></thead><tbody><tr><td>基金</td><td>887.94</td></tr><tr><td>股票</td><td>7921.6</td></tr></tbody></table><p>目前收益率</p><table><thead><tr><th>类型</th><th>百分比</th></tr></thead><tbody><tr><td>国内</td><td>-7.81%</td></tr><tr><td>海外</td><td>-7.46%</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> invest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> invest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google io 2019</title>
      <link href="/2019/05/12/other/googleio2019/"/>
      <url>/2019/05/12/other/googleio2019/</url>
      
        <content type="html"><![CDATA[<p>google io 2019 感想 占坑.</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学思维入门</title>
      <link href="/2016/10/07/math/2016-10-07/"/>
      <url>/2016/10/07/math/2016-10-07/</url>
      
        <content type="html"><![CDATA[<p>国庆7天，一眨眼就过了，除去加班4天，剩下的3天，好像也没干什么正事，总觉得现在的日子，每天都这么过去，然而，回过神来，好像又什么都没发生过。</p><p>出现这种情况，我现在回想，应该是没有目标，因为不知道前面有什么东西，一路走来，随走随停，停下来回顾走过来的路，一路黑，所以，要改变这种情况，最好的办法，就是在旅途不同阶段，定下不同目标，在停下来的时候检验一下，自己都做了哪些，这样就不会感觉，现在的日子总是在原地踏步。</p><p>所以，国庆之后除去背单词，数学思维的练习，加入我的目标套餐里头！</p><p>选了两本书作为学习，《程序员的数学》，《数学思维导论》。</p><p>加油！</p><span id="more"></span><h2 id="数和逻辑"><a href="#数和逻辑" class="headerlink" title="数和逻辑"></a>数和逻辑</h2><p>今天，一下午，一口气看完程序的数学前四章，总体观感，总算有本讲数学的书，以我的智商也能看懂了。</p><p>前四章讲的东西，大体可以分为两类，数和逻辑。</p><p>数是数学的基石，0的故事和余数，在我看来，表达了数学世界的最基础的表达。</p><p>0是数学的开始，用0来代表这个世界未知的东西，事件的开始。</p><p>而余数，是用来展现我们事物的周期性，还有种类。例如，我们的日历，就是余数在周期性的一大应用的地方，排队既是对一个总体的分组的应用。</p><p>逻辑和数学归纳，逻辑就不用说了，就是把生活的复杂的东西，进行逻辑处理，使之变成简单的东西，其中卡诺图的应用使用大开眼界。</p><p>归纳就是对一个通常事件，重新整理，使之能够让某个做好的事情，能够随时重现，碰到类似的问题，就能直接使用，节省时间。</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3d 学习笔记3</title>
      <link href="/2016/09/17/unity3d/2016-09-17/"/>
      <url>/2016/09/17/unity3d/2016-09-17/</url>
      
        <content type="html"><![CDATA[<p>中秋三天，一下子就过了，依然是感觉没干什么正事？第一天，回来趟家，第二天回来，第三天摸鱼到了快晚上了，才开始码字。</p><p>根据过往的学习经验，这次unity3d的学习，时间上过了10天，但是，都在摸鱼阶段，进度堪忧，要先仔细分析一下，为什么进度不行？</p><span id="more"></span><h2 id="现在掌握了些什么"><a href="#现在掌握了些什么" class="headerlink" title="现在掌握了些什么"></a>现在掌握了些什么</h2><p>按照之前的学习，我现在应该掌握，基本unity3d ide的操作，如快速完成一个 roll a ball的小游戏操作，然而，学完以后，这十几天疏于练习，至今都没独立完成一个roll a ball的小游戏练习，可以看出来，在学习的过程中，疏于练习，导致学习成果并没有什么成果，而且随着时间的推移，还会导致，学了的东西造成了遗忘，这是接下来需要注意的地方！</p><p>还有一个就是掌握UGUI常用控件的使用，流程，这个也是疏于练习，现在十几天过去了，也有一些不会用了！</p><p>总结的教训就是，多练习，不练即不会！</p><h2 id="先定一个小目标"><a href="#先定一个小目标" class="headerlink" title="先定一个小目标"></a>先定一个小目标</h2><p>掌握了基本的unity3d ide操作以后，接下来，就是开始熟悉unity3d游戏制作，这里选取，官方教程的3d rouglelike 来进行学习，目标9月份掌握这部分知识！</p>]]></content>
      
      
      <categories>
          
          <category> unity3d </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3d 学习笔记2</title>
      <link href="/2016/09/12/unity3d/2016-09-12/"/>
      <url>/2016/09/12/unity3d/2016-09-12/</url>
      
        <content type="html"><![CDATA[<p>这周，好恨啊，几乎是摸了一个星期的鱼，准时下班，然而，回到家了，就会因为莫名其妙的问题，我也不知道发生了什么事情，就到12点了，然而，我发现什么都没做。</p><p>然后周六，周日，也是很神奇的在感觉时间没干什么正事，就过了，感觉再这样下去，我这一辈子堪忧啊。</p><p>今年也没几个月过了，剩下的几个月，其实，虽然嘴上说要过得有意义一些，然而，身体却是不受控制的在浪费时间。</p><p>好了，unity的入坑虽然过了两周，然而学习时间只有短短的4天，基本的操作和一些UI也算是入门了，做一个简单总结，并且确定往后unity3d学习的知识框架！</p><span id="more"></span><h2 id="Unity3d开发流程"><a href="#Unity3d开发流程" class="headerlink" title="Unity3d开发流程"></a>Unity3d开发流程</h2><p>就我目前学习的unity3d的知识，我知道，要制作一款unity3d app的基本要素如下</p><ol><li>场景（Scene）</li><li>游戏对象（GameObject）</li><li>脚本（Scripts）</li></ol><p><img src="/./unity3d-1.png"></p><h2 id="UGUI的基本使用"><a href="#UGUI的基本使用" class="headerlink" title="UGUI的基本使用"></a>UGUI的基本使用</h2><p>摸鱼，摸的太厉害了太晚了，留到下周再补吧。</p>]]></content>
      
      
      <categories>
          
          <category> unity3d </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3d 学习笔记</title>
      <link href="/2016/09/06/unity3d/2016-09-06/"/>
      <url>/2016/09/06/unity3d/2016-09-06/</url>
      
        <content type="html"><![CDATA[<p>学习unity3d有两天了！为什么会想到入这个深坑呢？毕业4年了，忽然，想到当年为什么会去学编程呢？</p><p>当初，学编程的理由，其实很单纯，就是想在手机作出一个游戏，然而，事以愿违，做游戏的难度是在是太大了，涉及编程，美术，音乐，策划。读大学的时候，曾经努力过一把，由于智商问题，只能作罢。</p><p>然而，现在的unity3d 5.x 让我看到了，我也能做游戏的感觉，因为，unity3d发展到了5.x版本，已经很完善了，以前学习游戏的时候，最大的门槛就是，开发游戏的配套工具实在太难弄了，而unity3d的一站式服务，让开发游戏的门槛大大降低了，用unity3d做游戏，最大的问题不是写代码，而是你要有一个做游戏的想法！</p><p>至于，做游戏需要的美术，音乐，也可以在unity3d的商店里找到能用的素材。</p><p>所以，要实现一个游戏，剩下的工作，就是安排好时间，把unity3d用熟！</p><span id="more"></span><h2 id="Unity3d的工程架构"><a href="#Unity3d的工程架构" class="headerlink" title="Unity3d的工程架构"></a>Unity3d的工程架构</h2><p>用个流程图，把Unity3d工程相关的文件结构展示出来，用于方便记忆和查阅</p><p>然后就是，物件，脚本的相关绑定</p><h2 id="Unity3d-GUI的使用流程"><a href="#Unity3d-GUI的使用流程" class="headerlink" title="Unity3d GUI的使用流程"></a>Unity3d GUI的使用流程</h2><ol><li>要了解GUI的层级关系，例如一个Button按钮实际就是有一个加了Button组件的GameObject ＋ Text组合而成</li><li>Image的几种类型</li><li>怎么去做滚动框</li><li>Toggle 和 ToggleGroup的使用</li><li>自定义一个slider</li></ol>]]></content>
      
      
      <categories>
          
          <category> unity3d </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2016/04/20/lifestyles/2016-04-13/"/>
      <url>/2016/04/20/lifestyles/2016-04-13/</url>
      
        <content type="html"><![CDATA[<p>过去总喜欢风骚的贴一些名人警句，看看现在，写点东西都容易狗屁不通</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> lifestyles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker学习总结</title>
      <link href="/2016/02/29/docker/docker_summary/"/>
      <url>/2016/02/29/docker/docker_summary/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习docker有一周了，学习主要看华为写的《Docker进阶与实践》，还有<a href="https://github.com/yeasy/docker_practice">yeasy</a> 的《Docker 从入门到实践》，期间还参考了不少官网的内容，对于，docker现在应该算是入门了，起码基本的使用现在是没什么问题了。从上一年开始关注docker，到今天入门了，终于填好了一个坑，特别写篇笔记，记录自己学docker的心得。</p><span id="more"></span><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>从yeasy的书里，搞了一张图出来，这张图，可以算得上docker的cheatsheet了。<br>其实docker的命令也没啥好说的，也就十几个，常用常熟，也不需要特别记忆了。</p><p><img src="/./14566909261190.jpg"></p><h2 id="搭建私人docker-registry"><a href="#搭建私人docker-registry" class="headerlink" title="搭建私人docker registry"></a>搭建私人docker registry</h2><p>用docker官方的registry来搭建自己的镜像服务器是最省事的了</p><pre><code class="bash">//latest 那个tag在使用的时候会打印api过期，直接用v2的版本吧docker pull registry:2.3.0//创建一个本地目录来放上传的镜像mkdir /registrydocker run -p 5000:5000 -v /registry:/var/lib/registry -d --name local_registry registry:2.3.0//用curl验证镜像是否正常(具体ip看机子，如果是用docker-machine，可以用docker-machine ip default(你创建的虚拟机名字))curl -i 192.168.99.100:5000</code></pre><p>看到返回了200，说明镜像正常工作</p><pre><code>HTTP/1.1 200 OKCache-Control: no-cacheDate: Tue, 01 Mar 2016 13:10:22 GMTContent-Length: 0Content-Type: text/plain; charset=utf-8</code></pre><p>接下来就是尝试使用自己搭建的镜像了！</p><pre><code>//注意namesapce 要用你的镜像ipdocker tag busybox 192.168.99.100:5000/local_busyboxdocker push 192.168.99.100:5000/local_busybox </code></pre><p>然后你会发现push失败了</p><blockquote><p>he push refers to a repository [192.168.99.100:5000&#x2F;local_busybox]<br>unable to ping registry endpoint <a href="https://192.168.99.100:5000/v0/">https://192.168.99.100:5000/v0/</a><br>v2 ping attempt failed with error: Get <a href="https://192.168.99.100:5000/v2/">https://192.168.99.100:5000/v2/</a>: tls: oversized record received with length 20527<br> v1 ping attempt failed with error: Get <a href="https://192.168.99.100:5000/v1/_ping">https://192.168.99.100:5000/v1/_ping</a>: tls: oversized record received with length 20527</p></blockquote><p> 发生这个的原因，是docker默认是用https，配ssl是一个麻烦的事情，如果你是打算像我这样本地用来测试的，可以让docker使用http来push，但是，如果是公网的，无论多麻烦都不要省这个事情！</p><pre><code>docker-machine ssh default//进到我们的docker虚拟机后修改sudo vi /var/lib/boot2docker/profileEXTRA_ARGS=&#39;               --label provider=virtualbox             --insecure-registry 192.168.99.100:5000                                               &#39; //然后重启docker-machinedocker-machine restart default</code></pre><p> 当你把镜像重新运行起来就可以正常使用</p><pre><code>docker push 192.168.99.100:5000/local_busybox </code></pre><p> 这次就不会报错了！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a href="https://docs.docker.com/registry/deploying/">https://docs.docker.com/registry/deploying/</a></p></blockquote><h2 id="完整的docker实践"><a href="#完整的docker实践" class="headerlink" title="完整的docker实践"></a>完整的docker实践</h2><p>index.js</p><blockquote><pre><code class="js">var http = require(&#39;http&#39;)var PORT=10000;var server = http.createServer(function (request, response)&#123;  response.end(&quot;Hello World! &quot; + request.url)&#125;)server.listen(PORT, function()&#123;  console.log(&quot;Server listening on: http://localhost:%s&quot;, PORT);&#125;)</code></pre></blockquote><pre><code>Dockerfile&gt;```DockerfileFROM node:4.3.1ADD . /codeWORKDIR /codeCMD node index.js</code></pre><p>接下来使用</p><pre><code>docker build -t firstnode .</code></pre><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>我们一个项目通常会用到多个不同的应用，例如连接数据库，根据docker的官方的建议，一个容器最好只运行一个进程的原则，所以，单单一个dockerfile是满足不了这个需求的，于是官方推出了docker-compose 用于构建多容器。</p><blockquote><p>对于如何安装docker-compose 请参考官网教程 <a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p></blockquote><p>使用也是很简单只要在项目目录上创建一个<code>docker-compose.yml</code>的文件即可</p><pre><code class="Dockerfile">version: &#39;1&#39;services://这个是我们上面创建的image的名字  firstnode:    build: .    ports:      - &quot;10000:10000&quot;    volumes:     - .:/code    depends_on:     - redis //注意！连接redis的时候host部分要填写与这里一致的名字  redis:    image: redis</code></pre><p>然后运行</p><pre><code>docker-compose up</code></pre><h2 id="ARM-上的docker"><a href="#ARM-上的docker" class="headerlink" title="ARM 上的docker"></a>ARM 上的docker</h2><p><a href="http://blog.hypriot.com/">http://blog.hypriot.com/</a></p><h2 id="常见问题合集"><a href="#常见问题合集" class="headerlink" title="常见问题合集"></a>常见问题合集</h2><h3 id="v-映射的目录必须是绝对路径"><a href="#v-映射的目录必须是绝对路径" class="headerlink" title="-v 映射的目录必须是绝对路径"></a>-v 映射的目录必须是绝对路径</h3><p>例如，你当前路径有一个叫做registry，想这样映射目录是不起作用 的！</p><blockquote><p>docker run -p 5000:5000 -v registry:&#x2F;var&#x2F;lib&#x2F;registry -d –name local_registry registry:2.3.0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015年终总结之败家</title>
      <link href="/2016/02/13/summary/summary2015buybuybuy/"/>
      <url>/2016/02/13/summary/summary2015buybuybuy/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2014年的年终总结彻底坑掉了，现在估计也会想不起来2014年干过什么值得记录的事情了，这次2015年的年终总结，就趁着春节假期一气呵成写完吧。</p><span id="more"></span><h2 id="败家"><a href="#败家" class="headerlink" title="败家"></a>败家</h2><p>2015年不知不觉买了挺多东西，现在整理一份看看。</p><h2 id="数码设备"><a href="#数码设备" class="headerlink" title="数码设备"></a>数码设备</h2><ul><li>PS4</li></ul><p>怎么说呢，继上年买了psv、ps3，2015年1月的时候就入坑了ps4，当时为什么会买ps4，现在想想，还是有点不清楚，毕竟ps4上貌似没什么我特别想玩的游戏，不过，最后买了也不亏，玩了不少游戏，回过头来想想，貌似ps4吃尘的时间远远大于我去玩的时间。</p><ul><li>抽湿机</li></ul><p>最讨厌回南天了，于是，买了一台抽湿机，用了一年多了，还是管用的。</p><ul><li>iPhone 5s／6s</li></ul><p>怎么说呢，3月份买了一个5s，年底又买了6s，不知道怎么吐槽自己了。</p><ul><li>STARY 电动滑板</li></ul><p>非常酷的电动滑板，然而说好的2015年底发货，跳票了。官方貌似说2016年3月第一批发货。</p><ul><li>Teclast&#x2F;台电 X98 Pro WIFI 64GB WIN10平板电脑9.7英寸</li></ul><p>怎么说这个win 10平板呢？用了几次就吃灰了，虽然内存有4G，cpu也是最新的atom，可惜atom的性能还是渣了一些，用起来你说卡嘛，也不是卡得不能用，总之就是个鸡肋，反正就是我钱多了，买一个玩玩体验一下。</p><ul><li>Apple&#x2F;苹果 iPad mini retina 4</li></ul><p>今年我也入了iPad坑，之所以买这个iPad，当时在学iOS，iPhone都有了就差一个iPad，刚好iPad mini新款出了更新还是挺多了，就买了，然后买回来，还是吃尘的时间多啊。。。</p><ul><li>空气炸锅HD9233</li></ul><p>一直有听说空气炸锅，炸薯条非常方便，于是双十一特价就买了这个飞利浦的最好卖的炸锅，嗯！炸薯条的确很方便！</p><ul><li>小米电视2</li></ul><p>2015年年会中了一个电视，真心人品爆发了。可惜2016年年会就坑了，为了放电视还买了一个1k大洋的电视落地架。</p><ul><li>小米路由</li></ul><p>一个坑了我整整一年的路由。</p><p>怎么说呢，作为市场上鲜有的内置1T硬盘的路由，还是戳中了我的痛点，可惜毕竟是第一代，硬件上在长期使用上还是有着不少的缺陷，还有定制的openwrt系统并不稳定，一个月总有那么几天会假死，需要拔电源重启，这个bug得等到2016年1月才真正修复了。不过，第二代小米路由倒是吸收了1代硬件上的设计缺陷，做出了一个相对完善的二代，硬盘不用笔记本硬盘了，可惜系统的假死问题还是没解决，以至于我2015年月底买了二代，用了几天就退回去了，实在受不了还会每周假死，虽然后来系统修复了假死问题，不过，我那时候已经自建了Nas了。</p><ul><li>小米4</li></ul><p>作为android开发者，怎么不用一个配置高点的android 手机呢？你问我有多少台android手机？作为一个android开发者，我告诉你，我的android手机一点都不多，也就5台而已。</p><p>2015年值得拿出来说说的设备就这些了，期间还买了不少小玩意，例如桌子，收纳箱等，不过这些都是便宜货也没什么好记住的。这年头花了多数钱？我就懒的算了，人啊，要花得开心，然后就老老实实吃土吧。</p><h2 id="数字娱乐"><a href="#数字娱乐" class="headerlink" title="数字娱乐"></a>数字娱乐</h2><h3 id="PSV"><a href="#PSV" class="headerlink" title="PSV"></a>PSV</h3><ol><li>P4G 女神异闻录4 BEST版</li><li>胧村正 </li><li>太鼓达人V</li></ol><ul><li>太鼓达人v</li></ul><p>今年psv游戏买得不多，会免送的游戏已经够玩了，现在看来psv真的要成为ps4的手柄了，今年出的psv 游戏也就买了太鼓达人v，现在就差魔鬼25就白金了，不过魔鬼25的难度真心难啊，也不知道什么时候才能把这个白金收了。。。</p><ul><li>胧村正</li></ul><p>画面真心美，虽然没有中文版，玩的是美版，这种日式鬼怪题材的美版，阅读起来真心难懂，而且单词方面不少单词是日文的罗马音，不过，在玩的过程中也算学了不少新单词吧。</p><p>4个DLC在年末打折的时候也一起购买了，这个游戏算是今年我玩的最痛快的psv游戏了。</p><ul><li>女神异闻录4 黄金版</li></ul><p>玩了一关就彻底坑掉了，看2016年那天会填掉吧？</p><ul><li>伊苏：树海</li></ul><p>虽然不是今年买的游戏，但是作为一个伊苏粉丝，树海的白金，终于在2015年年末白了，耗时接近2年。。。真是可喜可贺，期间的艰辛，真是不可言喻，2016年伊苏8期望中文版不要等太久。虽说2015年树海推出了中文版，不过，作为英语还可以的我来说，玩美版就够了啦。</p><p>我真不是一个合格的伊苏粉啊。</p><h3 id="PS3"><a href="#PS3" class="headerlink" title="PS3"></a>PS3</h3><ol><li>魔界战记4+猎天使魔女+战地4+FIFA13</li><li>神海1，2合集</li></ol><p>今年的ps3，基本吃尘了。。。</p><h3 id="PS4"><a href="#PS4" class="headerlink" title="PS4"></a>PS4</h3><ol><li>The order 1986</li><li>巫师3</li><li>如龙0</li><li>阿克汉姆骑士Arkham Knight</li><li>刺客信条：大革命</li><li>血源</li><li>GTA 5</li><li>刺客信条：黑旗</li><li>看门狗</li><li>辐射4</li><li>最后的生还者</li><li>地狱潜者</li></ol><p>今年入了ps4，就游戏来说，玩得比较多的应该还是ps4了，买了不少游戏，不过吃尘的居多的，还有一些打折的时候喜加1。</p><ul><li>The order 1986</li></ul><p>ps4上画面最屌的游戏，实际上画面确实屌！可惜玩的时候，跟播片差不多，我个人感觉，续作如果不出就有点可惜了。。。而以目前1986的销量来看出续作的可能性很低。。。</p><ul><li>如龙0</li></ul><p>如龙系列的首个中文化，日本的黑道故事，除去那些坑死人的小游戏，主线剧情还是很不错。真岛哥真心男人啊！</p><p>2016年出了如龙1的重置版，等降价了入一盘玩玩。</p><ul><li>血源</li></ul><p>硬核游戏，死死死死死，如果不是看了黑桐谷歌的视频，说实话真心不会想到要买这么一个虐的游戏，虽然，难度很高，但是我好歹最后还是通关了，买了DLC不过吃尘了。</p><p>血源的艺术风格，很压抑，很血腥，很暴力。所以，有时候不怎么想玩，特别是不停地死死死死死死死死</p><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><ol><li>高考恋爱一百天</li><li>steam各种喜加1</li></ol><ul><li>高考恋爱一百天</li></ul><p>国产galgame 买了回来就吃尘了，就当支持一发国产游戏吧。</p><ul><li>steam喜加1</li></ul><p>steam支持支付宝，于是，打折就喜加1了，文明系列啊，valve打包游戏啊，坎巴拉太空计划啊，besiege啊，买买买，反正也花不了多少钱。</p><p>最后一算，还是花了不少钱。。。orz</p>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015年终总结之思考</title>
      <link href="/2016/02/13/summary/summary2015think/"/>
      <url>/2016/02/13/summary/summary2015think/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻了一下日志，从2013年开始就开坑写年终总结，然而，就没有下文了，时隔两年2015年的年终必须不坑！一口气写完吧！</p><span id="more"></span><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>整个2015年，才写了9篇文章，连一个月一篇都坚持不下来，人啊，真是越活越懒了，出现这种情况，很明显，就是我已经懒得去思考了。</p><p>2015年已经过去了，从写作的情况来看，明显没有刚毕业的那时候喜欢思考了，记得刚毕业那会，起码一个月会有几篇文章，用来总结反思。今年搞了一个周总结的，结果一个月都没坚持下来就弃坑了。现在想想，弃坑的原因，简单来说就是思想上开始惰性化了，节奏开始变慢，如果继续这样下去，其实对于以后的发展而言是很不利的，特别是现在经济情况也不是很好，人的年龄也开始越来越大了，女朋友也没，钱又没，人又懒的话，可想而知，在30岁以前还是一事无成，从2016年开始，就应该开始重视，重拾心情，勤于思考，这样才能活得精彩！</p><p>2016年春节已经过去了，接下来的时间，就要鞭策自己多观察，多思考，多反思，多写，多回顾。期望在2017年的时候，回望2016年不像现在回望2015年有那么多的不足！</p><h2 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h2><p>毕业也有3年时间了，在职业选择上，走上了IT程序员，回顾这3年来的职业技能，在整个2015年来说，进步很少！</p><p>整个2015年，无疑我是懒惰了，总得来说，少了思考，也就少了对技能的增进，在接下来的2016年，要吸收教训，不能在这样懒下去！</p><h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><p>整个2015年，我都没想到，我会看了这么多网络小说，随便数数，几十本100w字以上的小说还是有的，本来用来思考的时间，都被这些网络小说所填充了，这也可能是为什么，2015年我写少了的原因之一，2016年，尽量少读一些网络小说吧！</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>还是没有女朋友，这个不吐槽了。。。</p><p>整个2015年，做得最好的可能就是把背单词这样一件小事坚持了下来，成果还是很不错的</p><p>2015&#x2F;3&#x2F;2 4290<br><a href="http://testyourvocab.com/result?user=4975250">http://testyourvocab.com/result?user=4975250</a></p><p>2016&#x2F;2&#x2F;1 6740<br><a href="http://testyourvocab.com/result?user=6195663">http://testyourvocab.com/result?user=6195663</a></p><p>从4k左右的词汇量，一年坚持下来，涨到了6k，虽然从效率来说，可能算不少好，但是，把上下班那种拿来看风景的时间，化作一种成果，其实从结果来看还是很不错的，2015年的时候，对于英语我定了一个三年计划，希望三年后，我能够流畅的使用的英语，现在一年过去了，离我流畅使用英语其实，也没那么遥远了，语言的学习，坚持就是胜利！</p><h2 id="2016年的展望"><a href="#2016年的展望" class="headerlink" title="2016年的展望"></a>2016年的展望</h2><p>职业上，要更加的深入技术本质，多学，多思考，多出成果，不断改进。</p><p>生活上，开始有计划的锻炼的身体。</p><p>文化上，多读一些深度思考的书，多反思，多写。</p><p>希望来年，回望2016年，会有很大收获！</p>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 第三周学习笔记 View</title>
      <link href="/2015/09/21/ios/cs193p1_view/"/>
      <url>/2015/09/21/ios/cs193p1_view/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进入，iOS学习的第三周，这周犯懒，以至于，ios学习的进度，并没有什么大的进步，这周就只把tabview，学习了一遍，还有一些杂项，ios9 https的兼容，pod怎么用这类的。</p><span id="more"></span><h2 id="TableView"><a href="#TableView" class="headerlink" title="TableView"></a>TableView</h2><p>需要学习的几个方法</p><pre><code>override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;        return 0    &#125; override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 0 &#125;   override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;        let cell = tableView.dequeueReusableCellWithIdentifier(Storyboard.CellReuseIdentifier, forIndexPath: indexPath)        return cell    &#125; override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123;&#125;</code></pre><p>待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过去的坚持，现在的思考，未来的展望</title>
      <link href="/2015/09/20/lifestyles/note_20150920/"/>
      <url>/2015/09/20/lifestyles/note_20150920/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我是谁？<br>从哪里来<br>要到哪里去？</p></blockquote><span id="more"></span><p>2015年已经进入9月中旬了，回顾这大半年的。</p><p>2015年已经过去了，一大半，我已经快26岁了，一年快，20多年也快，今天，忽然感慨，我已经活了20多年了，回顾过去，貌似，都没怎么写过，关于我的文章，特别是最近几年，虽然笔耕不断，但是写的都是技术类的感想笔记，关于自己的，关于过去，关于未来的，虽想过，但是从没用过笔墨来记录，记得《论语》有一段</p><blockquote><p>朝闻道，夕死可矣</p></blockquote><p>不过，今天要记录这些文字，并不是我闻道了，只是有所想，离闻道，估计还差了十万八千里，用现在的网络用语就是，我和道之间差了1万个老子。</p><p>活了25年了，很兴庆活到了现在，这个世界，无时无刻都有人在死亡，死亡可能会降于每个人，我们经常会说，这世道不公，为什么，有些人出生就衣食无忧，有些人还在为温饱挣扎，但是，无论如何，在这个世界我们还存在着，在享受着这个世界带来的一切，有好有坏，总归还是会落入黄土。</p><p>人还活着，还是要想办法跟这个世界，好好玩耍，思考过去，展望未来。</p><p>在今年这过去的9个多月，现在看来，其实，过得很混乱，唯一值得高兴的事，也就只有我能把零碎时间用于学英语这件事坚持下来了。</p><p>大概是今年3月份，我觉得每天上下班只是用来看风景，实在有点浪费，思考，这段时间用来干点什么好，发现用了背单词这件事，实在合适，于是，就这样坚持到了现在，还时候，还是会犯懒，中断了2，3天，现在想想，只能说，我对一个技能的掌握，其实并没有怎么上心。</p><p>那对于一个事情坚持了半年时一个什么样的体验呢？很多人会好奇，竟然坚持了半年，那么现在我的英语是不是很棒呢？可惜，现实是很残酷的，就好比，一个普通人无论怎么锻炼的跑步，你也永远达不到奥运冠军的水准。这么一说，那我坚持半年，不就是一件无用功吗？从英语学习的目的来看，我还没达到，通达一门语言的完全的听说读写，不过，我也从没指望就靠点零碎时间学学英语，就可以学会一门语言。回到刚刚提到的跑步例子，一个普通人如果每天坚持跑步，纵然没法获得奥运冠军，但是，对身体还是有很大的益处。我坚持背半年英语单词也一样，虽然，没法用来掌握英语，但是也为我未来掌握英语打好了基础，时间一下就半年了，如果在3月的时候，我没有下决心背点单词，那么这过去的半年，我也就看了无数的窗外风景而已。</p><p>其实，在这半年的背单词，我还是能够慢慢的感受到，我对英语这门语言，没有像过去那么朦胧不懂，实际上，以我现在的词汇量，阅读一些简单的英语报纸，听一些带字幕的英语广播，大概也能听懂，这也让我相信，如果把一件不起眼的事情坚持几年，总归会有收获，打出一开始，我就定下了要坚持3年，现在已经过去了半年，还有2年半，等2年半后，在来看看这段文字，相信那时候，肯定又有一番不同的感悟。</p><p>然而，这半年，除却学习英语以外，其他都很失败。</p><p>工作上，现在想想，我感觉 现在就是一年经验用10年的那种情况，早几个月前，我就发现，我的工作技能停滞不前了，然而，我并不怎么留意，可能我觉得这生活得过且过，计较这么多，徒增烦恼，然而，当一个人停滞不前了，那样未来又能有什么激动人心的东西呢？</p><p>一个人，在某方面开始停滞不前了，如果，不及时调整过来的话，是一件十分危险的事情，而这样危险的东西，已经发生在我身上了，而现在我应该要想想为什么我会停滞不前，然后，又应该怎么解决这个问题。</p><p>没有计划，没有目标。</p><p>一个人停滞不前了，他或许是累了，或许是失去了目标。现在想来，我应该是失去了目标，在失去了明确的目标，又因为，迷恋着路上的风景，不断的闲逛。纵然我没有停下脚步，但是，我已经不知道，我应该去找那个路口，去找那个人生驿站。</p><p>竟然，现在已经有所察觉，也应该，及时作出调整，与其，迷迷糊糊的度过这一生，为何不选择让自己来选择这一生怎么过？</p><p>要解决目前，这个问题，定下一个简单易行，容易坚持的目标，是最重要的，不求一时结果，但愿方向明确。</p><p>最后，用《论语》的一段文字来结束吧</p><blockquote><p>吾日三省吾身</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> lifestyles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 第二周学习笔记 Controller</title>
      <link href="/2015/09/13/ios/cs193p1_controller/"/>
      <url>/2015/09/13/ios/cs193p1_controller/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进入，iOS学习的第二周，这周挺忙的，以至于这周学习iOS的时间就不多了，这周估计也就只能搞懂怎么用好controller</p><span id="more"></span><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>只看Stanford c193p 对于iOS的学习还是远远不够的，除了Stanford的课程，我还发现了，官方提供的入门课程也很值得学习，用于检验对Stanford的教程究竟掌握了多少还是有帮助的</p><p><a href="https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift">https://developer.apple.com/library/prerelease/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift</a></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>一个应用最核心的一个地方，就是要如何控制页面的跳转，Stanford的教程就重点说了一个Split view controller, 这个是远远不够的，我们还需要认真去读官方文档，学习每种controller的用法</p><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewControllerCatalog/Introduction.html#//apple_ref/doc/uid/TP40011313-CH1-SW1">官方Controller文档</a></p></blockquote><h3 id="Segue"><a href="#Segue" class="headerlink" title="Segue"></a>Segue</h3><p>就我目前所知两个controller 之前进行交互式的时候，我们要熟悉controller的两个方法</p><h4 id="全自动"><a href="#全自动" class="headerlink" title="全自动"></a>全自动</h4><pre><code class="swift">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123;&#125;</code></pre><p>如果，我们只使用storyboard控制按钮跳转到另外一个controller，只要搞懂这个方法的用法就行了。</p><p>当我们使用storyboard 连好线后，点击那个button，系统就会自动的调用这个方法</p><p>对于这个方法，我们需要搞懂UIStoryboardSegue 这个类的用法</p><p>关于这个类，我们关键需要知道</p><ul><li>UIStoryboardSegue.destinationViewController</li><li>UIStoryboardSegue.identifier</li></ul><p>第一个UIStoryboardSegue.destinationViewController，这个告诉了，我们跳转的controller 是一个什么类型的controller，一般，我们这个时候就会使用as? 转型成我们目标conroller，然后开始对这个目标controller进行操作</p><p>第二个UIStoryboardSegue.identifier，这个是segue唯一标识，我们，在storyboard每连一条线，都需要设置id。用于设别我们是点击的是哪个button触发了这次跳转</p><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>除了在storyboard手动的对每个button连线跳转controller，当然也可以我们手动触发controller，这个时候，我们就需要以下这个方法</p><pre><code class="swift">performSegueWithIdentifier(identifier: String?, sender: AnyObject?)</code></pre><p>调用这个方法前，记得先在controller，对目标controller 进行连线，这次的连线是两个controller之间。</p><h3 id="一些要注意的地方"><a href="#一些要注意的地方" class="headerlink" title="一些要注意的地方"></a>一些要注意的地方</h3><h4 id="千万不要在prepareForSegue期间对outlet进行直接赋值"><a href="#千万不要在prepareForSegue期间对outlet进行直接赋值" class="headerlink" title="千万不要在prepareForSegue期间对outlet进行直接赋值"></a>千万不要在prepareForSegue期间对outlet进行直接赋值</h4><p>如果，你需要在跳转的时候，对目标controller进行一些outlet初始化，注意，不要直接赋值，因为prepareForSegue的时候，你的outlet还没实例化。</p><p>要需要赋值的话，这里介绍两种方式</p><h5 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear"></a>viewWillAppear</h5><p>在controller 显示的时候，进行修改</p><pre><code class="swift">@IBOutlet weak var segueTitle: UILabel!var helloSegue: String = &quot;default&quot;override func viewWillAppear(animated: Bool) &#123;        super.viewWillAppear(animated)        segueTitle.text = helloSegue    &#125;</code></pre><h4 id="使用观察者模式"><a href="#使用观察者模式" class="headerlink" title="使用观察者模式"></a>使用观察者模式</h4><p>这个是我比较需要的方式，利用didSet这个特性，对outlet进行修改</p><pre><code class="swift">@IBOutlet weak var segueTitle: UILabel! &#123;        didSet&#123;            segueTitle.text = helloSegue        &#125; &#125;var helloSegue: String = &quot;default&quot;</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>当我们，网络读取图片的时候，这是一个比较耗时的操作，一般而言，我们是不会在主线程做这种事情，这个时候，我们就需要知道如何把一个操作放到另外一个线程操作，然后再把数据返回回来，在主线程进行显示。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stanford cs193p 10节课总结</title>
      <link href="/2015/09/05/ios/cs193p1_10/"/>
      <url>/2015/09/05/ios/cs193p1_10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学了一周的iOS for swift，这周放多了一天的假，于是在我看完10节课后有足够的时间进行总结和反思。</p><span id="more"></span><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>swift 跟这课程走用了一周，感觉是一个很好用的语言，而且对于我这种写过java，js转过来的程序猿来说，只要熟悉一些语法就能够很快的上手了，对于入门而言，swift在ios学习的初期基本没有任何学习上障碍。</p><p>不过，Stanford的课程用的是swift 1.0版本，在一些小细节上跟1.2有点不同，需要特别注意一下</p><ul><li>定义了let，如果没在定义的时候进行初始化，就要在init的时候对所有可能的情况都要初始化</li></ul><pre><code class="swift">class Person &#123;  let name  init(name: String)&#123;    if !name.isEmpty &#123;       self.name = name    &#125; else &#123;       // 常量的初始化一定要在所有分支上都处理了，不然就会编译错误       //Return from initializer without initializing all stored properties       self.name = &quot;&quot;    &#125;  &#125;&#125;</code></pre><p>对于目前我的理解而言，大部分情况还是<code>var</code>比较方便，我不怎么理解Stanford课程提供的代码中，对<code>let</code>的值进行赋值修改。</p><ul><li>熟悉swift在iOS的各种api这个只能靠多用来熟悉了</li></ul><p>总得来说，<code>swift</code>对刚接触iOS的初学者而言非常友好。</p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>iOS上的view真的让我打开眼界，像我这种之前写android的，真不知道原来IDE还能够这么强大，在xcode上，你可以非常便捷连接可视化的view和代码，直接图形化操作，非常直观方便。</p><p>而且还能实时预览自定义view，用<code>@IBInspectable</code>标记代码的变量，那个标记的变量能在可视化界面直接修改，这类操作，是我这个android程序员没法想象的。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>我以前一直很好奇iOS的界面跳转时怎么进行操作的</p><p>现在知道，ios可以直接在storyboard处理各种跳转，直接在界面拖就好了</p><ul><li>View Controller<blockquote><p>UITabBarController<br>UISplitViewController<br>UINavigationController<br>UITableViewController</p></blockquote></li></ul><p>熟悉以上几个基本上可以构建一个比较简单的app</p><p>其中<code>UITableViewController</code>非常强大，也非常复杂，需要下功夫认真学习</p><ul><li>Segua<blockquote><p>prepareForSegue</p></blockquote></li></ul><p>以我目前的认知，两个<code>View Controller</code> 是通过一个名为segua的东西进行交互。</p><h3 id="AutoLayout"><a href="#AutoLayout" class="headerlink" title="AutoLayout"></a>AutoLayout</h3><p>我以前一直很好奇iOS是怎么做不同尺寸的屏幕的适配，学了一节课，一个大致的印象，就是全手工配置。</p><p>相比，android的懒人屏幕适配，ios在不同尺寸的屏幕上的适配就需要下更多的功夫，还好xcode非常给力，这个适配除了要用点心以外，就没什么障碍了。</p><p>对于AutoLayout的理解和使用，还是要多多的上手练习，只看书的话对autolayout的使用帮助不大。</p><p>多练习，这是我现在对autolayout最大的感受了。</p><h3 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h3><ul><li>dispatch_async()</li><li>dispatch_get_main_queue()</li></ul><p>ios 的线程模型刚接触，我感觉到很不可思议，对于一些耗时操作，直接丢到<code> dispatch_async()</code>执行，有结果回来直接执行<code>dispatch_get_main_queue()</code> 对界面操作就完了。真的是不可思议的简单！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用了一周的时间，看了Stanford 10节课，内容有些多，平时还得上班，只有晚上那几个小时，时间实在是不够，还好这周还多放了一天，不然，这周连个总结都写不了。下周的安排，个人感觉还是以消化这周学习的内容为主，不打算继续看新课了，用一周的时间，消化完这周学习的内容，就继续接下来的课。</p><p>希望这样学习一个月后，可以写一个简单的app！</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0701 - 0713</title>
      <link href="/2015/07/13/weekly/20150701_0713/"/>
      <url>/2015/07/13/weekly/20150701_0713/</url>
      
        <content type="html"><![CDATA[<p>已经变成双月刊了…</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="英语学习报告"><a href="#英语学习报告" class="headerlink" title="英语学习报告"></a>英语学习报告</h3>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0608 - 0630</title>
      <link href="/2015/06/30/weekly/20150608_0630/"/>
      <url>/2015/06/30/weekly/20150608_0630/</url>
      
        <content type="html"><![CDATA[<p>慢慢变成月刊了…</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="英语学习报告"><a href="#英语学习报告" class="headerlink" title="英语学习报告"></a>英语学习报告</h3>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0511 - 0525</title>
      <link href="/2015/06/08/weekly/20150526_0607/"/>
      <url>/2015/06/08/weekly/20150526_0607/</url>
      
        <content type="html"><![CDATA[<p>双周刊..</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="英语学习报告"><a href="#英语学习报告" class="headerlink" title="英语学习报告"></a>英语学习报告</h3>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0511 - 0525</title>
      <link href="/2015/05/25/weekly/20150511_0525/"/>
      <url>/2015/05/25/weekly/20150511_0525/</url>
      
        <content type="html"><![CDATA[<p>双周刊..</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h3 id="从0到1：开启商业与未来的秘密"><a href="#从0到1：开启商业与未来的秘密" class="headerlink" title="从0到1：开启商业与未来的秘密"></a>从0到1：开启商业与未来的秘密</h3><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="英语学习报告"><a href="#英语学习报告" class="headerlink" title="英语学习报告"></a>英语学习报告</h3>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Fragment Tips</title>
      <link href="/2015/05/15/android/android_fragment_tips/"/>
      <url>/2015/05/15/android/android_fragment_tips/</url>
      
        <content type="html"><![CDATA[<p>##前言</p><p>Android 3.0 以后的引入的fragment,现在基本已经成为开发android程序必不可少的东西,期间,虽然有人对fragment提出反对<a href="http://corner.squareup.com/2014/10/advocating-against-android-fragments.html">advocating-against-android-fragments</a></p><p>虽然如此,我们还是要学会使用fragment.</p><p>目前,对于fragment机制,其实来来去去也就是官方那几张图的复述,所以,本文着重说说fragment使用tips,希望能给大家一点启发</p><span id="more"></span><h2 id="使用support-不使用官方api"><a href="#使用support-不使用官方api" class="headerlink" title="使用support,不使用官方api"></a>使用support,不使用官方api</h2><p>很多人慢慢的吧app的sdk提高到android 4.0,为了减少support包几百k的容量而去使用原生支持的fragment api.</p><p>实际上,这个不是很可取的做法,早期的fragment 实现是有不少bug的,而且,一些新增,但是很有用的api,并没有在早期sdk出现,例如,</p><pre><code>public final FragmentManager getChildFragmentManager ()</code></pre><p>这个获取fragment自身的fragmentmanager官方sdk要到4.2才支持,为了省几百k的字节让自己难受,实在得不偿失.</p><h2 id="尽可能动态生成Fragment"><a href="#尽可能动态生成Fragment" class="headerlink" title="尽可能动态生成Fragment"></a>尽可能动态生成Fragment</h2><h2 id="FragmentManager-的栈管理实践"><a href="#FragmentManager-的栈管理实践" class="headerlink" title="FragmentManager 的栈管理实践"></a>FragmentManager 的栈管理实践</h2><h3 id="栈监听"><a href="#栈监听" class="headerlink" title="栈监听"></a>栈监听</h3><h3 id="栈后退"><a href="#栈后退" class="headerlink" title="栈后退"></a>栈后退</h3><h3 id="栈任务"><a href="#栈任务" class="headerlink" title="栈任务"></a>栈任务</h3><h2 id="FragmentTransaction-的操作"><a href="#FragmentTransaction-的操作" class="headerlink" title="FragmentTransaction 的操作"></a>FragmentTransaction 的操作</h2><h3 id="add-x2F-show-x2F-hide"><a href="#add-x2F-show-x2F-hide" class="headerlink" title="add&#x2F;show&#x2F;hide"></a>add&#x2F;show&#x2F;hide</h3><h3 id="replace-x2F-remove"><a href="#replace-x2F-remove" class="headerlink" title="replace&#x2F;remove"></a>replace&#x2F;remove</h3><h2 id="Fragment-特别方法"><a href="#Fragment-特别方法" class="headerlink" title="Fragment 特别方法"></a>Fragment 特别方法</h2><pre><code class="java">setRetainInstancesetTargetFragmentstartActivityForResult</code></pre>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0427 - 0510</title>
      <link href="/2015/05/10/weekly/20150427_0510/"/>
      <url>/2015/05/10/weekly/20150427_0510/</url>
      
        <content type="html"><![CDATA[<p>5.1 假期睡了几天,然后这个系列,看来要彻底成为双周刊了</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h3 id="禅与摩托车"><a href="#禅与摩托车" class="headerlink" title="禅与摩托车"></a>禅与摩托车</h3><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0413 - 0426</title>
      <link href="/2015/04/27/weekly/20150413_0426/"/>
      <url>/2015/04/27/weekly/20150413_0426/</url>
      
        <content type="html"><![CDATA[<p>本来的每周回顾,由于上周加班了,所以变成双周了.</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h3 id="乌合之众"><a href="#乌合之众" class="headerlink" title="乌合之众"></a>乌合之众</h3><p>看完了,乌合之众,最大的收获就是解答了,文革为什么会发生,人为什么会在群体中丧失理智</p><h4 id="群体的思考"><a href="#群体的思考" class="headerlink" title="群体的思考"></a>群体的思考</h4><p>乌合之众对于群体的行为,提出了一个观点,就是群体是没有智商可言.这个观点,对于受过教育的人来说,是很反直觉的.因为,小时候的教育,就是三个臭皮匠胜过一个诸葛亮.而乌合之众所说的群体是没有智商的,这就与我们平时的经验有所矛盾.</p><p>实际上,认真思考,其实,这里并不矛盾.</p><p>首先,如何才算一个群体?三个臭皮匠能算一个群体吗?</p><p>三个臭皮匠并不能算一个群体,以群体来看,起码30个臭皮匠才能算群体.</p><p>而这个也很符合我们平时的结构,以军队的管理结构来看,班排连团旅师军,都是以小团体,来管理群体.</p><p>这样做的原因,明显就是群体只能遵循某种规则来活动,而不能有一种称之为群体的思考.</p><h4 id="群体的行为"><a href="#群体的行为" class="headerlink" title="群体的行为"></a>群体的行为</h4><p>有些时候,这个世界会发生一些我们作为个体来看,很不能理解的东西,例如中国的大跃进,十年文革,法国的巴黎大革命,德国纳粹,日本军国主义</p><p>这些,都曾经让我深感困惑,人的道德水平,怎么能够做出如此残暴的事情.</p><p>在读完了这本书,我觉得,对于一个群体,发生再怎么残暴的事情也不是什么很意外的事情.</p><p>对于一个群体而言,它是没有思考的,它的行为,会受制于某种控制之下,例如,群体中有一种暗示,就是犹太人都是敌人,要屠杀光.当这种暗示,成功的在群体传播,这个群体就自然而然的变成了极端种族群体,虽然,群体中的个体可能会发现有所不对劲,但是,在群体的影响下,并没有什么作用.</p><p>那谁在暗示了群体的行为?这个就是上一节提到的群体思考的内容了.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://book.douban.com/subject/1012611/">http://book.douban.com/subject/1012611/</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="英语学习的习惯养成"><a href="#英语学习的习惯养成" class="headerlink" title="英语学习的习惯养成"></a>英语学习的习惯养成</h3><p>从三月初开始坚持每天学习英语(主要以背单词为主),坚持到了现在.</p><p>简单,做了个小测试,发现,词汇量的确有所长进,但是,在英语阅读,特别是长文阅读,并没有什么长进.</p><p>关于这点,思考了一下,对于英语,砖我是有了,但是,造房子的设计图纸,并没有跟上,下个月,开始,英语学习,就要开始关注,英语的语法,听力的练习.</p><p>争取,6月的时候,我的英语水平有一个阶段性的进步</p>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回顾0401 - 0412</title>
      <link href="/2015/04/12/weekly/20150406_0412/"/>
      <url>/2015/04/12/weekly/20150406_0412/</url>
      
        <content type="html"><![CDATA[<p>从这个月开始,每周都对自己的读书,思考进行一个回顾思考.</p><p>由于上周,由于种种原因没写,所以这次把上周的补上.</p><span id="more"></span><h2 id="文化娱乐"><a href="#文化娱乐" class="headerlink" title="文化娱乐"></a>文化娱乐</h2><h3 id="人人都能学英语"><a href="#人人都能学英语" class="headerlink" title="人人都能学英语"></a>人人都能学英语</h3><p>清明假期,把这本书看完,最大的感受就是,标题说的是英语学习,实际上说的是以英语为蓝本,叫你如何去学习.</p><p>我把这书的学习方法总结为如下</p><h5 id="学习是一个长期的事情"><a href="#学习是一个长期的事情" class="headerlink" title="学习是一个长期的事情"></a>学习是一个长期的事情</h5><p>现在,大部分对于学习就是三分钟热度,或者,认为短期努力一把就能学好,但是,对于大部分,天资一般般的凡人来说,指望在一周,甚至一个月掌握一个对往后几十年都用得上的技能,这似乎是一个不切实际的事情.</p><p>在我看来,学习这种东西,如果每天能集中2个小时学一样东西,坚持半年才能小成.</p><h5 id="开始比一切都重要"><a href="#开始比一切都重要" class="headerlink" title="开始比一切都重要"></a>开始比一切都重要</h5><p>在学习的过程中,很多人都会想很多”学习方法”,什么叫做事半功倍,但是,很多时候,在一开始学习的时候,你还不需要考虑什么学习方法,而往往,人很多时候就会在一开始,尝试寻找所谓的学习方法,而让学习热情冷却了.</p><p>在我看来,寻找,所谓的”学习方法”,起码也得学习开始半年以后,对于自己所学的东西,有一定的体系了解,才能懂得什么学习方法才是合适自己的.</p><h5 id="计划与完成"><a href="#计划与完成" class="headerlink" title="计划与完成"></a>计划与完成</h5><p>在学习的时候,最难的不是学不会,而是,如何定合适的计划,并且坚持执行完成下去.</p><p>定学习计划,一定要量力而为,并且,适时调整,不能定下一些,看上去很好,但是,实际上却是完成不了.我相信,一个智力正常的人,学一样不是很难的东西,最后,都是可以用时间来填的.例如,一个计划,你定下一个月要完成,实际上,一个月完成不了,就调整为2个月,虽然,你要多花一个月时间,但是,你想想这个技能能用上几十年,多花一个月实际上不算什么.因为,一旦放弃,浪费的就不仅仅一个月时间了.</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://zhibimo.com/explore/everyone-can-use-english">http://zhibimo.com/explore/everyone-can-use-english</a></p><h3 id="创客"><a href="#创客" class="headerlink" title="创客"></a>创客</h3><p>&lt;长尾理论&gt;, &lt;免费&gt; 的作者在 07年出版的一本书,这是一本关于3d打印的,以及开源硬件的看法的一本书.</p><p>5年过后,来看这本书,你会,发现这5年的变化,实际上没有什么变化,虽然,开源硬件,3d 打印还是一个话题,但是,离革命还很远.</p><p>开源硬件还只是小众人的娱乐.而3d 打印还是一个美好的未来,但是,不是现在.</p><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="http://book.douban.com/subject/20365163/">http://book.douban.com/subject/20365163/</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="不可避免之事"><a href="#不可避免之事" class="headerlink" title="不可避免之事"></a>不可避免之事</h3><p>人的一生会有几十年,在这几十年里,难免会发生一些,悲伤的,高兴的事情,</p><p>这周,我妈就住院了.关于这个思考,还是月底再说吧.</p>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十年青春,十年网文</title>
      <link href="/2015/03/31/lifestyles/readtenyearsnovel/"/>
      <url>/2015/03/31/lifestyles/readtenyearsnovel/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>继续挖坑</p>]]></content>
      
      
      <categories>
          
          <category> lifestyles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle For Android 实用手册</title>
      <link href="/2015/02/28/android/gradle_for_android_toc/"/>
      <url>/2015/02/28/android/gradle_for_android_toc/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>暂定目录</p><span id="more"></span><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h2 id="安装-x2F-配置"><a href="#安装-x2F-配置" class="headerlink" title="安装&#x2F;配置"></a>安装&#x2F;配置</h2><h2 id="Gradle命令介绍"><a href="#Gradle命令介绍" class="headerlink" title="Gradle命令介绍"></a>Gradle命令介绍</h2><h2 id="打包实践"><a href="#打包实践" class="headerlink" title="打包实践"></a>打包实践</h2><h3 id="Debug-x2F-Release"><a href="#Debug-x2F-Release" class="headerlink" title="Debug&#x2F;Release"></a>Debug&#x2F;Release</h3><h3 id="多发行渠道包"><a href="#多发行渠道包" class="headerlink" title="多发行渠道包"></a>多发行渠道包</h3><ul><li>包名变化</li><li>特殊闪屏</li></ul><h2 id="使用Jenkins自动化打包"><a href="#使用Jenkins自动化打包" class="headerlink" title="使用Jenkins自动化打包"></a>使用Jenkins自动化打包</h2><h2 id="Gradle-单元测试"><a href="#Gradle-单元测试" class="headerlink" title="Gradle 单元测试"></a>Gradle 单元测试</h2><h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014败家回顾</title>
      <link href="/2015/01/19/summary/2014newdevices/"/>
      <url>/2015/01/19/summary/2014newdevices/</url>
      
        <content type="html"><![CDATA[<h2 id="败家目录"><a href="#败家目录" class="headerlink" title="败家目录"></a>败家目录</h2><span id="more"></span><h2 id="DJI大疆创新-Phantom-2-Vision-航拍飞行器"><a href="#DJI大疆创新-Phantom-2-Vision-航拍飞行器" class="headerlink" title="DJI大疆创新 Phantom 2 Vision 航拍飞行器"></a>DJI大疆创新 Phantom 2 Vision 航拍飞行器</h2><h2 id="2-4G迷你四轴飞行器"><a href="#2-4G迷你四轴飞行器" class="headerlink" title="2.4G迷你四轴飞行器"></a>2.4G迷你四轴飞行器</h2><h2 id="联想S6000原装蓝牙键盘"><a href="#联想S6000原装蓝牙键盘" class="headerlink" title="联想S6000原装蓝牙键盘"></a>联想S6000原装蓝牙键盘</h2><h2 id="COOX-T3-蓝牙小音箱"><a href="#COOX-T3-蓝牙小音箱" class="headerlink" title="COOX T3 蓝牙小音箱"></a>COOX T3 蓝牙小音箱</h2><h2 id="奥特蓝星iMT630"><a href="#奥特蓝星iMT630" class="headerlink" title="奥特蓝星iMT630"></a>奥特蓝星iMT630</h2><h2 id="kindle-Voyage"><a href="#kindle-Voyage" class="headerlink" title="kindle Voyage"></a>kindle Voyage</h2><h2 id="昂达v989"><a href="#昂达v989" class="headerlink" title="昂达v989"></a>昂达v989</h2><h2 id="红米1s-x2F-小米手环-x2F-小米盒子2G增强版"><a href="#红米1s-x2F-小米手环-x2F-小米盒子2G增强版" class="headerlink" title="红米1s&#x2F;小米手环&#x2F;小米盒子2G增强版"></a>红米1s&#x2F;小米手环&#x2F;小米盒子2G增强版</h2><h2 id="魔豆路由"><a href="#魔豆路由" class="headerlink" title="魔豆路由"></a>魔豆路由</h2><h2 id="极路由1s-x2F-极路由2"><a href="#极路由1s-x2F-极路由2" class="headerlink" title="极路由1s&#x2F;极路由2"></a>极路由1s&#x2F;极路由2</h2><h2 id="天猫魔盒"><a href="#天猫魔盒" class="headerlink" title="天猫魔盒"></a>天猫魔盒</h2><h2 id="iPod-touch-5"><a href="#iPod-touch-5" class="headerlink" title="iPod touch 5"></a>iPod touch 5</h2><h2 id="Mac-Mini-2014款"><a href="#Mac-Mini-2014款" class="headerlink" title="Mac Mini 2014款"></a>Mac Mini 2014款</h2><h2 id="PSV"><a href="#PSV" class="headerlink" title="PSV"></a>PSV</h2><h2 id="PS3"><a href="#PS3" class="headerlink" title="PS3"></a>PS3</h2><h2 id="PSV-TV"><a href="#PSV-TV" class="headerlink" title="PSV TV"></a>PSV TV</h2><h2 id="3ds"><a href="#3ds" class="headerlink" title="3ds"></a>3ds</h2><h2 id="森海塞尔pcx-200"><a href="#森海塞尔pcx-200" class="headerlink" title="森海塞尔pcx 200"></a>森海塞尔pcx 200</h2><h2 id="AKG-K514-MKII"><a href="#AKG-K514-MKII" class="headerlink" title="AKG K514 MKII"></a>AKG K514 MKII</h2><h2 id="家具"><a href="#家具" class="headerlink" title="家具"></a>家具</h2><h3 id="公牛（BULL）GN-H3060"><a href="#公牛（BULL）GN-H3060" class="headerlink" title="公牛（BULL）GN-H3060"></a>公牛（BULL）GN-H3060</h3><h3 id="施德楼925-35"><a href="#施德楼925-35" class="headerlink" title="施德楼925 35"></a>施德楼925 35</h3><h3 id="PowerCube模方插座"><a href="#PowerCube模方插座" class="headerlink" title="PowerCube模方插座"></a>PowerCube模方插座</h3><h3 id="逸淘-简易笔记本电脑桌置地式懒人床边书桌升降床上移动写字桌子"><a href="#逸淘-简易笔记本电脑桌置地式懒人床边书桌升降床上移动写字桌子" class="headerlink" title="逸淘 简易笔记本电脑桌置地式懒人床边书桌升降床上移动写字桌子"></a>逸淘 简易笔记本电脑桌置地式懒人床边书桌升降床上移动写字桌子</h3><h2 id="游戏光盘"><a href="#游戏光盘" class="headerlink" title="游戏光盘"></a>游戏光盘</h2>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014年终终结报告</title>
      <link href="/2015/01/04/summary/summary2014/"/>
      <url>/2015/01/04/summary/summary2014/</url>
      
        <content type="html"><![CDATA[<p>2013年貌似还没填…2014就结束了…</p><p>专注挖坑100年…</p><p>2016年 这个坑我不填了！</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android内存泄露发现与解决实践</title>
      <link href="/2014/12/23/android/androidmemeoryleakpractice/"/>
      <url>/2014/12/23/android/androidmemeoryleakpractice/</url>
      
        <content type="html"><![CDATA[<p>12月份挖坑文</p><span id="more"></span><p>dumpsys</p><p>hprof-conv</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://eclipse.org/mat/">https://eclipse.org/mat/</a></p><p><a href="http://lmbj.net/blog/android-shell-dumpsys/">http://lmbj.net/blog/android-shell-dumpsys/</a></p><p><a href="https://developer.android.com/tools/debugging/debugging-memory.html">https://developer.android.com/tools/debugging/debugging-memory.html</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从kindle3到kindle voyage</title>
      <link href="/2014/11/23/kindle/k3toky/"/>
      <url>/2014/11/23/kindle/k3toky/</url>
      
        <content type="html"><![CDATA[<p>11月坑文</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> kindle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kindle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac mini 2012 与 Mac mini 2014 X leapmotion</title>
      <link href="/2014/10/23/mac/mac2012andmac2014andleapmotion/"/>
      <url>/2014/10/23/mac/mac2012andmac2014andleapmotion/</url>
      
        <content type="html"><![CDATA[<p>10月份坑文</p>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android 接口模块化实践</title>
      <link href="/2014/09/30/android/androidinterface/"/>
      <url>/2014/09/30/android/androidinterface/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>挖坑文..</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派上的Node.js</title>
      <link href="/2014/08/31/nodejs/nodejsandpi/"/>
      <url>/2014/08/31/nodejs/nodejsandpi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近入手了,最新版本的树莓派 B+, 发现在其上面运行Node.js,实在好玩!</p><span id="more"></span><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><h3 id="更新最新树莓派系统"><a href="#更新最新树莓派系统" class="headerlink" title="更新最新树莓派系统"></a>更新最新树莓派系统</h3><pre><code class="bash">sudo apt-get upgradesudo apt-get update</code></pre><h3 id="安装Node-js-1"><a href="#安装Node-js-1" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>如果是以前的教程,可能是叫你去下载源码编译..以树莓派的性能来编译Node.js的源码,应该至少一个小时吧?</p><p>幸运的而是官方已经提供了,编译的树莓派二进制包,所以就不要再去下源码编译了..</p><pre><code class="bash">wget http://nodejs.org/dist/v0.10.26/node-v0.10.26-linux-arm-pi.tar.gztar -xvzf node-v0.10.26-linux-arm-pi.tar.gznode-v0.10.26-linux-arm-pi/bin/node --version</code></pre><p>接下来写进我们的环境变量</p><pre><code class="bash">vi .bash_profile</code></pre><p>在里面写入</p><pre><code class="bash">PATH=$PATH:/home/pi/node-v0.10.26-linux-arm-pi/bin</code></pre><p>在运行source 更新</p><pre><code class="bash">source .bash_profile</code></pre><p>现在我们有Node命令了</p><pre><code class="bash">node --version</code></pre><p>忽然,感慨当年先驱者为了在树莓派上运行上Node.js 各种折腾…现在真心方便.</p><h4 id="一些意外"><a href="#一些意外" class="headerlink" title="一些意外"></a>一些意外</h4><p>如果运行</p><pre><code class="bash">sudo npm install -g forever</code></pre><p>发现,报找不到npm命令,那你需要吧node的运行目录写到sudo运行环境</p><pre><code class="bash">sudo vi /etc/sudoers</code></pre><p>找到</p><pre><code>Defaults       secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</code></pre><p>在原来的基础上加上你的node环境</p><pre><code>Defaults       secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/pi/node-v0.10.26-linux-arm-pi/bin&quot;</code></pre><p>现在运行,就不会报错了.</p><pre><code class="bash">sudo npm install -g forever</code></pre><h2 id="远程控制Led-灯"><a href="#远程控制Led-灯" class="headerlink" title="远程控制Led 灯"></a>远程控制Led 灯</h2><p>环境搞定了,接下来就是开始编写我们的控制程序了!</p><h3 id="gpio-库"><a href="#gpio-库" class="headerlink" title="gpio 库"></a>gpio 库</h3><p>有兴趣了解树莓派的,可以去下面这个link,了解一下树莓派的gpio口,为什么树莓派能够这么火,其魅力就是这gpio口了.</p><blockquote><p><a href="https://github.com/rakeshpai/pi-gpio">https://github.com/rakeshpai/pi-gpio</a></p></blockquote><p>这个gpio库,更新挺及时的,已经支持B+了.</p><p>默认情况下,要访问树莓派的gpio口是需要管理员权限的.所以,我建议在装多一个东西吧</p><pre><code class="bash">git clone git://github.com/quick2wire/quick2wire-gpio-admin.gitcd quick2wire-gpio-adminmakesudo make install</code></pre><p>对于我们的远程控制一个led灯的软件环境准备已经完成,接下来就开始写Node代码吧.</p><p>最终效果可以移步下面这个link观看</p><blockquote><p><a href="http://www.miaopai.com/show/xwnY1Sgn6IOOlIQLk9cSLw__.htm">http://www.miaopai.com/show/xwnY1Sgn6IOOlIQLk9cSLw__.htm</a></p></blockquote><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><pre><code class="js">var http = require(&#39;http&#39;)var gpio = require(&#39;pi-gpio&#39;)var fs = require(&#39;fs&#39;)var errHandler = function (err)&#123;    console.log(err);&#125;gpio.open(8, &quot;output&quot;, function (err) &#123;    if(err)&#123;        console.log(&#39;已经打开&#39;);    &#125;&#125;)http.createServer(function (req, res)&#123;    if(req.url == &#39;/led/open&#39;) &#123;        res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text/plain&#39;&#125;);        gpio.write(8, 1, errHandler);        res.end(&#39;open&#39;)        return;    &#125;    if(req.url == &#39;/led/close&#39;)&#123;        res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text/plain&#39;&#125;);        gpio.write(8, 0, errHandler);        res.end(&#39;close&#39;);        return;    &#125;    res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text/html&#39;&#125;);    res.end(fs.readFileSync(&#39;index.html&#39;));&#125;).listen(1984);console.log(&#39;server runn at 1984&#39;);</code></pre><p>你刚刚看到的视频效果,背后的代码不到50行…如果,写好一些.估计可以压缩不到20行..</p><p>因为这代码没什么技术可言..所以,今天就到此为止了吧..</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android 事件机制的实现与实践</title>
      <link href="/2014/07/31/android/andorideventemitter/"/>
      <url>/2014/07/31/android/andorideventemitter/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>挖坑</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014 Hangjs 见闻流水账第二天</title>
      <link href="/2014/06/29/nodejs/hangjs2014two/"/>
      <url>/2014/06/29/nodejs/hangjs2014two/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一天传送门: <a href="http://cnodejs.org/topic/53aa6d6dc3ee0b58206c7b3f">2014 Hangjs 见闻流水账第一天 </a></p><p>写作风格跟第一天还是一样的.</p><span id="more"></span><h2 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h2><p>每个slide我都会根据自己的理解重新命名一次,用于表达自己的第一看法,主观意见,不喜可吐槽,但是不要喷,就算要喷请轻碰…</p><h3 id="angular-大法好"><a href="#angular-大法好" class="headerlink" title="angular 大法好"></a>angular 大法好</h3><p>今天第一场slide是由<a href="http://weibo.com/isofish">Sofish</a>带来的关于如何<a href="http://sofi.sh/2412">优化你的Angular Web App</a>.</p><p>作为一名angular用户,这次slide分享的切换路由状态的监听事件,是个不错的收获,之前的loading状态都是到处定义开始-结束和标识,或者自定义一个服务来进行全局控制.有内置的话就不需要每次碰到都自己写了.</p><p>不过,对于angular的代码组织的说明,还是通用方案(例如使用<a href="https://github.com/angular/angular-seed/">angular-seed</a>),这个通用方案的最大的弊病就在于,随着项目的业务越来越复杂,单文件的代码量会越来越大,后来Q&amp;A也有人提了我同样的问题,不过,Sofish 简单回答带过.</p><p>对于没有去hangjs的同学,这个slide关于angular的优化很值得一看…</p><p>PS: 这个PPT在现场看的时候,异常辛苦(字完全看不清),吴老师吐槽这个slide的文字背景对比度太没考虑现场的投影设备环境了…</p><h4 id="视频传送门"><a href="#视频传送门" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/oMuGAFbPnf8/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/09.Sofish-%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84Angular%20Web%20App.mov">又拍云</a></td></tr></tbody></table><h3 id="如何成为一名优秀的githuber"><a href="#如何成为一名优秀的githuber" class="headerlink" title="如何成为一名优秀的githuber"></a>如何成为一名优秀的githuber</h3><p>这次slide由<a href="http://weibo.com/137601206">郭宇</a>,分享的<a href="https://github.com/jsconfcn/hangjs/blob/gh-pages/slides/GuoYu-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4-%E6%88%91%E7%9A%84%E5%BC%80%E6%BA%90%E4%B8%80%E5%B9%B4.md">开源项目的管理与维护</a></p><p>作为一名github的活跃用户,这场由github 超活跃的用户带来的演讲,有不少启发的地方.</p><h4 id="开源项目的兴奋点"><a href="#开源项目的兴奋点" class="headerlink" title="开源项目的兴奋点"></a>开源项目的兴奋点</h4><p><a href="http://weibo.com/137601206">郭宇</a> star 数最大的项目就是那个命令行的<a href="https://github.com/turingou/douban.fm">豆瓣电台</a> 现在是978, 其实,我是万万没想到(这个douban.fm,我是从刚开始看到现在,我还贡献了几个PR),原来大家对于能够用命令行播放在线音乐的兴趣是这么大的,不知道是真解决了自己的需求,还只是为了炫酷?</p><p>我认识的一部分github朋友,为什么开坑,不填坑.很多原因都是因为,没人关注啊.写了也没什么反响,没有了自我满足那块(不少开坑的作者,就是冲着自我满足),也就没有动力去填坑了.所以,如果是要打算开一个能够自我满足的坑,在开坑的时候,最后,看一下当前的IT热点,例如,ios 的swift.这样的开坑,获得各种眼球的机会大大挣大.可能有人会说,这样是不是不负责任的行为?</p><p>我个人看法,作为一个凡人,获得一些小小的自我满足,其实也没什么,如果你能够针对问题提issue,而不是看地图炮就好,其实,不少开坑的作者,还是很喜欢有人针对他的坑,提一些意见.不过,开坑的话,有时候难免会碰到几个莫民奇妙的喷子,对于这些喷子,一开始倒是挺生气的,不过,后边会发现,随着关注度提高到一定程度,喷子必有,也没必要为了纠结这几个喷子,而影响了正常的心情.</p><h4 id="开源项目的自我满足"><a href="#开源项目的自我满足" class="headerlink" title="开源项目的自我满足"></a>开源项目的自我满足</h4><p>如何开坑(建立开源项目),其实是个很大的问题,我认识的不少拥有github账号的朋友,很多就是一些僵尸,甚至几年来,github活动主页全部是0.个人觉得,这种现象的产生,是因为,他们很多时候都没法从写代码中获得到足够的满足,连自己的都没法满足,又如何能够满足他人呢?又如何能够把开坑当成一种有趣的事情来做呢?个人看法,切勿地图炮….</p><p>在自我满足达到一定程度,就会自然而然的负起责任来.</p><h4 id="视频传送门-1"><a href="#视频传送门-1" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/ZSV7-gydgsQ/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/10.%E9%83%AD%E5%AE%87-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E7%BB%B4%E6%8A%A4.mov">又拍云</a></td></tr></tbody></table><h3 id="思考如何组织管理大型JS项目"><a href="#思考如何组织管理大型JS项目" class="headerlink" title="思考如何组织管理大型JS项目"></a>思考如何组织管理大型JS项目</h3><p>由EF 教育的<a href="https://github.com/mikaelkaron">Mikael Karon</a>带来的<a href="http://2014.jsconf.cn/slides/mikaelkaron-massivejs/massive-js.html">Massive Javascript Development</a></p><p>老实说,完全没听懂.后来还是看<a href="http://weibo.com/sharpmaster">民工精髓V</a> 的微博,才知道说的是一些很高深的内容</p><blockquote><p>…这老外讲的架构方面的主题，可能因为我平时比较关注这方面，所以毫无压力听懂说的每个东西，然后还在微博上实时翻译记录了。手机打字速度太慢了，下次来听还是得带电脑。老外讲的要点就是，对于大型项目，要模块化，开发阶段小粒度，部署阶段大粒度。真精辟，我也这么想。</p></blockquote><blockquote><p><a href="http://weibo.com/1858846672/Ba9NkEPoO">这个老外讲的切中大型工程的要点:模块化，开发阶段小粒度，部署阶段大粒度</a></p></blockquote><p>有兴趣的去看看</p><h4 id="视频传送门-2"><a href="#视频传送门-2" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/fqKtbaP0DIA/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/11.Mikael%20Karon%20-%20Massive%20Javascript%20Development2.mov">又拍云</a></td></tr></tbody></table><h3 id="并不诱人的轮子-–-TroopJS"><a href="#并不诱人的轮子-–-TroopJS" class="headerlink" title="并不诱人的轮子 – TroopJS"></a>并不诱人的轮子 – TroopJS</h3><p>还是EF 教育的人,<a href="https://github.com/garryyao">Garry Yao</a>,关于<a href="http://2014.jsconf.cn/slides/garryyao-troopjs/scalable-web-application-with-troopjs.html">Scalable Web Application with TroopJS</a></p><p>这个slide完全没听进去…</p><h4 id="视频传送门-3"><a href="#视频传送门-3" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/JKNKWW_yZrw/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/12.Garry%20Yao%20-%20Scalable%20Web%20Application%20with%20TroopJS.mov">又拍云</a></td></tr></tbody></table><h3 id="考虑我们是有追求的程序员"><a href="#考虑我们是有追求的程序员" class="headerlink" title="考虑我们是有追求的程序员"></a>考虑我们是有追求的程序员</h3><p>下午第一场,是人见人黑的<a href="http://weibo.com/lifesinger">玉伯</a>的<a href="http://2014.jsconf.cn/slides/how-to-continue-to-grow-up.pdf">如何持续技术学习</a></p><p>如果,你还没有自己的一套自我管理观的话,玉伯这个slide应该对你能够有所启发.</p><p>我对这个slide归纳就是:控制输入,主动思考,最后自我输出.</p><h4 id="视频传送门-4"><a href="#视频传送门-4" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/VUzRIPY6Es8/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/13.%E7%8E%89%E4%BC%AF%20%E5%A6%82%E4%BD%95%E6%8C%81%E7%BB%AD%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0.mov">又拍云</a></td></tr></tbody></table><h3 id="让你的服务快快快"><a href="#让你的服务快快快" class="headerlink" title="让你的服务快快快"></a>让你的服务快快快</h3><p>台湾的<a href="https://github.com/clonn">Caesar Chi</a>带来的<a href="http://2014.jsconf.cn/slides/nodejs_api_connect_jsconfcn_hangjs.pdf">Node.js 與多方服務串接實務</a></p><p>看这个slide题目,你第一反应可能又是准备水一场了吧.因为,连接多个服务商,无非就是各种认证接入,不过,实际上这个slide并没有把重点放在串接上.</p><p>前面,一部分时间讲如何将对接服务进行模块化实践,后边就大谈,如何提高服务端对客户端响应.其中,的一个实践就是</p><blockquote><p>先响应,后处理</p></blockquote><p>客户端发起了一个请求,服务端立马反应给客户端,让客户端知道服务端在处理了,你去干点的吧,结果由服务端主动推送.这样做的好处就是可以让客户端不用等待.</p><p>当然,缺点也有,就是增加了对异常的处理复杂性.举个例子,你提交了一个表单,然后,服务器告诉你,正在处理,于是你去做点别的东西,或者离开,很不幸的是,你表单某个字段有问题,这是,服务器推送了一个异常给你,但是,你已经离开原来页面了,于是,你不知道你的填写是有问题的.还有一个问题就是维持长连接的资源消耗.</p><h4 id="视频传送门-5"><a href="#视频传送门-5" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/h8TuqilJq0w/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/14.Caesar%20Chi%20Node.js%20%E8%88%87%E5%A4%9A%E6%96%B9%E6%9C%8D%E5%8B%99%E4%B8%B2%E6%8E%A5%E5%AF%A6%E5%8B%99.mov">又拍云</a></td></tr></tbody></table><h3 id="Node-js是如何进化为NodeOs"><a href="#Node-js是如何进化为NodeOs" class="headerlink" title="Node.js是如何进化为NodeOs"></a>Node.js是如何进化为NodeOs</h3><p>由NodeOs 作者<a href="https://github.com/groundwater">Jacob Groundwater</a>,分享的<a href="http://2014.jsconf.cn/slides/five-lines.pdf">five-lines 深入浅出 node 命令行工具</a></p><p>这个slide应该是开场几个小时前定下来的,之前日程表上面是没有的,NodeOs记得上一年,大家有过一段讨论,后来就沉了,当时,听到介绍的时候,立马去看了一下<a href="https://github.com/NodeOS/NodeOS">NodeOs</a>的github,发现了个<a href="https://github.com/NodeOS/NodeOS-Docker">docker image</a>,看来还是有点进度的.</p><p>不过,这次slide挺有意思的,正如标题所说,深入浅出,通过对node基本的一些特性(执行shell命令),最后慢慢的做出复杂的东西.例如打造一个Node.js 风格的操作系统,让全部命令执行输出JSON化.</p><p>其实,很多语言都有执行shell命令的api,但是,为什么之前没有人想到要搞个JavaOs,PythonOs…等等(可能也有但是我不知道).这个slide带给我最大的收获,就是要勇于去想象!</p><p>就算是这个想象有点不切实际,但是如果是理论上可行的,为啥不尝试在想象的时候去实践一下?</p><p>而在Node.js 上实际上还真出现了不少想象力丰富的东西,除了前面提到的NodeOs,还有<a href="https://github.com/YaroslavGaponov/node-jvm">Node上的jvm虚拟机</a>,让Node.js做类似于arduino 的<a href="https://tessel.io/">tessel</a>,有些朋友可能会觉得这些东西的可能是个傻x想法,但是,现实是这些东西不但被人想出来,而且还都做出来了,我觉得,当人不愿意去进行想象的时候,也就停止了进步.忽然,想起了老罗的那句语录.</p><blockquote><p>不被嘲笑的梦想，是不值得去实现的</p></blockquote><p>当一个程序员失去想象力的时候,可能也是步向平庸的开始了.</p><h4 id="视频传送门-6"><a href="#视频传送门-6" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/3-3PegdbS6E/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/15.Jacob%20Groundwater%20and%20dead-horse%20-%20five-lines.mov">又拍云</a></td></tr></tbody></table><h3 id="c-和Node-js-相亲相爱"><a href="#c-和Node-js-相亲相爱" class="headerlink" title="c# 和Node.js 相亲相爱"></a>c# 和Node.js 相亲相爱</h3><p>这么多slide里头,唯一一个用windows(其他都用Mac)进行分享的,微软美女程序员<a href="http://irisclasson.com/">Iris</a> 带来的<a href="https://github.com/tjanczuk/edge">Edge.js</a></p><p>实际上就是一个让c#程序里头能够跑Node.js,在Node.js里头能够跑c#,个人不怎么喜欢这玩意,后来也跟老雷讨论了一下这东西,老雷也表示不怎么喜欢.我们俩不怎么喜欢的原因,可能都是因为我们都没接触过c#.</p><p>因为,不怎么感兴趣,所以没什么好说的.</p><h4 id="视频传送门-7"><a href="#视频传送门-7" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/cdedTXM5y28/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/16.Iris%20-%20Edge.js.mov">又拍云</a></td></tr></tbody></table><h3 id="手机传感器在移动web的实践"><a href="#手机传感器在移动web的实践" class="headerlink" title="手机传感器在移动web的实践"></a>手机传感器在移动web的实践</h3><p>天猫前端<a href="http://weibo.com/777865156">鬼道-徐凯</a>带来的<a href="http://2014.jsconf.cn/slides/luics-hybrid-api.html">Hybrid API</a>这是一个你只看题目,怎么也不会猜到要准备说的什么内容的分享(当时看日程表的时候,Hybrid Api? 这是啥东西啊…).</p><p>这个slide分享的是,手机传感器在移动web的使用实践.你可能会惊讶,现在的手机浏览器能够支持传感器了?目前来看,手机浏览器还没支持w3c关于传感器的实现,但是,不妨碍我们的想象力啊,于是,我们可以通过改造手机的web控件,从而让移动web支持手机传感器,然后,利用这个特性,来开发一些特别有趣的东西.</p><p>后边,鬼道就分享天猫app是如何利用这个特性,进行真实项目实践.总得来说,这是一个很具有想象力的分享!</p><h4 id="视频传送门-8"><a href="#视频传送门-8" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/1-Ltio6NGaU/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/17.%E9%AC%BC%E9%81%93%20Hybrid%20API.mov">又拍云</a></td></tr></tbody></table><h3 id="用Node-js玩转Storm"><a href="#用Node-js玩转Storm" class="headerlink" title="用Node.js玩转Storm"></a>用Node.js玩转Storm</h3><p>Luying Li(没找到相关的个人主页)带来的<a href="http://2014.jsconf.cn/slides/Introduction-To-Storm.pdf">Storm - Distributed and fault-tolerant realtime computation</a>分享.</p><p>其实看日程表的时候,看到Storm混进来,顿时在想,这玩意不是用Java写的吗,跟JS有什么关系?会不会跟<a href="http://2014.jsconf.cn/slides/nodejs_api_connect_jsconfcn_hangjs.pdf">Node.js 與多方服務串接實務</a>带来一些意外的惊喜?不过这次,真没什么意外惊喜了.</p><p>大部分时间都是介绍Storm是个什么,举的例子也全部都是Java写的.最后,补充了一下,Storm的实现支持任何语言,Node.js当然不在话下,于是最后贴了两个Node.js实现.那么举例子的时候..为啥不用JS写…感觉好没说服力..这个场子毕竟是JS….你确不用js来举例子.</p><h3 id="来日方长的前端技术革命"><a href="#来日方长的前端技术革命" class="headerlink" title="来日方长的前端技术革命"></a>来日方长的前端技术革命</h3><p>最后一场slide由来自于云适配的<a href="http://weibo.com/chenbenfeng">陈本峰</a>分享的<a href="http://2014.jsconf.cn/slides/WebComponents.JSConf.pdf">Web Components标准：前端开发的新一次技术革命</a></p><p>由于,这个话题,我不怎么感兴趣,然后这场slide的ppt还没放上来,所以,我都忘得差不多这场slide究竟说了些什么..只是印象中知道,这个是几年后才有可能实现的标准.</p><h4 id="视频传送门-9"><a href="#视频传送门-9" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/pKlqYK8s6bY/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/19.%E9%99%88%E6%9C%AC%E5%B3%B0%20-%20Web%20Components%E6%A0%87%E5%87%86%EF%BC%9A%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E6%96%B0%E4%B8%80%E6%AC%A1%E6%8A%80%E6%9C%AF%E9%9D%A9%E5%91%BD.mov">又拍云</a></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次两天的Hangjs, 面基了不少一直在网上有交流但是,从来没见过面的朋友,特别是有机会一起同行的<a href="http://weibo.com/ucdok">老雷</a>,在我看来,参加这类技术大会,还是以认识和交流,各种平时耳闻但不见面的人为主最好,听slide对自己有用的就认真听听,这次hangjs我最大的软肋就是不够主动,没有随便逮住一个人就说,你好,能够简单认识一下吗?这是我的github,来扩大一下自己的人脉起码也可以为自己的<a href="https://github.com/youxiachai">github</a>涨涨粉…).</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>其他人的hangjs 参会记录</p><p><a href="http://weibo.com/p/1001603724334156923311">梁杰_numbbbbb 技术大会到底该怎么听？</a></p><p><a href="http://weibo.com/p/1001603724961759021973">民工精髓V 杭JS参会记录</a></p><p><a href="http://zhuli.me/hang-js-2014/">lisposter Hang-JS-2014</a></p><p><a href="http://www.thinkingincrowd.me/2014/06/25/hangjs-2014/">鹄思乱想 2014 杭JS 杂谈</a></p><p><a href="https://github.com/fsiaonma/fsiaonma.blog.com/issues/5">fsiaonma 继《京JS》后，再遇《杭JS》</a></p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2014 Hangjs 见闻流水账第一天</title>
      <link href="/2014/06/24/nodejs/hangjs2014one/"/>
      <url>/2014/06/24/nodejs/hangjs2014one/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>6月21日~6月22日, 第一次跑远门去参加一个大会(广州 -&gt; 杭州),本来打算,在火车的回来的路上,把这两天的东西记录一下,不过,火车上的环境实在恶劣,同时也高估了自己的专注力,所以,最后还是决定回来再写吧,还可以先看看,别人是怎么写的.在动笔之前,看了一下别人写的,所以,直接略过会议的一些流程,对这个会议的流程有兴趣的可以去看附录的传送门,我觉得他们已经把我本来想写的东西都写了,然后,就直接针对,每个slide说说自己的看法,正如标题所说,就是个流水账…</p><span id="more"></span><h2 id="Slide"><a href="#Slide" class="headerlink" title="Slide"></a>Slide</h2><p>每个slide我都会根据自己的理解重新命名一次,用于表达自己的第一看法,主观意见,不喜可吐槽,但是不要喷,就算要喷请轻碰…</p><h3 id="如何造一个好用的”轮子”"><a href="#如何造一个好用的”轮子”" class="headerlink" title="如何造一个好用的”轮子”"></a>如何造一个好用的”轮子”</h3><p>这次hangjs的第一场是由<a href="http://weibo.com/zensh">严清老师</a>带来的关于<a href="http://2014.jsconf.cn/slides/%E4%B8%A5%E6%B8%85-JavaScript%E5%BC%82%E6%AD%A5%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AF%B9%E6%AF%94.key.zip">thenjs异步编程的实现原理和优缺点</a>分享.</p><p>其实关于JS的异步编程可以算得上是烂大街的主题了,严清老师觉得各家的的异步实现的轮子不好,于是<a href="https://github.com/teambition/then.js">thenjs</a>就诞生.不过,严清老师能实现一个不错的库,但是,在我看来在一个只有40多分钟的slide里大谈具体代码的实现原理,并不合适,花大量时间谈具体的代码实现,在一个只有40多分钟的slide里头是很枯燥的事情(而且,我也不觉得这玩意能够在40分钟里头说清),毕竟这个东西是开源的,粗略的说说实现就好,你对实现感兴趣,去看源码吧!接下来用实际案例说说这个轮子的实现跟其他家轮子的实现有什么不同的地方,这样的不同,带来了什么好的地方.这样,我就对thenjs的异步实现非常感兴趣,从而对异步实现原理有更高层次的理解.毕竟这是一个时间很短的slide,希望能够多说一些能够启发性的东西,而不是具体怎么写.</p><p>如同前面说的js异步编程其实是烂大街的话题,我感觉大家更多想看到各种案例实践,而且我也一开始是以为标题的优缺点会是严清老师,会大说特说在实际开发中,用现用的异步库如何如何被坑,然后决心自己造轮子,用各种血的现实告诉大家,thenjs是如何好用…这样的异步实现是多么的优秀…结果到优缺点的比较主要还是各种基于代码的实现比较….没有任何炫酷的实际案例比较…</p><h3 id="不明觉厉的Node-js-内核嵌入开发"><a href="#不明觉厉的Node-js-内核嵌入开发" class="headerlink" title="不明觉厉的Node.js 内核嵌入开发"></a>不明觉厉的Node.js 内核嵌入开发</h3><p>这个slide 是最近很火的atom编辑器主要作者之一的<a href="https://github.com/zcbenz">赵成</a> 的分享,原标题是 <a href="http://2014.jsconf.cn/slides/Practice%20on%20embedding%20Node.js%20into%20Atom%20Editor.pdf">Atom编辑器嵌入Node.js引擎实践</a>,当时,看到这个标题,我就觉得,我听这个slide就是打打酱油了,因为不可能听懂,作为一个凡人码农,从来都没看过Node.js是怎么实现的,然后,这个slide一上来就跟我们说,如何改造Node.js的引擎,实在是太高端了…实在玩不过来,不过我相信,会场几百号人肯定有人能听懂的,只是我比较low而已…</p><p>不过,一个面向JS程序员的大会,讲如何让Chromium能够运行v8,我不敢表示大多数,但是有一点可以肯定是,很多Node.js程序员并不会编译Chromium,那么更不用说,知道原理后,要动手操作Node.js跟Chromium合体了.作为对atom-shell最了解的人说,面对的大部分JS程序员,我觉得这个slide还不如多多分享一下怎么用atom-shell 快速开发一些跨平台app技巧,然后用一些具体案例对比一下<a href="https://github.com/rogerwang/node-webkit/">node-webkit</a>这两者的优缺点(关于这个优缺点在这次slide上有提到过,不过并没细讲…).</p><p>PS:这次的演讲者作为github员工,说了一些关于github的内部事情,atom本来是打算不开源的,但是,不开源的阵营的主要领导者,因为某次丑闻导致离职,于是atom就开源了…</p><h4 id="视频传送门"><a href="#视频传送门" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/JU112RMWPIQ/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/03.%E8%B5%B5%E6%88%90%EF%BC%9AAtom%E7%BC%96%E8%BE%91%E5%99%A8%E5%B5%8C%E5%85%A5Node.js%E5%BC%95%E6%93%8E%E5%AE%9E%E8%B7%B5.mov">又拍云</a></td></tr></tbody></table><h3 id="Node-js-的胶水时代"><a href="#Node-js-的胶水时代" class="headerlink" title="Node.js 的胶水时代"></a>Node.js 的胶水时代</h3><p>这次的演讲者<a href="https://github.com/threeday0905">赫门</a>带来的是前几个月就开始有讨论的<a href="http://ued.taobao.org/blog/2014/04/full-stack-development-with-nodejs/">前后端分离实践</a>.</p><p>这次的slide,通过两次大战来递进的说目前前后端实践的情况,这个我听着挺带感的,因为,我正好就是<a href="http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/48">第一次前后端分离大战</a>的实践者,然后<a href="http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/51">碰到的问题</a>也跟slide说的一样.</p><p>不过,<a href="http://2014.jsconf.cn/slides/herman-taobaoweb/index.html#/57">第二次前后端分离大战</a>,虽然标题的是第二次,但是,我觉得本质只是第一次前后端分离大战的一个特殊存在,针对的是你的后端业务不是用Node.js来写,于是通过Node.js对后端业务进行一个合并优化,让客户端干少一点事情,提升客户端的响应速度.所以,Node.js就像胶水一样把两个分离的东西粘在了一起.毕竟很多系统都用了十几年了,不太可能再用Nodejs重写一遍,不过利用Node.js作为胶水的功能,针对移动应用的场景对现有系统进行优化,是个不错的实践思路.</p><h4 id="视频传送门-1"><a href="#视频传送门-1" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/_PON-LV6X2E/">土豆</a>)</td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/04.%E8%B5%AB%E9%97%A8-%E6%B7%98%E5%AE%9D%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5.mov">又拍云</a></td></tr></tbody></table><h3 id="不存在的服务-存在的使用"><a href="#不存在的服务-存在的使用" class="headerlink" title="不存在的服务,存在的使用"></a>不存在的服务,存在的使用</h3><p>下午第一场slide是由台湾开发者<a href="https://github.com/peihsinsu">蘇 培欣</a>带来的是,<a href="http://2014.jsconf.cn/slides/JSConf%20-%20Google%20BigQuery%20API%20Node.js%E5%AF%A6%E4%BD%9C%E8%A8%98%E9%8C%84.pdf">Google BigQuery API Node.js实践</a> 看到这个标题,应该明白我为什么对这个slide起了这么一个名字了吧?</p><p>这个slide其实也没什么好说的,就是讲如何使用<a href="https://github.com/peihsinsu/bigquery">bigquery</a> 这个用Node.js写的模组(模块),进行google big query的查询.</p><p>不过,通过这个slide知道了Google bigquery 这个服务,倒是一个不错的收获,对于有大数据需求,但是没有空折腾各种优化的精力,用这个服务倒是省心不少,对了,要速度快,访问google的黑科技是必须要掌握的!</p><h4 id="视频传送门-2"><a href="#视频传送门-2" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/205h9BvigGs/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/05.%E8%8B%8F%E5%9F%B9%E6%AC%A3-Google%20BigQuery%20API%20Node.js%20%E5%AE%9E%E8%B7%B5.mov">又拍云</a></td></tr></tbody></table><h3 id="用管道串流你的思想"><a href="#用管道串流你的思想" class="headerlink" title="用管道串流你的思想"></a>用管道串流你的思想</h3><p>这次slide是由James Halliday来演讲,github是<a href="https://github.com/substack">substack</a>平时,在使用库的时候有关注作者的习惯的话,对于这个github名字应该很熟悉了吧!</p><p>外国人的演讲,你就不要指望外国人能够跟你用中文演讲了.第一次在现场听外国人的演讲,果然是近乎完全听不懂orz.关于<a href="https://twitter.com/substack">@substack</a>的很多趣闻,已经有很多人说过了,这里就不跑题了,还是说说这次slide的收获吧.</p><p>虽然,听不懂说什么,但是不妨碍我看得懂PPT说什么..</p><p>在出发去hangjs的时候正好在使用gulp的时候看了一本substack写的Node.js流编程实践<a href="https://github.com/substack/stream-handbook">stream-handbook</a>,然后这次slide,substack 现场编程show了一把这个思想的具体应用,直到现在我还在消化着,等消化得差不多,在额外写一篇分享吧.</p><p>最后介绍了一个挺好玩的东西<a href="http://voxeljs.com/">voxeljs</a> 基本上就是一个类似于Minecraft 的H5 游戏,不过,可以在上面编程让游戏变得很好玩.</p><h4 id="视频传送门-3"><a href="#视频传送门-3" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/svwrLe0ZTWs/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/06.James%20Halliday-Peer-Directed%20Collaborative%20Projects.mov">又拍云</a></td></tr></tbody></table><h3 id="曲高和寡"><a href="#曲高和寡" class="headerlink" title="曲高和寡"></a>曲高和寡</h3><p>这场slide由来自于中科院的<a href="http://weibo.com/belleveinvis">@belleveinvis</a>分享如何写一个代码生成器的原理,标题: Patrisika - Theoretical and Practical Code Generation.在听这个的slide的过程中,我和<a href="http://weibo.com/spuout">吴老师</a>,表示各种听不懂.因为听不懂,也不好做什么评价了.</p><p>本来,我觉得在一个面向js程序员的大会上讲如何写一个代码生成器是否合适主题?不过,后边翻了一下微博就找到同吐槽看不懂,不过有个看懂了的回复说其实是符合主题的.</p><blockquote><p><a href="http://weibo.com/2039445353/Ba2Fao0N8">跟js同步异步转换有关，所以在这里讲也不过分</a> 具体内容点击传送门吧.</p></blockquote><p>PS: 翻了一下微博,还是有人有不错的收获例如 <a href="http://weibo.com/1651843872/BabaT3RU8">题叶</a></p><p>只能说自己的水平不行..orz</p><h4 id="视频传送门-4"><a href="#视频传送门-4" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/Wm1gC_2kx-k/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/08.Belleve%20Invis%20-%20Patrisika%20-%20Theoretical%20and%20Practical%20Code%20Generation.mov">又拍云</a></td></tr></tbody></table><h3 id="并不新鲜的快速构建MVC应用"><a href="#并不新鲜的快速构建MVC应用" class="headerlink" title="并不新鲜的快速构建MVC应用"></a>并不新鲜的快速构建MVC应用</h3><p>接下来是<a href="http://weibo.com/676588498">芋头</a>分享的 <a href="http://2014.jsconf.cn/slides/Rabbit.js-MVC.pdf">如何快速构建MVC应用</a>.</p><p>实际上这个slide主要是讲<a href="https://github.com/xinyu198736/Rabbit.js">Rabbit.js</a> 的设计思想,传统的mvc 加上一套约定的web框架,跟paypal 的<a href="https://github.com/krakenjs/kraken-js">kraken-js</a>有点类似,不过有个特点就是Rabbit.js 封装了一个Sql 和 nosql的模型定义,可以让你的代码在mysql 和 mongodb 都能够运行的很好.</p><p>芋头在slide上一再强调Rabbit.js还没正式发布,然后,各位有兴趣的话可以看着学习一下,看能不能对自己的开发有所启发.</p><h4 id="视频传送门-5"><a href="#视频传送门-5" class="headerlink" title="视频传送门"></a>视频传送门</h4><table><thead><tr><th align="left">在线播放</th><th align="left">视频下载</th></tr></thead><tbody><tr><td align="left"><a href="http://www.tudou.com/programs/view/qEKEHAeNHTI/">土豆</a></td><td align="left"><a href="http://hangjs.b0.upaiyun.com/videos/07.%E8%8A%8B%E5%A4%B4-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAMVC%E5%BA%94%E7%94%A8.mov">又拍云</a></td></tr></tbody></table><h3 id="原标题存在的矛盾性"><a href="#原标题存在的矛盾性" class="headerlink" title="原标题存在的矛盾性"></a>原标题存在的矛盾性</h3><p>今天最后一场slide是由百度工程师<a href="http://weibo.com/berg">@berg</a> 带来的目前关于如何让H5的应用运行得很流畅的解决方案: <a href="http://2014.jsconf.cn/slides/BlendUI.pdf">BlendUI - 让轻应用如Native般流畅</a></p><p>在这个slide开讲前,我对这个slide其实挺期待的,因为,我一直都有关注h5在app上的应用,对于用h5做的应用,最无解的问题就是动画的流畅性,对于现在,IOS 的原生webview性能已经很好了,在未来的ios8 webview的js引擎终于用上跟safari 一样的引擎,并且支持webgl,然后,随着硬件的各种升级,最终让基于H5的应用达到本地应用的流畅性(未来两年内应该可以实现),不过这都是未来,现在还是老老实实写本地应用吧.</p><p>然后看到这个标题,心里还是挺期待在当前硬件无法得到解决的情况下,是否存在什么黑科技,让H5应用达到一个飞越?</p><p>在听这场slide的时候,果然,不存在什么黑科技! BlendUI 的解决方案,并不是打算死磕纯DOM黑科技实现,而是,应地制宜用了一些技巧.原生DOM动画,不流畅,那么动画这部分,我不用DOM来实现了,直接上本地,这下动画切换的流畅问题就完美解决了.每个页面就是一个webview,页面的切换就是两个webview的本地切换,效果妥妥的流畅! 多webview 内存占用多? 现在千元手机都2G内存了,妥妥的!而且开多个webview其实并没有那么耗内存!</p><p>于是BlendUI 如Native般流畅 实际上因为动画部分就是native, 那还不是如Native般流畅….所以,我说这个标题存在的矛盾性就在这里.不过,可能是我对轻应用的了解不一样,我对轻应用的了解的就是能用纯H5实现,不套壳能用浏览器运行,套壳就是APP,只要有webview控件的平台都能支持.因为轻嘛,所以,跨平台运行妥妥的。</p><p>对于用多webview的动画切换来解决H5类型应用的方案,其实早在一年前我就有尝试过,在这里会有几个坑的,后边after party 找berg实机体验了一把,看来这个坑berg就目前这个版本并没有解决,关于这点,后边after party在展开说.</p><blockquote><p>小插曲: 在提问环节,有个人问berg,目前百度轻应用有没有什么明星应用,如果没记错的话,berg回答的是还没有…</p></blockquote><h2 id="After-party"><a href="#After-party" class="headerlink" title="After party"></a>After party</h2><p>对于每届中国JS开发者大会,最有价值的就是这个after party了,可以面对面的找各种大牛进行交流.</p><h3 id="BlendUI"><a href="#BlendUI" class="headerlink" title="BlendUI"></a>BlendUI</h3><p>我找到了berg,借手机实机体验了一把BlendUI,安装blendui 的轻应用是一台小米2, 有2G 内存.我针对过去研究碰到的坑,立马测试了一下,于是还是碰到了.总结如下:</p><ul><li><p>有一定机率webview和原生控件同时存在一个页面. 这个坑很怪异,挺难重现的,就是你的webview有张图片,你点击这个图片用原生控件来显示,在某种操作的情况下,这个原生显示图片的控件会和webview在你没点击图片的时候同时显示.</p></li><li><p>webview 丢失.这个坑就很好比较容易重现.表现是当你,在点击webview的某张图片后,是显示一个覆盖这个webview图片滑动控件,然后快速后退,在快速点击某个item,重复快速的操作前面的步骤,就会有一定几率无论你点那个item也不会显示webview而是一直显示这个滑动图片控件.</p></li></ul><p>不过BlendUI 并没有正式发布,所以以上bug可能到时候已经修复了.对了,不知道到时候,在目前千元手机1G内存下的表现又会是如何呢?</p><h3 id="随便转转"><a href="#随便转转" class="headerlink" title="随便转转"></a>随便转转</h3><p>我线下的即兴交流能力实在是太差了,跟berg 简单交流了一下,就是走走听一下,大家都在讨论什么,那些围着外国友人的交流的实在高端,简单的听了一下,表示无力….</p><p>期间跟一个大众点评的员工简单交流了一下,发现,大众点评在一些小业务上也用上了Node.js,而且,还用上了docker.</p><p>PS: 我的交流能力有待提高啊….</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>其他人的hangjs 参会记录</p><p><a href="http://weibo.com/p/1001603724334156923311">梁杰_numbbbbb 技术大会到底该怎么听？</a></p><p><a href="http://weibo.com/p/1001603724961759021973">民工精髓V 杭JS参会记录</a></p><p><a href="http://zhuli.me/hang-js-2014/">lisposter Hang-JS-2014</a></p><p><a href="http://www.thinkingincrowd.me/2014/06/25/hangjs-2014/">鹄思乱想 2014 杭JS 杂谈</a></p><p><a href="https://github.com/fsiaonma/fsiaonma.blog.com/issues/5">fsiaonma 继《京JS》后，再遇《杭JS》</a></p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 数组的奇妙用法</title>
      <link href="/2014/06/09/nodejs/userjsarray/"/>
      <url>/2014/06/09/nodejs/userjsarray/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般语言的数组的大多除了存数值,还是存数值,不过对于js而已,数组的用法异常的灵活,本博文,就简单介绍几种技巧.</p><span id="more"></span><h2 id="函数队列"><a href="#函数队列" class="headerlink" title="函数队列"></a>函数队列</h2><p>在敲代码,我们首先要学习JS对象的两个方法,这两个方法在整个js编程中非常重要!</p><ul><li>call <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Function&#x2F;call</a></li><li>apply <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Function&#x2F;apply</a></li></ul><p>阅读完<code>call</code>和<code>apply</code> 的用法后,就开始我们的实例演练.</p><p>有这么一个关于积分规则的需求</p><ol><li>登录5分</li><li>发帖1分</li><li>被删帖-10分</li></ol><p>嗯,思考了十秒以后,你应该会敲下如下代码</p><pre><code class="js">var totalPoint = 0;var action = &#39;&#39;switch (action) &#123;    case &#39;登录&#39;:        totalPoint +=5;        break;    case &#39;发帖&#39;:        totalPoint +=1;        break;    case &#39;被删帖&#39;:        totalPoint -=10;        break;    default :&#125;</code></pre><p>非常直观合理,简单快速实现了我们的需求,增加规则,我们只要增加case就好了…….</p><p>不过十几日后..</p><p>你的PM想到了20条规则(还有诸如,发帖了10个贴就不能增加积分之类的,触发机制.),于是你的<code>switch</code>代码有接近20条以上的分支,而且,每个分支的积分规则都要注意不要放错位置.</p><p>还记得,我们前面学习的<code>call</code> 和 <code>apply</code> 吗,那现在我们用js数组就能够优雅的处理好.</p><p>约定:</p><ul><li>每个规则设定的变量都是一个拥有一个参数,和一个有两个参数的函数.</li><li>每个规则参数的变量都是一个拥有长度为2的数组,第一个为对象,第二个拥有两个参数的函数.</li></ul><pre><code class="js">//规则设定var taskQueue = [];//规则参数var ruleQuery = [];var totalPoint = 0;//参数预置和结果输出var rule1 = [&#39;&#39;, function (result) &#123;    console.log(result);&#125;];ruleQuery[&#39;rule1&#39;] = rule1;//积分规则var task1  = function (params, done) &#123;    done(totalPoint += 5);&#125;taskQueue[&#39;登录&#39;] = task1;var action = &#39;登录&#39;//运行预定规则任务taskQueue[action].apply(null, ruleQuery[&#39;rule1&#39;]);&gt; 5</code></pre><p>乍看,好像比<code>switch</code>的方式复杂不小,这种写法的好处,就是我们只需要定义规则和规则参数,并且填入到数组里面就行,不像<code>switch</code>要关心一大坨case 分支.</p><p>例如刚才提到的</p><blockquote><p>帖了10个贴就不能增加积分之类的</p></blockquote><p>我们只需要稍稍改良一下<code>task</code>的定义</p><pre><code class="js">var totalPoint = 0;var ruleQuery = [];var taskQueue = [];//rule第一个参数可以用于定义发帖的计量.var rule1 = [1, function (result) &#123;    console.log(result);&#125;];ruleQuery[&#39;rule1&#39;] = rule1;//积分规则var task2  = function (params, done) &#123;    if(params &lt; 10)&#123;        totalPoint += 5;    &#125; else &#123;        totalPoint += 0;    &#125;    done(totalPoint);&#125;taskQueue[&#39;发帖&#39;] = task2;taskQueue[&#39;发帖&#39;].apply(null, ruleQuery[&#39;rule1&#39;]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angularjs 学习总结</title>
      <link href="/2014/06/02/html5/angularexam/"/>
      <url>/2014/06/02/html5/angularexam/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用了angularjs 一个多月了,碰碰撞撞的摸索点了东西,写个简单的总结吧.</p><span id="more"></span><h2 id="ngStyle"><a href="#ngStyle" class="headerlink" title="ngStyle"></a>ngStyle</h2><h2 id="ngRepeat"><a href="#ngRepeat" class="headerlink" title="ngRepeat"></a>ngRepeat</h2><h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><h2 id="watch-apply"><a href="#watch-apply" class="headerlink" title="$watch $apply"></a>$watch $apply</h2><h2 id="Service-Factory-Provider"><a href="#Service-Factory-Provider" class="headerlink" title="Service Factory Provider"></a>Service Factory Provider</h2><h2 id="route"><a href="#route" class="headerlink" title="$route"></a>$route</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2>]]></content>
      
      
      <categories>
          
          <category> html5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 也来挑战ACM</title>
      <link href="/2014/05/18/nodejs/jsforoj/"/>
      <url>/2014/05/18/nodejs/jsforoj/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个ACM票友,最近,在微博上看到,有人说现在有支持JS的OJ平台,于是,花了一点时间摸索了一下,为了让更多的js程序员也入坑,于是写一篇快速入门的攻略,让各位用js在ACM圈子里面打出一番天地…..</p><span id="more"></span><h2 id="支持JS的OJ网站"><a href="#支持JS的OJ网站" class="headerlink" title="支持JS的OJ网站"></a>支持JS的OJ网站</h2><p>据我所知,目前有两个OJ平台支持用js 做题</p><ol><li><a href="http://judge.u-aizu.ac.jp/onlinejudge/index.jsp">http://judge.u-aizu.ac.jp/onlinejudge/index.jsp</a></li><li><a href="http://codeforces.com/">http://codeforces.com/</a></li></ol><p>第一个是日本的OJ平台,是后来有人介绍给我的,我没有怎么认真去看,所以,本篇博文,讲的是如何在第二个毛子的OJ平台用js做题.</p><h2 id="用JS做题"><a href="#用JS做题" class="headerlink" title="用JS做题"></a>用JS做题</h2><p>注册账号什么..看得懂英文的应该都没什么问题,所以,现在让我们直接去做题吧!</p><p>找一个水题测试一下,怎么用js来写输入输出</p><p><a href="http://codeforces.com/problemset/problem/1/A">http://codeforces.com/problemset/problem/1/A</a></p><pre><code class="js">function main() &#123;    var numbers = readline().split(&#39; &#39;);    var one = numbers[0];    var two = numbers[1];    var three = numbers[2];    print(Math.ceil(one / three) * Math.ceil(two / three));&#125;main();</code></pre><p>在codeforces, 跑js直接用的是v8, 所有输入流用的是<code>readline()</code>,输出用<code>print()</code> 习惯的话,比用node的简单不少.</p><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>我们写好的js文件,用node来跑肯定不行,在windows平台下,codeforces已经编译好二进制包给我们了,我们只要下载,安装就行</p><p><a href="http://assets.codeforces.com/files/v8-3.32.0.7z">http://assets.codeforces.com/files/v8-3.32.0.7z</a></p><p>对于linux和mac的平台,你们得自己去编译个v8了.接下来以windows平台本地运行为例.</p><p>下载好了,我们windows下的运行环境二进制包以后,要运行刚才写的代码我们只需要</p><pre><code>d8 1a.js</code></pre><p>简单测试一下,输入,输出,感觉没问题了,我们就开始提交答案吧.</p><h2 id="提交答案"><a href="#提交答案" class="headerlink" title="提交答案"></a>提交答案</h2><p>在问题的右边有个上传文件的框.你直接把js文件上传上去就行了.</p><p><img src="/codeforce_1.png"></p><p>那么有没有在线写的呢?答案是有的,就在<strong>sumbit</strong> 这个tab上</p><p><img src="/codeforce_2.png"></p><p>接下来等结果就好了.</p><h2 id="看别人的解决思路"><a href="#看别人的解决思路" class="headerlink" title="看别人的解决思路"></a>看别人的解决思路</h2><p>对于一个ACM的票友而言..最痛苦的莫过于,想了半天都搞不懂,想看答案学习一下,但是Oj平台又不让看别人的提交的答案,不过codeforces 没这个限制,所有答案都是公开的.</p><p><img src="/codeforce_3.png"></p><p>在接下来的页面,我们可以看到各种语言对于这道题的状态,点击最左边的数字可以看到别人的解题思路代码,右边有个过滤条件tab,可以根据自己需要进行过滤</p><p><img src="/codeforce_4.png"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>对于js 在做题的时候,性能如何? 官方有个benchmark</p><p><a href="http://codeforces.com/blog/entry/10024">http://codeforces.com/blog/entry/10024</a></p><p>就性能而言,肯定没法跟c比,不过,作为ACM业余票友而言(专业的肯定不会用js来写了..),这个性能足以去做不少题了.吐槽一下..ruby 真慢..</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时髦的API文档生成方式</title>
      <link href="/2014/05/11/nodejs/swaggerapi/"/>
      <url>/2014/05/11/nodejs/swaggerapi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js ORM 框架 sequelize 入门教程 1</title>
      <link href="/2014/04/06/database/sequelize1/"/>
      <url>/2014/04/06/database/sequelize1/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>现在Node.js 上面的关系数据库ORM 框架有</p><ul><li><a href="https://github.com/sequelize/sequelize">sequelize</a></li><li><a href="http://dresende.github.io/node-orm2/">node-orm2</a></li><li><a href="http://knexjs.org/">knex</a></li></ul><p>其中以sequelize的关注度最高…因为,当初,我就是看着sequelize 的star 数最高..于是就入坑了..对了,国内的话,前端乱炖的数据库ORM用的就是sequelize</p><span id="more"></span><h2 id="Sequelize-历史"><a href="#Sequelize-历史" class="headerlink" title="Sequelize 历史"></a>Sequelize 历史</h2><p>对于我来说从2013年初到现在 接触sequelize应该有接近一年了..在这过去一年里sequelize的进步还是挺大的….在以前的版本.sequelize 对于关联表关系有着一些异常奇异的问题,这也导致,后边sequelize 的几个作者,下定决心做好单测…有兴趣的朋友可以去围观一下sequelize的单元测试,就现在而言,sequelize应该可以算能用了,所以,也决定写些东西推广一下sequelize,让一些人更加方便的入坑…</p><p>在sequelize开发历史中,在1.7 的时候,开了一个2.0 的分支,这两个分支的关系,可能有些人就混乱了,这里说一下,1.7 和 2.0 的版本是同步开发的,在1.7 正式出来的时候,1.7 和 2.0 的代码是一样的.不过,现在1.7已经正式发布,1.7和2.0 可能开始不同步了,所以,大家为了省事还是用1.7吧,至于2.0什么时候开发完..我估计得今年年底吧.</p><h2 id="Let’s-start"><a href="#Let’s-start" class="headerlink" title="Let’s start!"></a>Let’s start!</h2><p>先安装一下sequelize 的命令行工具,方便一些初始化工作</p><blockquote><p>Windows <code>npm install -g sequelize</code><br>*nix <code>sudo npm install -g sequelize</code></p></blockquote><p>安装完以后,我们之间在项目目录运行</p><blockquote><p><code>sequelize -i</code></p></blockquote><p>配置文件就会自动帮我们生成好了</p><pre><code class="bash">├───config└───migrations</code></pre><p>config 目录下的config.json 就是我们需要根据数据的配置进行修改的文件了</p><p>接下来我们安装用到的包</p><pre><code class="bash">npm install sequelize --savenpm install sqlite3 --savenpm install mysql --save</code></pre><p>sequelize 是支持多方言数据库(MySQL, MariaDB, SQLite and PostgreSQL)的ORM 框架.其中对于MariaDB 的支持..貌似就这一家了(不过用MariaDB应该不多吧).</p><p>为了展示sequelize 对于多数据库的支持,我使用两个不同的数据库生产环境用mysql,测试开发用sqlite3.</p><p>然后去修改 <code>config/config.json</code></p><pre><code class="js">  &quot;development&quot;: &#123;      &quot;username&quot;: null,      &quot;password&quot;: null,      &quot;database&quot;: &quot;database_development&quot;,      &quot;option&quot; : &#123;          &quot;dialect&quot;: &quot;sqlite&quot;,          &quot;storage&quot;:  &quot;test.sqlite&quot;,          &quot;define&quot;: &#123;              &quot;timestamps&quot;: false,              &quot;freezeTableName&quot;: true          &#125;      &#125;  &#125;</code></pre><p>对于sqlite3而言,直接把dialect 改为sqlite即可,如果是MySQL的,注意username,password,database一个都不能少!</p><p>对于define 里面的东西.这里先演示两个. timestamps 对于表是否自动添加createAt 和 updateAt这两个字段,如果你用不上的话,就关掉吧. freezeTableName, 是冻结表名,默认sequelize会帮你的定义的表名字自动加上s..所以,如果你用不上的话,就关掉吧.关于更多的配置请看<a href="http://sequelizejs.com/docs/latest/usage#options">http://sequelizejs.com/docs/latest/usage#options</a></p><h2 id="Let’s-run"><a href="#Let’s-run" class="headerlink" title="Let’s run!"></a>Let’s run!</h2><p>做了这么一番准备,现在开始让我们开始用sequelize进行数据库访问吧!</p><pre><code class="js">var Sequelize = require(&#39;sequelize&#39;);var node_env = process.env.NODE_ENV ? process.env.NODE_ENV : &#39;development&#39;;//根据系统环境载入我们的配置var config = require(&#39;../config/config&#39;)[node_env];var dbStroage = new Sequelize(config.database, config.username, config.password, config.option);//定义我们的User 表var User = dbStroage.define(&#39;user&#39;, &#123;    username: Sequelize.STRING,    password: Sequelize.STRING&#125;)//如果是第一次运行的话,需要用sync 方法创建表dbStroage.sync()    .success(function () &#123;        //用sequelize创建我们第一个用户        User.create(&#123;            username : &#39;youxiachai&#39;,            password : &#39;123456&#39;        &#125;).done(function (err, result)&#123;                console.log(err)                console.log(result)            &#125;)    &#125;)    .error(function (err)&#123;            console.log(err);&#125;)</code></pre><p>对于sequelize的配置运行,就到此结束了,下次我们讨论一下如何用sequelize 做一个Restful风格的应用.</p><p>本节完整代码 <a href="https://github.com/youxiachai/sequelize-lesson">https://github.com/youxiachai/sequelize-lesson</a></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> sequelize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零构建webapps</title>
      <link href="/2014/03/05/html5/phonegapandwebapp/"/>
      <url>/2014/03/05/html5/phonegapandwebapp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="Mini-Page"><a href="#Mini-Page" class="headerlink" title="Mini Page"></a>Mini Page</h1><h2 id="设计一个TAB-类型的布局"><a href="#设计一个TAB-类型的布局" class="headerlink" title="设计一个TAB 类型的布局"></a>设计一个TAB 类型的布局</h2><ul><li>position</li><li>overflow</li><li>display</li><li>z-index</li><li>-webkit-box-sizing</li></ul><p>header</p><p>content</p><p>navbar</p><h1 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h1>]]></content>
      
      
      <categories>
          
          <category> html5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
            <tag> phonegap </tag>
            
            <tag> appframework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s start Cocos2d-html5 2 : Dynamic World !</title>
      <link href="/2014/02/09/game/startcocos2d2/"/>
      <url>/2014/02/09/game/startcocos2d2/</url>
      
        <content type="html"><![CDATA[<h2 id="上节回顾"><a href="#上节回顾" class="headerlink" title="上节回顾"></a>上节回顾</h2><p>在上一节中,我们大概了解场景, 层, 精灵 ,接下来我们重点讨论一下精灵的使用.</p><p>这次我们的项目比上一节复杂那么一点点.</p><p>本节项目目录结构</p><p>Github: <a href="https://github.com/youxiachai/Cocos2d-html5-little-book/tree/master/myDynamicWorld">https://github.com/youxiachai/Cocos2d-html5-little-book/tree/master/myDynamicWorld</a></p><pre><code class="bash">│   boot-html5.js│   index.html│   main.js│├───res│       runner.png│       running.plist│       running.png│└───src        DynamicWorldScence.js        resource.js        StandHumanLayer.js        WorldElement.js</code></pre><span id="more"></span><h2 id="女娲造人"><a href="#女娲造人" class="headerlink" title="女娲造人"></a>女娲造人</h2><h3 id="泥人材料"><a href="#泥人材料" class="headerlink" title="泥人材料"></a>泥人材料</h3><p>女娲要造人,材料当然不可或缺了, 在<code>cocos2d-html5</code> 里头,我们一般会约定把图片素材放到项目的<code>res</code> 目录下,接下来用吗手工定义一个用于处理资源文件的js,方便我们用于访问.</p><pre><code class="js">var ImgRes = ImgRes || &#123;&#125;,    g_resources = [];ImgRes.s_runner_png = &quot;runner.png&quot;;ImgRes.s_running_png = &quot;running.png&quot;;ImgRes.s_running_plist = &quot;running.plist&quot;;//把需要预加载的资源路径添加进来Object.keys(ImgRes).forEach(function (item)&#123;    g_resources.push(&#123;        src : ImgRes[item]    &#125;)&#125;)</code></pre><blockquote><p>有人可能会想,一个个写好的蛋疼啊..有没有自动搞定的方式? 答案是肯定有了! 不过这个不在本节讨论范围内,初学,还是老老实实一个个手动添加资源吧.</p></blockquote><p>这里的资源路径不应该是 <code>res/runner.png</code> 吗? 为什么写成了 <code>runner.png</code> 是不是搞错了什么呀.这是故意这么写的.</p><p>接下来,我们要对上一节的<code>main.js</code> 进行一点小改动</p><p>将</p><pre><code class="js">director.runWithScene(new this.startScene());</code></pre><p>替换成</p><pre><code class="js">// 定义搜索资源的目录, 这里我们约定了res. 这样对于res 目录下的资源我们之间写名字即可.cc.FileUtils.getInstance().setSearchPaths([].concat(&quot;res&quot;));cc.LoaderScene.preload(g_resources, function () &#123;            director.replaceScene(new this.startScene());&#125;, this);</code></pre><p>因为我们这里有图片素材,当然需要与加载到缓存里面,<code>cocos2d-html5</code> 的预加载api 非常贴心,只需要使用 <code>cc.LoaderScene.preload</code> api 即可,而<code>g_resource</code> 就是我们之前定义好的资源数组.</p><p>这样我们的要准备造泥人的材料就准备好了, 接下来开始造人!</p><p><strong>注意对于新增的js文件,千万不要忘记了在<code>boot-html5.js</code> 配置定义<code>appFiles</code> 数组 里头添加新增js文件路径.</strong></p><h3 id="造人"><a href="#造人" class="headerlink" title="造人"></a>造人</h3><p>作为<code>cocos2d-html5</code> 的女娲,要造一个人非常简单.</p><pre><code class="js">var StandHumanLayer = cc.Layer.extend(&#123;  ctor: function (path) &#123;        this._super();        var humanSprite = cc.Sprite.create(path);        //定义我们的人出现的坐标点.        //值得注意的是在cocos2d-html5 的世界,坐标用的是右手坐标系,起始点在左下,而不是一般的左上.        humanSprite.setPosition(cc.p(80, 57));        this.addChild(humanSprite);  &#125;&#125;);//---------DynamicWorldScence.js// 在我们的世界场景里`onEnter` 函数里添加 this.addChild(new StandHumanLayer(ImgRes.s_runner_png));</code></pre><p>然后,我们世界第一个人就出来了!</p><p><img src="/./standHuman.png"></p><p>接下来我们的人怎么移动动起来呢?</p><p>这里涉及到了</p><blockquote><p><a href="http://www.cocos2d-x.org/wiki/Actions">Cocos2d-x 的Action 机制</a></p></blockquote><p>默认的基本动作提供了5种</p><ul><li>Position</li><li>Scale</li><li>Rotation</li><li>Visibility</li><li>Opacity</li><li>Color</li></ul><p>以平移为例</p><pre><code class="js">//让我们在StandHumanLayer.js 的ctor 函数里头再造一个会动的人吧var humanSprite2 = cc.Sprite.create(path);humanSprite2.setPosition(cc.p(80, 200));//在2s 内 X 轴从80 到 300var actionTo = cc.MoveTo.create(2, cc.p(300, 200));humanSprite2.runAction(cc.Sequence.create(actionTo));this.addChild(humanSprite2);</code></pre><p><img src="/./humanmove.gif"></p><h3 id="活起来"><a href="#活起来" class="headerlink" title="活起来!"></a>活起来!</h3><p>上一小节我们终于把人造好了,也能控制这人怎么移动,不过都是僵硬的,接下来,我们把人造得有人气!</p><p>这里涉及到了</p><blockquote><p><a href="http://www.cocos2d-x.org/wiki/Animations">cocos2d-x Animations 机制</a></p></blockquote><p><code>cocos2d-html5</code> 支持3类动画</p><ul><li>Frame Animation</li><li>Sprite Sheet Animation</li><li>Skeleton Animation</li></ul><p>这节里头我们用的是<code>Sprite Sheet Animation</code>.</p><blockquote><p>本节的plist 的创建请阅读 <a href="https://github.com/cocos2d/cocos-docs/blob/master/tutorial/parkour-game-with-javascript/chapter5/en.md">https://github.com/cocos2d/cocos-docs/blob/master/tutorial/parkour-game-with-javascript/chapter5/en.md</a> 这里有教你怎么用TexturePackerGUI.</p></blockquote><p>经过一番努力,终于从TexturePackerGUI 把我们的活人表造出来了,接下来就是用起来了.</p><p>最终完成的代码:</p><pre><code class="js">// 扩展StandHumanLayer.js 的构造函数,传入精灵表信息var StandHumanLayer = cc.Layer.extend(&#123;    ctor: function (path,origin, originlist) &#123;        this._super();        // 1  静态        var humanSprite = cc.Sprite.create(path);        humanSprite.setPosition(cc.p(80, 57));        this.addChild(humanSprite);        //2  移动        var humanSprite2 = cc.Sprite.create(path);        humanSprite2.setPosition(cc.p(80, 200));        var actionTo = cc.MoveTo.create(2, cc.p(300, 200));        humanSprite2.runAction(cc.Sequence.create(actionTo));        this.addChild(humanSprite2);        //3 会动的人        this.anime(origin, originlist)    &#125;,    anime : function (origin, originlist) &#123;        // 1 读取我们预加载的精灵表        cc.SpriteFrameCache.getInstance().addSpriteFrames(originlist);        // 1.1 使用 SpriteBatchNode 获得更好的性能        var spriteSheet = cc.SpriteBatchNode.create(origin);        this.addChild(spriteSheet);        // 2 把精灵表里的每帧动作加载到数组里面        var animFrames = [];        for (var i = 0; i &lt; 8; i++) &#123;            var str = &quot;runner&quot; + i + &quot;.png&quot;;            var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(str);            animFrames.push(frame);        &#125;        // 3 使用我们上头定义好的数组,创建动画, 第二参数,为每帧间隔时间        var animation = cc.Animation.create(animFrames, 0.1);        var runningAction = cc.RepeatForever.create(cc.Animate.create(animation));        // 4 从我们精灵表里头取第一帧作为精灵        var sprite = cc.Sprite.createWithSpriteFrameName(&quot;runner0.png&quot;);            sprite.setPosition(cc.p(80, 280));            sprite.runAction(runningAction);        // 4.1 最后把我们的第一帧精灵加入到精灵表里.       spriteSheet.addChild(sprite);    &#125;&#125;)</code></pre><p>最终效果</p><p><img src="/./humanainme.gif"></p><h2 id="来源声明"><a href="#来源声明" class="headerlink" title="来源声明"></a>来源声明</h2><p>图片资源来至于跑酷教程 <a href="https://github.com/cocos2d/cocos-docs/tree/master/tutorial/parkour-game-with-javascript">https://github.com/cocos2d/cocos-docs/tree/master/tutorial/parkour-game-with-javascript</a></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s start Cocos2d-html5 1 : Hello World!</title>
      <link href="/2014/02/08/game/startcocos2d/"/>
      <url>/2014/02/08/game/startcocos2d/</url>
      
        <content type="html"><![CDATA[<h2 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h2><p>组成 cocos2d-html5的世界基石大体分为3类</p><ul><li>Scene</li><li>Layer</li><li>Sprite</li></ul><p>关于这部分的详细讨论我们留到后边吧,如果你等不及了,可以去翻阅官方文档 <a href="http://cocos2d-x.org/wiki/Director_Scene_Layer_and_Sprite">here</a></p><span id="more"></span><h2 id="开天辟地"><a href="#开天辟地" class="headerlink" title="开天辟地"></a>开天辟地</h2><p>这个项目下载地址: <a href="https://github.com/youxiachai/Cocos2d-html5-little-book/tree/master/myhelloWorld">https://github.com/youxiachai/Cocos2d-html5-little-book/tree/master/myhelloWorld</a></p><ul><li>项目目录结构</li></ul><p>总共才4个文件</p><pre><code class="bash">│   boot-html5.js│   index.html│   main.js│└───src        HelloScence.js</code></pre><ul><li><code>index.html</code> 我的世界<br>要创建一个cocos2d-html5 的世界,我们只需要创建一个<code>canvas</code>和 一个<code>script</code> 即可.</li></ul><pre><code class="html">&lt;canvas id=&quot;gameCanvas&quot; width=&quot;1280&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt;&lt;script src=&quot;boot-html5.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li><code>boot-html5.js</code></li></ul><p>上帝说要有光,我们就得把光造出来,而这个文件就是用于如何让引入 cocos2d-html5 最基本的世界元素</p><pre><code class="js">(function () &#123;    var d = document;    // cocos2d-html5 配置定义    var c = &#123;        COCOS2D_DEBUG:2, //0 to turn debug off, 1 for basic debug, and 2 for full debug        showFPS:true,        frameRate:60,        renderMode:0,       //渲染模式: 0(default), 1(Canvas only), 2(WebGL only)        tag:&#39;gameCanvas&#39;, //世界在那里!        engineDir:&#39;../cocos2d/&#39;,       // SingleEngineFile:&#39;../../Cocos2d-html5-min.js&#39;,       //引入我们定义的场景js 文件        appFiles:[            &#39;src/HelloScence.js&#39;        ]    &#125;;    window.addEventListener(&#39;DOMContentLoaded&#39;, function () &#123;        //添加引擎js 文件        var s = d.createElement(&#39;script&#39;);        s.src = c.engineDir + &#39;jsloader.js&#39;;        d.body.appendChild(s);        //把配置信息加载到document, 用于全局访问        document.ccConfig = c;        s.id = &#39;cocos2d-html5&#39;;    &#125;);&#125;)();</code></pre><ul><li><code>HelloScence.js</code></li></ul><p>现在,我们开始创建我的世界吧!</p><pre><code class="js">var HelloLayer = cc.Layer.extend(&#123;    init :function()    &#123;        this._super();        // 获取当前屏幕信息        var s = cc.Director.getInstance().getWinSize();        // 游戏背景层        var layer1 = cc.LayerColor.create(new cc.Color4B(0, 0, 0, 255), 1280, 720);        layer1.setAnchorPoint(new cc.Point(0.5,0.5));        // 文字精灵        var helloLabel = cc.LabelTTF.create(&quot;Hello world&quot;, &quot;Arial&quot;, 60);        helloLabel.setPosition(new cc.Point(s.width/2,s.height/2));        helloLabel.setColor(new cc.Color3B(0,255,0));        //把精灵添加到背景层        layer1.addChild(helloLabel);        // 把合成好的层添加进来        this.addChild(layer1);        // 返回我们的HelloLayer        return this;    &#125;&#125;);var HelloScene = cc.Scene.extend(&#123;    onEnter:function()&#123;        this._super();        // 把我们的定义好的图层添加到场景里面        this.addChild(new HelloLayer().init());    &#125;&#125;)</code></pre><ul><li><code>main.js</code><blockquote><p>关于为什么是<code>main.js</code> 而不是其他,请看附录的加载流程图</p></blockquote></li></ul><pre><code class="js">var cocos2dApp = cc.Application.extend(&#123;    // 加载配置信息, 这下明白`  document.ccConfig = c;` 的意思了吧    config:document[&#39;ccConfig&#39;],    ctor:function (scene) &#123;        this._super();        this.startScene = scene;        cc.COCOS2D_DEBUG = this.config[&#39;COCOS2D_DEBUG&#39;];        cc.initDebugSetting();        cc.setup(this.config[&#39;tag&#39;]);        cc.AppController.shareAppController().didFinishLaunchingWithOptions();    &#125;,    applicationDidFinishLaunching:function () &#123;        //注意 director 的使用        var director = cc.Director.getInstance();        director.setDisplayStats(this.config[&#39;showFPS&#39;]);        director.setAnimationInterval(1.0 / this.config[&#39;frameRate&#39;]);        director.runWithScene(new this.startScene());        return true;    &#125;&#125;);// 我们的世界就出来了!var myApp = new cocos2dApp(HelloScene);</code></pre><p><img src="/./myworld.png"></p><blockquote><p>ps: firefox 的WEBGL 性能令人发指的烂…chrome 一般能跑满60帧</p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="API-文档"><a href="#API-文档" class="headerlink" title="API 文档"></a>API 文档</h3><p>官方在线文档: <a href="http://www.cocos2d-x.org/reference/html5-js/V2.2.2/index.html">http://www.cocos2d-x.org/reference/html5-js/V2.2.2/index.html</a></p><p>官方文档离线镜像: <a href="https://github.com/youxiachai/cocos2d-html5-api-offlinedoc">https://github.com/youxiachai/cocos2d-html5-api-offlinedoc</a></p><h3 id="文件加载过程"><a href="#文件加载过程" class="headerlink" title="文件加载过程"></a>文件加载过程</h3><p>这个图是跑酷教程chapter2 截图</p><p><img src="/./execute-path.png"></p>]]></content>
      
      
      <categories>
          
          <category> game </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用node开发repl应用</title>
      <link href="/2014/01/20/nodejs/usercommander/"/>
      <url>/2014/01/20/nodejs/usercommander/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次看到一些库<code>npm -g install xx</code>然后,执行<code>xx</code>就可以跑起来,这不就是一个shell工具了吗,那么我不就可以不用学习shell语法,直接用js写命令行脚本了吗!</p><span id="more"></span><h2 id="什么是REPL应用"><a href="#什么是REPL应用" class="headerlink" title="什么是REPL应用"></a>什么是REPL应用</h2><p>所谓的repl应用就是一个终端命令行工具,如果使用linux对于命令行工具例如curl,awk,grep,find,这些肯定不陌生,而现在,我们就是用node去写类似这样的程序</p><h2 id="读取-求值-输出"><a href="#读取-求值-输出" class="headerlink" title="读取-求值-输出"></a>读取-求值-输出</h2><p>对于第一次动手写repl应用,我们首先,了解一些知识点.</p><h3 id="Process-api"><a href="#Process-api" class="headerlink" title="Process api"></a>Process api</h3><blockquote><p>文档 <a href="http://nodejs.org/api/process.html">http://nodejs.org/api/process.html</a></p></blockquote><p>process 对象在node里面是全局对象,不需要用require引入,直接使用</p><blockquote><p>console.log(process)</p></blockquote><p>我们就可以在终端里面看到process都有些什么内容了.对于,开发一个repl应用,我们对于process对象只需要了解以下下几点就行</p><ul><li>process.argv &#x2F;&#x2F;这次输入值集合</li><li>process.stdout.* &#x2F;&#x2F;终端输出方法</li><li>process.stdin.* &#x2F;&#x2F;终端输入方法</li><li>process.exit(); &#x2F;&#x2F; 退出</li></ul><p>对于process的了解这几点大部分repl应用都可以开发了,接下来,我们说说,如何让命令行工具读取参数.</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>对于repl而言,值读取的常见的一般有两种:</p><h4 id="配置值"><a href="#配置值" class="headerlink" title="配置值"></a>配置值</h4><pre><code class="js">#!/usr/bin/env nodeif(process.argv[2] === &#39;-w&#39;)&#123;    var args = process.argv.slice(3);    var output = &#39;&#39;;    args.forEach(function (item)&#123;        output += item + &#39; &#39;;    &#125;)    console.log(output);    process.exit();&#125;</code></pre><blockquote><p>node repl.js -w Hello world!</p></blockquote><blockquote><p>Hello world!</p></blockquote><h4 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h4><pre><code class="js">#!/usr/bin/env nodefunction read(prompt) &#123;    process.stdout.write(prompt + &#39;:&#39;);    process.stdin.resume();    process.stdin.setEncoding(&#39;utf-8&#39;);    process.stdin.on(&#39;data&#39;, function(chunk) &#123;      process.stdout.write(&#39;output: &#39; + chunk);      process.exit();    &#125;);&#125;read(&#39;input&#39;)</code></pre><blockquote><p>node repl.js</p></blockquote><blockquote><p>input: Hello world!</p></blockquote><blockquote><p>output: Hello world!</p></blockquote><p>repl 应用本质其实就是一个shell脚本,现在我们要用node来写,所以,对于*nix环境我们必须在第一行说明我们的文件需要在什么环境下运行.</p><blockquote><p><code>#!/usr/bin/env node</code></p></blockquote><h4 id="process-argv"><a href="#process-argv" class="headerlink" title="process.argv"></a>process.argv</h4><p>我们主要从命令行输入值都是从<code>process.argv</code>里面读取,这个对象,保存了我们所有命令行的输入,我们可以打印出来看看</p><blockquote><p>console.log(&#96;process.argv)</p></blockquote><pre><code>[ &#39;node&#39;,  &#39;E:\\ProjectGitHub\\node.js\\repl.js&#39;,  &#39;-w&#39;,  &#39;Helloworld!&#39; ]</code></pre><p>从这个输出我们就可以很明了的知道我们为什么要用<code> process.argv.slice(3);</code>来获取值了.</p><h4 id="process-stdout-amp-amp-process-stdin"><a href="#process-stdout-amp-amp-process-stdin" class="headerlink" title="process.stdout &amp;&amp; process.stdin"></a>process.stdout &amp;&amp; process.stdin</h4><p>这两个方法用于对终端输出和输入的操作,上面的例子应该很好演示这个使用了,这里就不再赘述了.</p><h3 id="求值-amp-输出"><a href="#求值-amp-输出" class="headerlink" title="求值 &amp; 输出"></a>求值 &amp; 输出</h3><h4 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h4><p>现在要讲的这个repl应用就是简单的在终端中显示前端乱炖的专栏列表.效果如下(PS:绿色那些是debug输出,你自动忽略吧…):</p><blockquote><p>输入 <code>htmljs article</code></p></blockquote><blockquote><p>输入 <code>htmljs article -p 1</code></p></blockquote><p><img src="/./graph1.png" alt="效果图"></p><h4 id="内容准备"><a href="#内容准备" class="headerlink" title="内容准备"></a>内容准备</h4><p>这里用到了<code>request</code>,<code>cheerio</code> 对前端乱炖页面进行解析,这块的讨论已经超出了本文的讨论范围,以后放在介绍<code>cheerio</code>的时候再说这块的实现.</p><p>用命令行看前端乱炖专栏列表:</p><blockquote><p><a href="https://github.com/youxiachai/html-js-cli">https://github.com/youxiachai/html-js-cli</a></p></blockquote><h4 id="利用Commander处理输入"><a href="#利用Commander处理输入" class="headerlink" title="利用Commander处理输入"></a>利用Commander处理输入</h4><p>对于如何在终端输入参数,在上面的读取篇已经全部介绍完毕,用原生<code>process</code>处理输入异常的繁琐,对于这点,TJ大神写了一个模块<code>commander</code>用来处理.</p><pre><code class="js">#!/usr/bin/env nodevar program = require(&#39;commander&#39;),    htmljscli = require(&#39;../index&#39;),    libInfo = require(&#39;../package&#39;);program    .version(libInfo.version)program    .command(&#39;article&#39;)    .description(&#39;show article list&#39;)    .option(&#39;-p, --page [page]&#39;, &#39;article list&#39;)    .action(function(options)&#123;        htmljscli.listArticle(options.page)    &#125;);program.parse(process.argv); // 这行必须是结尾</code></pre><p>不到20行代码就可以解决了原本需要各种处理<code>process.argv</code> 情况,而且还很贴心了帮我们自动生成help介绍</p><blockquote><p>htmljs article -h</p></blockquote><blockquote><p><img src="/./graph2.png" alt="效果图"></p></blockquote><p>使用<code>commander</code> 我们只需要了解一下几点就可以了</p><ul><li>commander.option()</li></ul><blockquote><p>用于将对象值对象化, 例如上文定义的<code> commander .option(&#39;-p, --page [page]&#39;, &#39;article list&#39;)</code>我们输入的时候<code> -p</code> 的时候,就可以用<code>options.page</code> 获取我们的参数</p></blockquote><ul><li>commander.command().option().action()</li></ul><blockquote><p>用于配置子命令</p></blockquote><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>有时候,一些库会要求我们</p><blockquote><p>npm -g install cnpm</p></blockquote><p>然后很神奇的发现可以</p><blockquote><p>cnpm install xx</p></blockquote><p>这类的操作,那我们发布的包怎么实现这个神奇的魔法呢.原理非常简单,我们只需要在我们的<code>package.json</code>加入以下几句就行</p><pre><code class="js">&#123;  &quot;bin&quot;: &#123;    &quot;htmljs&quot;: &quot;./bin/htmljscli&quot;  &#125;&#125;</code></pre><p>用<code>npm</code> 安装的时候就会自动与当前系统环境进行绑定.</p><p>接下来我们只需要</p><blockquote><p>npm -g install html-js-cli</p></blockquote><p>运行</p><blockquote><p>htmljs article</p></blockquote><p>就可以在终端看到专栏列表了</p><p>值得注意的时候,在<code>windows</code>发布你写node repl应用,<code>*nix</code>用户安装的时候,命令并不会起作用,所以,要用<code>npm</code>发布repl应用的时候请使用<code>*nix</code>系统</p><h2 id="Node-repl-应用"><a href="#Node-repl-应用" class="headerlink" title="Node repl 应用"></a>Node repl 应用</h2><h3 id="豆瓣电台命令行版"><a href="#豆瓣电台命令行版" class="headerlink" title="豆瓣电台命令行版"></a>豆瓣电台命令行版</h3><blockquote><p><a href="https://github.com/turingou/douban.fm">https://github.com/turingou/douban.fm</a></p></blockquote><p>###微博命令行工具</p><blockquote><p><a href="http://justan.github.io/twei">http://justan.github.io/twei/</a></p></blockquote><p>###cnpmjs</p><blockquote><p><a href="https://github.com/cnpm/cnpm">https://github.com/cnpm/cnpm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2013年终总结</title>
      <link href="/2013/12/31/summary/final2013/"/>
      <url>/2013/12/31/summary/final2013/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>年终总结..</p><p>ps: 2016年回顾，这个坑不填了！</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Kraken.js!</title>
      <link href="/2013/11/30/nodejs/hellokraken/"/>
      <url>/2013/11/30/nodejs/hellokraken/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>kraken.js 由paypal 公司开源的一个用于快速开发基于Express.js框架应用的快速开发工具, 因为kraken 并没有在Express.js基础上更改多少东西,只是在原来的express基础上补充了一些约定开发的规则, 让开发根据便捷.</p><span id="more"></span><h2 id="你好-世界"><a href="#你好-世界" class="headerlink" title="你好,世界!"></a>你好,世界!</h2><p>要创建一个kraken 项目只需要非常简单的三步走:</p><ol><li><p>安装必备工具</p><blockquote><p>  Linux or Mac <br/><br><code>sudo npm install -g yo generator-kraken</code> <br/><br>Windows <br/><br><code> npm install -g yo generator-kraken</code></p></blockquote></li><li><p>创建kraken项目 <br/><br>只需要一行代码,然后,看着提示语,输入一些东西,一个项目就这样创建完毕.</p><blockquote><p><code>yo kraken</code></p></blockquote></li><li><p>运行kraken项目 <br /><br>还是只需要一行代码</p><blockquote><p><code>npm start</code></p></blockquote></li></ol><p>以上三行代码即可,完成一个kraken项目的创建了.</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h3><ol><li><p><code>yo kraken</code> 你输入项目名字的时候,会在当前项目创建与该项目名字一样的文件夹,记得<code>cd</code> 进去文件夹再去运行 <code>npm start</code></p></li><li><p>注意<code>NODE_ENV</code>的设置,kraken的配置是会根据当前<code>NODE_ENV</code>进行变化,所以如果跑不通的时候最好检查一下当前的<code>NODE_ENV</code>.默认情况下,<code>NODE_ENV</code>没有设置或者设置了<code>development</code>,启动的时候,<code>kraken</code> 会默认加载<code>./public/templates</code> 下的模板,设置了其他值的时候,就会去加载<code>./.build/templates</code> 而这个当你在<code>kraken</code> 项目目录下运行<code>grunt build</code> 就会出现<code>.build</code> 该目录了用于部署在<code>NODE_ENV</code>设置为<code>production</code>或者其他值的时候加载.</p></li></ol><p>查看你当前系统的<code>NODE_ENV</code>环境</p><blockquote><p>Linux or Mac</p><blockquote><p><code>echo $NODE_ENV</code></p></blockquote></blockquote><blockquote><p>Windows</p><blockquote><p><code>echo %NODE_ENV%</code></p></blockquote></blockquote><h2 id="约定开发"><a href="#约定开发" class="headerlink" title="约定开发"></a>约定开发</h2><p>个人看法 <code>kraken</code> 与其说是一个框架好不如说它只不过提供了灵活,方便的用于构建Express应用的方式.</p><h3 id="配置-x2F-config"><a href="#配置-x2F-config" class="headerlink" title="配置(&#x2F;config)"></a>配置(&#x2F;config)</h3><p><code>kraken</code> 在 <code>./config</code> 约定了两类配置文件:</p><ol><li><code>app.json</code> 用于配置,host, port, i18n ,express 等.</li><li><code>middleware</code> 用于对默认中间件的配置,目前支持的中间件有<code>appsec</code>, <code>compiler</code>, <code>session</code>, <code>errorPages</code>, <code>static</code>, 详细的参数配置请阅读官方文档,这里就不赘述了.</li></ol><p>除此以外,<code>kraken</code> 还约定支持根据<code>NODE_ENV</code>自动匹配相应的配置文件,规则是:</p><blockquote><p><code>app-NODE_ENV.json</code></p></blockquote><p>例如, 当前<code>NODE_ENV</code>是<code>development</code>, 你在目录下有一个<code>app-development.json</code>的文件话,就会优先读取该文件的配置.</p><h3 id="控制器-x2F-controllers"><a href="#控制器-x2F-controllers" class="headerlink" title="控制器(&#x2F;controllers)"></a>控制器(&#x2F;controllers)</h3><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p><code>kraken</code> 默认会自动加载<code>./controllers</code> 下的文件,进行路由控制,个人觉得,这个真心省心.接下来的写法,与express 完全一样!</p><pre><code class="js">module.exports = function (server) &#123;    server.get(&#39;/customer&#39;, function (req, res) &#123;       res.send(&#39;Hello World&#39;);    &#125;);&#125;;</code></pre><p>如果,你是express的开发者,就会越感发现,<code>kraken</code>更多的是补充了express不足的地方,除此以外跟平常用express开发毫无区别.</p><h3 id="自定义中间件-和-周期控制"><a href="#自定义中间件-和-周期控制" class="headerlink" title="自定义中间件 和 周期控制"></a>自定义中间件 和 周期控制</h3><p><code>kraken</code> 将一个请求的周期定义为三级:</p><ol><li><code>app.requestStar</code> 请求开始</li><li><code>app.requestBeforeRoute</code> 进行路由前</li><li><code>app.requestAfterRoute</code> 路由后输出</li></ol><p>整个实现异常简洁, 有兴趣的可以去阅读源码:</p><blockquote><p><code>appcore.js</code> <code>line: 172 - 198</code></p></blockquote><p>定义一个中间件的方法与express的时候一样,只不过,现在多了一步,我们要把中间件放到哪个位置而已</p><p>约定在<code>./middleware/lib</code> 下建一个文件,beforeRouteMiddleware.js</p><pre><code class="js">module.exports = function () &#123;_    var reqCounts = 0;    return function (req, res, next) &#123;        req.counts = reqCounts | 0;        reqCounts++;        next();    &#125;;&#125;;</code></pre><p>然后在: index.js</p><pre><code class="js">var beforeRouteMiddleware =  require(&#39;./lib/middleware/beforeRouteMiddleware&#39;)app.requestBeforeRoute = function requestBeforeRoute(server) &#123;    server.use(beforeRouteMiddleware());&#125;;</code></pre><p>与express的中间件功能一样,每请求一次,都会触发中间件. 与原生的express不同<code>krarken</code>提供了更有条例的中间件定义约定.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>kraken</code> 还有一些比较实用的功能,例如安全,还有本地化,不过这些内容,官方文档已经写得很详细了,这里就不作过多的说明. 在我看来,<code>kraken</code> 只干了一件事,就是把express条理化了,<code>kraken</code>并没有对express进行更多的封装,所以,只要会express的入手<code>kraken</code> 就像喝水一样简单. 而<code>kraken</code> 提供的约定,能够更有效率的开发Node.js的web项目.</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选一个靠谱的正版电子书市场 -- 排版篇</title>
      <link href="/2013/10/31/lifestyles/ebooklibraryselect/"/>
      <url>/2013/10/31/lifestyles/ebooklibraryselect/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来,很早以前就该写一篇博文说说目前中国的电子书市场的概括,可惜,一直拖着,没写,都快月末了.得速度填坑.</p><span id="more"></span><h2 id="电子书市场概况"><a href="#电子书市场概况" class="headerlink" title="电子书市场概况"></a>电子书市场概况</h2><p>说到电子书,大家第一时间想到的就是免费,然后下载,很少有人会说,这电子书看起来不错哦,多少钱一本呢.这也是国内电子书市场相比国外电子书市场滞后的一个原因,不过,几年来,情况有所改观,已经有不少公司在电子书市场发力,其中,我比较认可的有多看,豆瓣,中国亚马逊,当当,京东等,还有一些受众的人群也挺多的但是不对我口味,所以我接下来就不作拿来做比较,例如,盛大的云中书城,中国知网,超星,读秀等…</p><h2 id="书的口味"><a href="#书的口味" class="headerlink" title="书的口味"></a>书的口味</h2><p>一个电子书市场是否能够做的起来,我是觉得单单依靠量上去,是一种很傻很天真的想法,特别是,作为会掏钱买电子书的人群来说,他们能够认可这种方式的,那肯定是对阅读有点追求,就算书卖得再便宜,甚至于免费送,下载下来不去看意义又何在了?所以,在我的评价里面,一个电子书城里面的合作的是出版社这点很重要,这个关乎于书城里面的书质量.可惜的是,在我打算评选的几大书城里面,只有多看,和豆瓣有一个专门的页面介绍这些出版社,其余的,我找遍所有地方都没找着.</p><table><thead><tr><th align="left">书城</th><th>出版社数量</th></tr></thead><tbody><tr><td align="left">多看</td><td>63</td></tr><tr><td align="left">豆瓣</td><td>10</td></tr><tr><td align="left">中国亚马逊</td><td>没有公开页面介绍</td></tr><tr><td align="left">当当</td><td>没有公开页面介绍</td></tr><tr><td align="left">京东</td><td>没有公开页面介绍</td></tr></tbody></table><p>虽然,那些书城的合作出版社并没有公开,但是,从各大网站的主页上可以发现,感觉这几家都有卖实体书的,感觉电子书的出版社应该是差不多一样的.所以说,这几家的书可以说基本一致.</p><h2 id="移动阅读"><a href="#移动阅读" class="headerlink" title="移动阅读"></a>移动阅读</h2><p>电子书与实体书最大的优点就是便携,想想,我每次搬家那几大箱书,实在是痛苦至极.而对于电子书最大的挑战就是如何在不同尺寸的屏幕下,依然能够提供最好的体验,这也是接下来重点测试的部分.</p><p>对于电子书而言,支持专门的e-ink 阅读器设备的当然是最好的了,目前支持阅读器有以下几家:</p><table><thead><tr><th align="left">书城</th><th>设备</th></tr></thead><tbody><tr><td align="left">多看</td><td>全系列老款kindle</td></tr><tr><td align="left">中国亚马逊</td><td>kindle paperwhite 2012&amp;2013</td></tr><tr><td align="left">当当</td><td>都看阅读器</td></tr></tbody></table><p>其中不用说,硬件设备做得做好肯定是kindle 系列了.</p><p>不过,阅读器设备,毕竟还算是比较少人会去特地去买来看书,所以在移动设备上我们更多的会选择android或者IOS设备进行电子书阅读.而对于这目前主流的移动设备操作系统,几乎所有书城都会同时支持.所以,接下来,我来进行对电子书的排版比较</p><h2 id="排版引擎"><a href="#排版引擎" class="headerlink" title="排版引擎"></a>排版引擎</h2><p>一本电子书值不值得去买,在我看来,书的排版十分重要,虽然,书的内容很重要,但是,看着舒服也很重要,毕竟是掏钱买的东西,要求高点是十分必须的.至于价格,不在我考虑范围内,那家排版好我就选那家购买.</p><p>为了找一本几个书城都有的书真心不容易…</p><h3 id="对比怪诞心理学"><a href="#对比怪诞心理学" class="headerlink" title="对比怪诞心理学"></a>对比怪诞心理学</h3><h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><p><img src="/images/ebookcomparison/guaidan_jd.png"></p><h4 id="中国亚马逊"><a href="#中国亚马逊" class="headerlink" title="中国亚马逊"></a>中国亚马逊</h4><p><img src="/images/ebookcomparison/guaidan_z.png"></p><h4 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h4><p><img src="/images/ebookcomparison/guaidan_douban.png"></p><h4 id="多看"><a href="#多看" class="headerlink" title="多看"></a>多看</h4><p><img src="/images/ebookcomparison/guaidan_duokan.png"></p><p>很奇葩的发现,当当居然没有这本书..这四家书城APP里面,要分个高低,毫无疑问,京东最烂.连段落都解析不好的,从这里可以看出来,京东其实,没多用心做电子书….</p><p>从这本书的段落排版思路上可以分为两类,京东和豆瓣(标题居中),多看和中国亚马逊(标题局两边).</p><p>京东和豆瓣的解析思路虽然一样,但是,处理明显与豆瓣相比差了十万八千里.</p><p>而多看和亚马逊的排版应该是按照实体书的排版规范来进行显示的,我看了一下实体书的排版,标题是局右的,而且,都复原了单页标题.</p><p>从这点比较上来看,多看和亚马逊都多电子书进行了与实体书一致的排版体验,这点上无疑比京东和豆瓣好,而豆瓣虽然没有进行与实体书一致的排版,但是不影响观感,而京东的排版,实在是太敷衍了..这边书的排版并不复杂,连排版这么简单的书排版都显示得这么差,实在是让人没有在其上面买书的欲望..有排版更好的书,为什么我要掏钱买劣质排版的呢?</p><h4 id="当当专场"><a href="#当当专场" class="headerlink" title="当当专场"></a>当当专场</h4><p>这几个书城里面,就排版而言,当当算得上不好不坏,不过就资源而言,很多我想看的书都没有….</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这文写完以后再看..好水啊……主要是没什么时间去认真比较..算是填了一点的坑吧.</p>]]></content>
      
      
      <categories>
          
          <category> lifestyles </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle 构建 android 应用常见问题解决指南</title>
      <link href="/2013/09/30/android/android4gradlefaq/"/>
      <url>/2013/09/30/android/android4gradlefaq/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>android gradle 插件已经发展到0.5.7,同时gradle 本身也到了1.8,相比两个月前,android gradle 更快,更完善,也更好用了,为了让各位androider 早日用上gradle这样的神器,特地写一篇关于gradle一些奇葩错误的解决指南.</p><span id="more"></span><h2 id="使用最新的gradle-android插件"><a href="#使用最新的gradle-android插件" class="headerlink" title="使用最新的gradle android插件"></a>使用最新的gradle android插件</h2><p>以前我们写的时候会这么写</p><pre><code class="groovy">dependencies &#123;    classpath &#39;com.android.tools.build:gradle:0.5.0&#39;&#125;</code></pre><p>不过,由于android gradle 插件的开发还是很活跃的,而且目前而言,可能还存在一些我们不知道的坑,但是,别人踩过,后边,官方修复,为了不踩坑,我建议android gradle 始终保持最新版本,写法如下:</p><pre><code class="groovy">dependencies &#123;    classpath &#39;com.android.tools.build:gradle:0.5+&#39;&#125;</code></pre><h2 id="由于代码编码与编译环境编码不一致-导致构建失败"><a href="#由于代码编码与编译环境编码不一致-导致构建失败" class="headerlink" title="由于代码编码与编译环境编码不一致,导致构建失败"></a>由于代码编码与编译环境编码不一致,导致构建失败</h2><p>有时候,我们的代码使用utf-8 保存的,但是,进行gradle build 的环境是gbk这类的,这时候会包如下错误:</p><blockquote><p>15: 错误: 编码GBK的不可映射字符<br>         * 鍑虹幇涓枃璇锋敞鎰?</p></blockquote><p>这个时候我们就需要手动的设置编译时编码类型.</p><pre><code class="groovy">tasks.withType(Compile) &#123;    options.encoding = &quot;UTF-8&quot;&#125;apply plugin: &#39;android&#39;android &#123;&#125;</code></pre><h2 id="android-support-v4-重复引用问题"><a href="#android-support-v4-重复引用问题" class="headerlink" title="android support v4 重复引用问题"></a>android support v4 重复引用问题</h2><pre><code class="java">UNEXPECTED TOP-LEVEL EXCEPTION:java.lang.IllegalArgumentException: already added: Landroid/support/v4/app/ActivityCompatHoneycomb;        at com.android.dx.dex.file.ClassDefsSection.add(ClassDefsSection.java:123)        at com.android.dx.dex.file.DexFile.add(DexFile.java:163)        at com.android.dx.command.dexer.Main.processClass(Main.java:490)        at com.android.dx.command.dexer.Main.processFileBytes(Main.java:459)        at com.android.dx.command.dexer.Main.access$400(Main.java:67)        at com.android.dx.command.dexer.Main$1.processFileBytes(Main.java:398)        at com.android.dx.cf.direct.ClassPathOpener.processArchive(ClassPathOpener.java:245)</code></pre><p>出现这个问题的原因一般是由于我们这样的写法导致:</p><blockquote><pre><code class="groovy">dependencies &#123;    compile fileTree(dir: &#39;libs&#39;, include: &#39;*.jar&#39;)&#125;</code></pre></blockquote><pre><code>某个相同的jar包,被复制到了build目录导致重复编译使编译时失败,由于这个问题android support v4 出现的比较多,所以同类型的都归类为v4 问题吧.要避免这个问题,我们尽量少使用依赖某个目录下所有包,毕竟android项目不想java web项目动不动就有好几十jar 包依赖.要修复这个v4,原理很简单,可以使用依赖maven的写法.&gt;```groovydependencies &#123;    compile &#39;com.android.support:support-v4:13.0.0&#39;&#125;</code></pre><h2 id="打包后缺少-so文件"><a href="#打包后缺少-so文件" class="headerlink" title="打包后缺少*.so文件"></a>打包后缺少*.so文件</h2><p>用指定依赖包的方式打包,我们会发现,最终打包后的jar没有了*.so文件,这个时候,我们需要自定义一个tasks,写如下:</p><pre><code class="groovy">task copyNativeLibs(type: Copy) &#123;    from(new File(&#39;libs&#39;)) &#123; include &#39;**/*.so&#39; &#125;    into new File(buildDir, &#39;native-libs&#39;)&#125;tasks.withType(Compile) &#123; compileTask -&gt; compileTask.dependsOn copyNativeLibs &#125;clean.dependsOn &#39;cleanCopyNativeLibs&#39;tasks.withType(com.android.build.gradle.tasks.PackageApplication) &#123; pkgTask -&gt;    pkgTask.jniDir new File(buildDir, &#39;native-libs&#39;)&#125;</code></pre><p>这样,在编译时,就会自动把libs目录下的<code>**/*.so</code> 文件复制到apk里面了.</p><h2 id="构建多渠道包"><a href="#构建多渠道包" class="headerlink" title="构建多渠道包"></a>构建多渠道包</h2><p>在最新版本的gradle 0.5.7 中,构建多渠道包比之前简单多了,在以前,你需要这么写:</p><pre><code class="groovy">android &#123;    buildTypes &#123;         hiapk &#123;             packageNameSuffix &quot;.hiapk&quot;         &#125;         playstore &#123;             packageNameSuffix &quot;.playstore&quot;        &#125;     &#125;    sourceSets &#123;        hiapk &#123;            manifest.srcFile &#39;hiapk/AndroidManifest.xml&#39;        &#125;        playstore &#123;            manifest.srcFile &#39;hiapk/AndroidManifest.xml&#39;        &#125;    &#125;&#125;</code></pre><p>要替换某个类型的文件需要自己手动写,渠道多了,这代码量是可想而知的多,在0.5.7中,进行了一个约定规则,构建,渠道包你只需</p><pre><code class="groovy">android &#123;    buildTypes &#123;         hiapk &#123;             packageNameSuffix &quot;.hiapk&quot;         &#125;         playstore &#123;             packageNameSuffix &quot;.playstore&quot;        &#125;     &#125;    sourceSets &#123;         hiapk.setRoot(&#39;build-types/hiapk&#39;)         playstore.setRoot(&#39;build-types/playstore&#39;)    &#125;&#125;</code></pre><p>在项目的根目录下创建一个<code>build-types</code>的目录,在创建对应渠道的子目录,然后把一些,诸如要替换<code>AndroidManifest.xml</code>,里面友盟渠道号什么的,直接把xml复制进去就行,gradle在构建项目的时候,会自动的优先使用<code>build-types</code>下目录文件的目录,诸如,根据不同渠道,不同国家换个程序图标什么的,都只要放到目录下即可.</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grunt 新手指南</title>
      <link href="/2013/08/31/nodejs/gruntjsstart/"/>
      <url>/2013/08/31/nodejs/gruntjsstart/</url>
      
        <content type="html"><![CDATA[<p>##导言##<br>作为一个正在准备从java 后端转大前端,一直都有想着,在js 的世界里面有没有类似于maven或者gradle 的东西..然后,就找到了grunt 这玩意</p><span id="more"></span><p>##Grunt是用来干什么的##<br>诸如ant,maven,gradle,make 之流的,那么我们为什么要学这么一个工具了,我们用IDE编程不是好好的吗,要让人去学这么一个工具,那么必然要有这个工具能够为我们搞定什么的原因.</p><p>选择Grunt原因</p><ol><li>管理我们的文件依赖</li><li>随心所欲的批处理任务</li><li>整合常用的前端工具,js混淆,文件合并压缩.</li></ol><p>说了这么多,上面就是我们为什么要选择grunt.js 作为我们项目构建的工具,如果你没有任何项目构建的概念,我建议了就不要看有关grunt的任何资料了,包括本文.因为,你看不懂我接下来我要写东西,也看不懂任何有关grunt相关资料,所以,就不要浪费时间了.</p><p>##让Grunt 干活##<br>如果,你之前有接触过构建工具,或者你现在有项目构建的概念,那么任务(tasks)这个概念想必理解起来不会有太大的难度了.</p><p>###创建我们第一个任务###<br>只要在我们的Gruntfile.js 文件写上这么几句</p><pre><code class="js">module.exports = function (grunt) &#123;    grunt.registerTask(&#39;test&#39;, &#39;my first tasks&#39;, function () &#123;        grunt.log.write(&#39;Hello World!&#39;).ok();    &#125;);&#125;</code></pre><p>接着我们只要在当前目录运行<br><code>grunt test</code></p><p>就能看到控制台输出</p><blockquote><p>Hello World.</p></blockquote><p>接下来咱们有个node 环境就可以想干嘛的就干嘛了..停住!如果只是这样,这跟我们写个shell脚本有什么区别呢?实际上grunt跟shell 脚本没什么区别,只是grunt有一个node 运行环境,可以比写shell脚本简单那么一些,如果你已经是shell脚本达人,我觉得没有再学grunt必要了.</p><p>###任务的任务###</p><p>有时候,我们有很多任务,不过这里任务,都可以归类为一中,我们就需要注册一个多任务来处理这种情况,例如,文件的操作就有,创建,打开,重命名,这些任务都可以归类为文件操作任务</p><pre><code class="js">module.exports = function (grunt) &#123;  grunt.initConfig(&#123;    file: &#123;      create: &#39;source file&#39;,      open: &#39;open file&#39;,      delete: &#39;delete file&#39;    &#125;&#125;);  grunt.registerMultiTask(&#39;file&#39;, &#39;Log stuff.&#39;, function () &#123;    grunt.log.writeln(this.target + &#39;: &#39; + this.data);  &#125;);&#125;</code></pre><p>这个时候我们运行的时候,就会看到如下接口</p><p><code>grunt file:create</code></p><blockquote><p>create: ‘source file’</p></blockquote><p><code>grunt file:open</code></p><blockquote><p>open: ‘open file’</p></blockquote><p><code>grunt file:delete</code></p><blockquote><p>delete: ‘delete file’</p></blockquote><p>那么在我们自定义多任务的时候,可以通过<code>this.target</code> 获得当前任务命令,然后通过<code>this.data</code> 获取到我们的配置值,接下来就是发挥你的想象力的时候了.</p><p>##总结##<br>实际上grunt不是什么神奇的时候,它最不过是一个运行在node的一个命令行工具,可以方便我们用js写脚本而已.</p><p>##插件推荐##</p><ol><li>grunt-contrib-watch<ul><li>监听文件修改</li></ul></li><li>grunt-curl<ul><li>想curl 下载远程js</li></ul></li><li>grunt-contrib-clean<ul><li>文件清理工具</li></ul></li><li>grunt-contrib-cssmin<ul><li>css压缩工具</li></ul></li><li>grunt-contrib-copy<ul><li>文件复杂工具</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用node-webkit开发PC 客户端</title>
      <link href="/2013/07/03/nodejs/nodeWebkitApp/"/>
      <url>/2013/07/03/nodejs/nodeWebkitApp/</url>
      
        <content type="html"><![CDATA[<p>##导言##<br>node-webkit 是一个很神奇的桌面客户端项目,正如这个项目的名字,这个项目是由node 和 webkit 构成,简单来说,就是你可以用HTML 5和 node 进行桌面客户端开发,而且客户端还是同时支持在 WIN,MAC,LINUX运行. 下面,就用一个简单的例子来展示一下node-webkit的魅力.</p><span id="more"></span><p>##创建项目##</p><p>###本例子基于Grunt构建###<br>如果,你用过grunt,要创建一个node-webkit 非常简单,我已经写好了一个node-webkit的<code>grunt-init</code>的项目模板. 至于怎么安装这个模板,跟官方的教程一样.<br>如果你是windows 用户</p><blockquote><p><code>md %USERPROFILE%\.grunt-init\node-webkit</code> <br /><br><code>git clone git@github.com:youxiachai/grunt-init-node-webkit.git %USERPROFILE%\.grunt-init\node-webkit</code></p></blockquote><p>linux or mac</p><blockquote><p>git clone <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:youxiachai&#x2F;grunt-init-node-webkit.git ~&#x2F;.grunt-init&#x2F;node-webkit</p></blockquote><p>你只需要用</p><blockquote><p><code>grunt-init node-webit</code></p></blockquote><p>就可以创建完毕.</p><pre><code class="shell">├─app.nw└─test</code></pre><p>app.nw 这个目录就是我们准备要开始写的pc 客户端的项目文件夹,运行node-webkit项目很简单,只需要把node-webkit 的运行环境配置到环境变量,然后运行</p><blockquote><p><code>nw app.nw</code> 就可以运行起来了.<br><img src="/images/nodewebkit/nodewebkit1.jpg" alt="oscdesk1"></p></blockquote><p>PS: 如果你不想接触grunt,不过我建议还是学一下grunt,你可以到<a href="https://github.com/rogerwang/node-webkit#quick-start">https://github.com/rogerwang/node-webkit#quick-start</a> 学习如何启动一个node-webkit应用.</p><p>##效果图##<br><img src="/images/nodewebkit/oscdesk1.jpg" alt="oscdesk1"></p><p><img src="/images/nodewebkit/oscdesk2.jpg" alt="oscdesk1"></p><p>这个就是所谓的 win 8 风格的客户端了吧….界面用的框架是这货:<a href="http://aozora.github.io/bootmetro/">http://aozora.github.io/bootmetro/</a> 90% 的时间都是调整界面…蛋疼死了……连个 win8 风格的progress 都没..让我非常伤心..也可能是alpha 的原因吧. 不过最后的效果,还是很难看,就凑合着过去吧….</p><p>###开发###<br>基于node-webkit 开发pc 客户端语言支持 <code>c/c++</code>,<code>html5</code>,<code>css3</code>, <code>js</code>,<code>node api</code>.好了,现在我们开始用html 5 + css3 写一个pc 客户端吧.<br><code>node-webkit</code>本质就是一个可以跑node 的浏览器,所以,我们用web 开发的技巧来开发pc 客户端毫无问题.</p><p>首先,打开<code>toolbar</code>,在<code>package.json</code>文件里面有个<code>toolbar</code>的参数,设置为<code>true</code>即可,就会见到如下图所示:</p><blockquote><p><img src="/images/nodewebkit/toolbar.jpg" alt="toolbar"></p></blockquote><p>点击那个三横线的按钮,一个chrome 风的调试窗口就出来了.</p><blockquote><p><img src="/images/nodewebkit/console.jpg" alt="console"></p></blockquote><p>开发的时候,我们修改完文件,并不需要重新运行程序来看结果,我们,可以直接点击左边的刷新按钮即可看到我们修改的运行结果.用<code>node-webkit</code>开发客户端是不是很方便了!</p><p>那么接下来,要开发一个oschina pc 客户端,我们只需要知道,相关api 就行了,从android 客户端源码里面可以得到相关api…具体代码在<code>app/model/oschinaApi.js</code> 文件里面.</p><p>node-webkit,已经吧相关的安全限制已经去掉,所以说,用node-webkit开发pc客户端,用webkit 发的请求不受同源限制. 用node-webkit 开发一些restful 应用是非常舒服的事情,只要有个不错的界面.关于<code>node-webkit</code>的东西也就这么些了,剩下的就是web 开发,不在本文<code>node-webkit</code>范围内,所以就不再啰嗦..</p><p>##使用的开源项目##<br>界面: </p><p><a href="http://aozora.github.io/bootmetro/">http://aozora.github.io/bootmetro/</a> </p><p><a href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></p><p>模板引擎: </p><p><a href="https://github.com/visionmedia/ejs">https://github.com/visionmedia/ejs</a></p><p>##项目地址##<br>Github: </p><blockquote><p><a href="https://github.com/youxiachai/osChinaDesktopClient">https://github.com/youxiachai/osChinaDesktopClient</a></p></blockquote><p>git@osc:</p><blockquote><p><a href="http://git.oschina.net/youxiachai/oschinadesktopclient">http://git.oschina.net/youxiachai/oschinadesktopclient</a></p></blockquote><p> 程序运行: windows用户之间去到<code>app.nw</code> 目录下运行 nw.exe 即可.</p><blockquote><p>cd app.nw <br/> nw.exe</p></blockquote><p>linux 或者mac 用户 把除 index.html,package.json,app 以外的文件删除,然后将<code>node-webkit</code> 运行环境配到环境变量中运行</p><blockquote><p>nw app.nw</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pomelo Issue Faq(Pomelo 常见问题集)</title>
      <link href="/2013/06/26/pomelo/pomelo-faq/"/>
      <url>/2013/06/26/pomelo/pomelo-faq/</url>
      
        <content type="html"><![CDATA[<p>##导言##<br>基本上把pomelo 在github上 两个issue repo 全部看完(4xx) <a href="https://github.com/NetEase/pomelo-cn/issues?state=open">pomelo-cn</a> <a href="https://github.com/NetEase/pomelo/issues?state=open">pomelo</a> 顺便吐槽一下貌似大家都不知道pomelo-cn? 发现一些新的中文issue 都是来自于pomelo…我觉得这样老外很伤心..呵呵…挑选了一下个人觉得有代表性的问题,因为纯粹是我个人评价,所以,欢迎你提供有价值的issue…</p><span id="more"></span><p>##版本问题##<br>####<a href="http://nodejs.netease.com/topic/51b4b6c33e8b1fca032a5a3a">0.4.2的心跳主动断开有BUG</a>####</p><p>####<a href="http://nodejs.netease.com/topic/51aa0c883e8b1fca0323e267">用pomelo的各位：千万不要升node 0.10.8 ~ 0.10.9 </a>####</p><p>##Connector##<br>####<a href="https://github.com/NetEase/pomelo-cn/issues/46">客户端是否可以连接area服务器 </a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/89">關於pomelo的一點疑惑</a> ####</p><p>##SessionService##</p><p>####<a href="https://github.com/NetEase/pomelo/issues/230">sessionService 多connector 踢session用户策略</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/199">有没有文档具体解释localSessionService和sessionService？</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/173">建议在session上增加notify方法</a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/185">关于msgRemote.js中Remote.prototype.forwardMessage函数的疑问</a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/90">fail to send message by uid for session not exist</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/84">谁能帮我介绍一下 pomelo的session 用法？</a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/186">关于api中的LocalSessionService，LocalSession，SessionService</a>####</p><p>##RPC##</p><p>####<a href="https://github.com/NetEase/pomelo/issues/212">RPC调用为何一定要传递session作为第一参数？</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/192">RPC调用耗时问题</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/65">关于IPC组件的设计</a>####</p><p>##ChannelService##</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/85">对于channelService的问题</a>####</p><p>##Socket##</p><p>####<a href="https://github.com/NetEase/pomelo/issues/200">如果想设置keepAlive和Nodelay在哪里设置呢？</a>####</p><p>##Handler##</p><p>####<a href="https://github.com/NetEase/pomelo/issues/204">指定default error handler</a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/69">关于Pomelo的几个问题</a>####</p><p>##模块##</p><p>####<a href="https://github.com/NetEase/pomelo/issues/195">关于pomelo-robot使用,说一下感想 </a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/30">关于Lordofpomelo基于灯塔的AOI服务的疑问</a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/93">几个关于admin和monitor的问题及建议</a>####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/7">关于lordofpomelo中的灯塔的疑惑 </a>####</p><p>##客户端##<br>####<a href="https://github.com/NetEase/pomelo/issues/113">android 客户端老是出现下面错误，java就没事</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/240">使用 pomelo-flashclient 连接 pomelo【0.4.3】 失败</a>####</p><p>##其他##</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/5">咨询一下网易Pomelo团队问题</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/14">请教关于游戏数据和游戏处理逻辑位置的问题</a> ####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/92">请问一下onUserLeave.bind(null, self.app)是什么意思 </a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/202">基于某个服务器的全局变量</a> ####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/180">官方有没有提供多物理机部署的文档？</a> ####</p><p>####<a href="https://github.com/NetEase/pomelo-cn/issues/82">还是关于游戏启动和得到所有在线玩家的问题</a>####</p><p>####<a href="https://github.com/NetEase/pomelo/issues/251">WEBSTORM 启动 POMELO CHAT 的GAME-SERVER出现 FAILED TO RUN, return code: 127</a>####</p>]]></content>
      
      
      <categories>
          
          <category> pomelo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pomelo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构博客园Android App</title>
      <link href="/2013/06/20/android/cnblogsAppRefactor/"/>
      <url>/2013/06/20/android/cnblogsAppRefactor/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>第一个全功能的非官方android客户端已经过去一年了…目前貌似已经不再更新的样子?最近发现,在android 4.1上运行的时候,列表都不能滚动了..而且,原界面设计,也不适合放在android 平板上使用,看了一下源码,跟我的编写风格出入挺大的,于是,就写一个我的博客园android 客户端.</p><p><strong>ps: 本人在广州正在 找nodejs 工作 不知道有木有推荐一下? 联系邮箱:<a href="mailto:&#x79;&#111;&#x75;&#x78;&#105;&#x61;&#99;&#x68;&#x61;&#105;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;">&#x79;&#111;&#x75;&#x78;&#105;&#x61;&#99;&#x68;&#x61;&#105;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a></strong></p><span id="more"></span><p>##客户端规划##<br>看了一下,博客园开放的API,没发现有闪存的API,所以没有目前暂时不打算实现关于用户信息这块的内容,目前提供来看用户登录最大的作用也就收藏一个文章,个人感觉意义不大….</p><p>###目标:###</p><ol><li>自适应android 手机和平板</li><li>扁平化的设计风格</li><li>文章自动离线保存</li><li>支持代码样式的博客内文</li></ol><p>然后花了昨天和今天,两天时间,终于把一个原型app 完成,看了一下,完成度还挺高的,首先要感谢<a href="http://www.cnblogs.com/walkingp/">@walkingp</a> 的贡献.</p><p>###当前版本的进度:###</p><ol><li>android 和平板的响应式设计</li><li>完成新闻列表,和博客列表的api</li></ol><p>编码花了两天,前天,写设计稿,单元测试,昨天敲代码,今天发布文档…</p><p>###TODOLIST###</p><ol><li>完善界面</li><li>实现新闻内容和博文内容的显示 </li><li>博文内容里面的代码支持样式(长期计划)</li></ol><p>##自适应设计##<br>现在android 平板已经不少了,android其实提供了一套很好用于兼容,手机和平板的机制,让我们不需像ios 那样做两个app..</p><p>看图吧</p><p>###手机导航###<br>手机上显示的导航为抽屉式导航:</p><p><strong>以下均为示意图,吐槽难看,前面已经说过原因了…</strong></p><p><img src="/images/cnblogsapp/phoneNav.jpg" alt="抽屉式导航"></p><p>新闻列表</p><p><img src="/images/cnblogsapp/phonenews.jpg" alt="新闻列表"></p><p>博客列表</p><p><img src="/images/cnblogsapp/phonebloglist.jpg" alt="博客列表"></p><p>###平板导航###<br>平板上显示为 actionbar Tabs 式导航:</p><p>新闻列表</p><p><img src="/images/cnblogsapp/tabletNewsList.jpg" alt="新闻列表"></p><p>博客列表</p><p><img src="/images/cnblogsapp/tabletbloglist.jpg" alt="博客列表"></p><p>有兴趣当白老鼠的可以下载打包好的APK(<a href="https://github.com/youxiachai/CnBlogs4Android">项目主页</a>))….不过,不保证能够完美运行在所有android上…..</p><p>下一次再见就是项目完成的时候了….目前没有ROADMAP….</p><p>##支持本项目##<br>如果,你对这个有点兴趣,愿意支持一下,没有什么比捐点线实在了…</p><p><a href="http://me.alipay.com/youxilua"><img src="/img/pay_encourage.png"></a></p><p>##关于本项目用到的库##<br>这个项目基于gradle 构建(发现 0.4.2 还是有bug…作为保留工具,目前主力工具还是adt)…由于依赖库的位置问题,目前而言,还不能直接fork就能跑..而且也不建议这个时候下载,或者fork,因为,还有很多地方会有改动.</p><p>项目地址 : <a href="https://github.com/youxiachai/CnBlogs4Android">https://github.com/youxiachai/CnBlogs4Android</a></p><p>###本人写的类库###</p><p>ActionTitleBar : <a href="https://github.com/youxiachai/ActionTitleBar">https://github.com/youxiachai/ActionTitleBar</a></p><p>OneXListView : <a href="https://github.com/youxiachai/OneXListview">https://github.com/youxiachai/OneXListview</a></p><p>ajaxQuery : <a href="https://github.com/youxiachai/ajaxAquery">https://github.com/youxiachai/ajaxAquery</a></p><p>嗯..以上类库目前皆无文档….不过,以后会有的…</p><p>###公共类库###</p><p>SlidingMenu : <a href="https://github.com/jfeinstein10/SlidingMenu">https://github.com/jfeinstein10/SlidingMenu</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Pomelo 搭建一个简易的推送平台</title>
      <link href="/2013/06/17/pomelo/pomelo_study_appserver/"/>
      <url>/2013/06/17/pomelo/pomelo_study_appserver/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>实际上,个人感觉,pomelo 目前提供的两个默认<code>sioconnector</code>和<code>hybridconnector</code> 使用的协议并不适合用于做手机推送平台,在pomelo的一份公开ppt里面,有提到过, 网易的消息推送平台是基于pomelo开发的 (一个frontend 支持30w 长连接,消耗了3g 内存,如果我没记错数据应该是这样),不过,这里用的前端(frontend)实现的是基于MQTT协议,我估计这个基于MQTT协议实现的frontend,基本不可能开源出来.这里只是说,默认提供的frontend不适合用于构建大型的推送平台(c10m规模的),一般而言(c10k级别的),个人感觉还是够用的.</p><p>为了展示,更多pomelo 的相关特性,可能这里的逻辑业务,与实际有所不同.敬请注意</p><span id="more"></span><p>##推送平台的架构图##<br>整个应用的架构图:</p><blockquote><p><img src="/images/pomelo/pushapp/Pushapp.png"></p></blockquote><p>###后端###</p><ul><li><a href="mailto:&#x70;&#111;&#x6d;&#101;&#108;&#111;&#64;&#x30;&#x2e;&#52;&#x2e;&#51;">&#x70;&#111;&#x6d;&#101;&#108;&#111;&#64;&#x30;&#x2e;&#52;&#x2e;&#51;</a></li></ul><p>###前端###</p><ul><li>android</li><li>web browser</li></ul><p>##开发约定##</p><p>###客户端请求对象###</p><pre><code class="js">&#123;    &quot;role&quot;: &quot;client/server&quot;,    &quot;apikey&quot;: &quot;String&quot;,    &quot;clientId&quot;: &quot;String&quot;&#125;</code></pre><p>###服务端返回对象###</p><p><strong>发给web management</strong></p><pre><code class="js">&#123;    &quot;code&quot;: &quot;Int httpCode ex: 200&quot;,    &quot;msg&quot;: &quot;String&quot;,    &quot;users&quot;: &quot;Array 客户端的clientId 值 ex:[&quot;android1&quot;] &quot;&#125;</code></pre><p><strong>发给android客户端</strong></p><pre><code class="js">&#123;    &quot;code&quot;: &quot;Int httpCode ex: 200&quot;,    &quot;msg&quot;: &quot;String&quot;&#125;</code></pre><p>###客户端访问用的route###</p><p>android:</p><blockquote><p>connector route &#x3D; sio-connector.entryHandler.enter, 用于把当前客户端加入到推送频道当中</p></blockquote><p>WebManagement:</p><blockquote><p>connector route &#x3D; hybrid-connector.entryHandler.enter,用于连接服务器.<br /><br>backend route &#x3D; pushserver.pushHandler.pushAll, 把消息推送到所有已连接的客户端.</p></blockquote><p>##后台编码##<br>Pomelo 有个特点,就是约定开发,很多地方是约定好的配置,优点是,架构清晰,可读性好,缺点是,需要大量的文档支持,目前而言,pomelo的官方文档做的不好的地方就是,虽然文档都有了,但是太零散了,分类不清楚,还有就是文档没跟上开发,有时候,你不阅读里面源码根本不知道这个api要传那些参数.</p><p>###sioconnector &#x2F; hybridconnector###<br>由于pomelo 0.3 以后新增了一个新的connector:hybridconnector,支持socket和websocket，使用二进制通讯协议,但是除了,网页js版本和c 客户端实现了这个connector,其他客户端均还没实现,所以,我们还需要一个兼容android 客户端的connector: siocnnector,关于两个connector 具体比较,以后有空重写<a href="http://blog.gfdsa.net/2013/06/04/pomelo_study_two/">这篇的时候</a>,暂时,你只要知道,这个两个connector,一个基于socket.io,一个基于socket和websocket 即可.</p><p><strong>app.js</strong><br>由于我们用到了两个不同的connector,所以要在app.js写上:</p><pre><code class="js">// 支持 socket.ioapp.configure(&#39;production|development&#39;, &#39;sio-connector&#39;, function()&#123;    app.set(&#39;connectorConfig&#39;,        &#123;            connector : pomelo.connectors.sioconnector        &#125;);&#125;);//支持 websocket 和 socketapp.configure(&#39;production|development&#39;, &#39;hybrid-connector&#39;, function()&#123;    app.set(&#39;connectorConfig&#39;,        &#123;            connector : pomelo.connectors.hybridconnector,            heartbeat : 300,            useDict: true,            useProtobuf: true        &#125;);&#125;);</code></pre><p>经过这样的配置,我们就能够使用两个不同的connector了.</p><p>###推送实现###<br>用pomelo 进行消息的推送,非常便捷,由于,我们现在只关注推消息给全部客户端,那样就非常简单了.</p><p>推送流程:</p><ul><li>根据uuid 把 android 客户端添加到各自的推送频道当中.</li><li>web 端根据uuid 把消息推送的全部在线的客户端.</li></ul><p><strong>为了教学的方便,这里的uuid 硬编码为: xxx-xx–xx-xx</strong></p><p>把客户端添加到相应的channel</p><pre><code class="js">//把客户端添加到推送列表中PushRemote.prototype.add = function(uid, role, sid, channelName, cb)&#123;    var channel = this.channelService.getChannel(channelName, true);    if(role === &#39;server&#39;)&#123;        //web 服务端直接返回用户列表        cb(null ,this.getUsers(channelName));    &#125;else &#123;        if(!!channel)&#123;            channel.add(uid ,sid);        &#125;        //uuid 告诉给服务端onAdd 事件        // [&#123;uid: userId, sid: frontendServerId&#125;]        var server = [&#123;uid: channelName, sid: sid&#125;];       this.channelService.pushMessageByUids(&#39;onAdd&#39;, &#123;msg: &quot;add ok&quot;, users:this.getUsers(channelName)&#125;,server, function(err)&#123;           if(err)&#123;               console.log(err);               return;           &#125;       &#125;);    &#125;&#125;;</code></pre><p>Frontend 利用rpc 调用pushserver 添加客户端到相应频道的方法.</p><pre><code class="js"> //sid 统一为web managment 所在的 frontend server.    this.app.rpc.pushserver.pushRemote.add(session, uid,role, &#39;connector-server-client&#39;, uuid, function(err, users)&#123;        if(err)&#123;            console.log(err);            return;        &#125;        if(users)&#123;            next(null, &#123;code: 200, msg: &#39;push server is ok.&#39;, users: users&#125;);        &#125;else&#123;            next(null,&#123;code: 200, msg: &quot;add ok&quot;, users: users&#125;);        &#125;    &#125;);</code></pre><p>web 管理端调用消息推送</p><pre><code class="js">Handler.prototype.pushAll = function(msg, session, next)&#123;    var pushMsg = this.channelService.getChannel(msg.apikey, false);    pushMsg.pushMessage(&#39;onMsg&#39;,&#123;msg: msg.msg&#125;, function(err)&#123;       if(err)&#123;           console.log(err);       &#125; else&#123;           console.log(&#39;push ok&#39;);           next(null, &#123;code: 200, msg: &#39;push is ok.&#39;&#125;);       &#125;    &#125;);&#125;;</code></pre><p>以上就是主要客户端如何加入到推送队列的代码,以及web 管理端进行消息推送的主要代码,是不是很简单! 完整代码可以参阅最后提供的github 地址.</p><p><strong>有一点要注意的,如果pomelo 项目要部署到外网或者局域网,frontend 的host 要填写当前host 主机的ip 地址</strong></p><p>例如:</p><pre><code class="js">&quot;connector&quot;: [    &#123;&quot;id&quot;: &quot;connector-server-1&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 3150, &quot;clientPort&quot;: 3010, &quot;frontend&quot;: true&#125;        ]</code></pre><p>部署到某台服务器,需要修改</p><pre><code class="js">&quot;connector&quot;: [    &#123;&quot;id&quot;: &quot;connector-server-1&quot;, &quot;host&quot;: &quot;192.168.1.107&quot;, &quot;port&quot;: 3150, &quot;clientPort&quot;: 3010, &quot;frontend&quot;: true&#125;        ]</code></pre><p>客户端访问相应的host 的地址.</p><p>客户端和服务端的github 地址: <a href="https://github.com/youxiachai/pomelo-pushServer-Demo">https://github.com/youxiachai/pomelo-pushServer-Demo</a></p><p>##附录##<br>如果,你现在对pomelo感兴趣的话,你可以看下我写的pomelo 的系列教程(因为还没写好所以暂时只发布在我的博客)暂时一共四篇.基本涵盖了pomelo 大部分基本知识点.</p><p><a href="http://blog.gfdsa.net/tags/pomelo/">http://blog.gfdsa.net/tags/pomelo/</a></p><p><strong>广州有招nodejs 程序员(有两年android 开发经验..orz)的吗…能否给个面试机会,联系邮箱: <a href="mailto:&#121;&#x6f;&#117;&#x78;&#x69;&#x61;&#x63;&#x68;&#97;&#x69;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;">&#121;&#x6f;&#117;&#x78;&#x69;&#x61;&#x63;&#x68;&#97;&#x69;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a></strong></p><p>参与的相关社区:</p><p>github: <a href="https://github.com/youxiachai">https://github.com/youxiachai</a></p><p>cnodejs(Top积分榜 14 …): <a href="http://cnodejs.org/user/youxiachai">http://cnodejs.org/user/youxiachai</a></p><p>独立博客: <a href="http://blog.gfdsa.net/">http://blog.gfdsa.net</a></p>]]></content>
      
      
      <categories>
          
          <category> pomelo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pomelo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于HTTP 协议认证介绍与实现</title>
      <link href="/2013/06/15/http/webhttpauth/"/>
      <url>/2013/06/15/http/webhttpauth/</url>
      
        <content type="html"><![CDATA[<p>##导言##<br>一直对http 的头认证有兴趣,就是路由器的那种弹出对话框输入账号密码怎么实现一直不明白,最近,翻了一下http 协议,发现这是一个RFC 2617的实现,所以写篇文章介绍一下吧.</p><span id="more"></span><p>###Http基本认证###<br>这是一个用于web浏览器或其他客户端在请求时提供用户名和密码的登录认证,要实现这个认证很简单:</p><p>我们先来看下协议里面怎么定义这个认证的.</p><ol><li><p>编码: 将用户名 追加一个 冒号(‘:’)接上密码,把得出的结果字符串在用Base64算法编码.</p></li><li><p>请求头: Authorization: 认证类型 编码字符串</p></li></ol><p>来看一下客户端如何发起请求<br>例如,有一个用户名为:tom, 密码为:123456 怎么认证呢?</p><p>步骤如下</p><ol><li><p>编码 </p><blockquote><p>Base64(‘tom:123456’) &#x3D;&#x3D; dG9tOjEyMzQ1Ng&#x3D;&#x3D;;</p></blockquote></li><li><p>把编码结果放到请求头当中</p><blockquote><p>Authorization: Basic dG9tOjEyMzQ1Ng&#x3D;&#x3D;</p></blockquote></li></ol><p>请求样例<br>客户端</p><pre><code class="shell">GET / HTTP/1.1Host: localhostAuthorization: Basic dG9tOjEyMzQ1Ng</code></pre><p>服务端应答</p><pre><code class="shell">HTTP/1.1 200 OKDate: Thu, 13 Jun 2013 20:25:37 GMTContent-Type: application/json; charset=utf-8Content-Length: 53</code></pre><p>如果没有认证信息</p><pre><code class="shell">HTTP/1.1 401 Authorization RequiredDate: Thu, 13 Jun 2013 20:25:37 GMTWWW-Authenticate: Basic realm=&quot;Users&quot;</code></pre><p>验证失败的时候,响应头加上WWW-Authenticate: Basic realm&#x3D;”请求域”.</p><p>这种http 基本实现,几乎目前所有浏览器都支持.不过,大家可以发现,直接把用户名和密码只是进行一次base64 编码实际上是很不安全的,因为对base64进行反编码十分容易,所以这种验证虽然简便,但是很少会在公开访问的互联网使用,一般多用在小的私有系统,例如,你们家里头的路由器,多用这种认证方式.</p><p>###Http 摘要认证###<br>这个认证可以看做是基本认证的增强版本,使用随机数+密码进行md5,防止通过直接的分析密码MD5防止破解.<br>摘要访问认证最初由 RFC 2069 (HTTP的一个扩展：摘要访问认证)中被定义<br>加密步骤:</p><ol><li><p><img src="/images/webhttp/ha1.png"></p></li><li><p><img src="/images/webhttp/ha2.png"></p></li><li><p><img src="/images/webhttp/res.png"></p></li></ol><p>后来发现,就算这样还是不安全(md5 可以用彩虹表进行攻击),所以在RFC 2617入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数。这些增强为了防止如选择明文攻击的密码分析。</p><blockquote><p><img src="/images/webhttp/d1.png"></p></blockquote><ol><li><p>如果 qop 值为“auth”或未指定，那么 HA2 为</p><blockquote><p><img src="/images/webhttp/d2.png"></p></blockquote></li><li><p>如果 qop 值为“auth-int”，那么 HA2 为</p><blockquote><p><img src="/images/webhttp/d3.png"></p></blockquote></li><li><p>如果 qop 值为“auth”或“auth-int”，那么如下计算 response：</p><blockquote><p><img src="/images/webhttp/d4.png"></p></blockquote></li><li><p>如果 qop 未指定，那么如下计算 response：</p><blockquote><p><img src="/images/webhttp/d5.png"></p></blockquote></li></ol><p>好了,知道加密步骤,下面我们用文字来描述一下;</p><p>最后,我们的response 由三步计算所得.</p><ol><li><p>对用户名、认证域(realm)以及密码的合并值计算 MD5 哈希值，结果称为 HA1。</p><blockquote><p>HA1 &#x3D; MD5( “tom:Hi!:123456” )<br>    &#x3D; d8ae91c6c50fabdac442ef8d6a68ae8c</p></blockquote></li><li><p>对HTTP方法以及URI的摘要的合并值计算 MD5 哈希值，例如，”GET” 和 “&#x2F;index.html”，结果称为 HA2。</p><blockquote><p>HA2 &#x3D; MD5( “GET:&#x2F;“ ) &#x3D; 71998c64aea37ae77020c49c00f73fa8</p></blockquote></li><li><p>最后生成的响应码</p><blockquote><p>Response &#x3D; MD5(“d8ae91c6c50fabdac442ef8d6a68ae8c:L4qfzASytyQJAC2B1Lvy2llPpj9R8Jd3:00000001:c2dc5b32ad69187a<br />:auth:71998c64aea37ae77020c49c00f73fa8”) &#x3D; 2f22e6d56dabb168702b8bb2d4e72453;</p></blockquote></li></ol><p>RFC2617 的安全增强的主要方式:</p><p>发起请求的时候,服务器会生成一个密码随机数(nonce)(而这个随机数只有每次”401”相应后才会更新),为了防止攻击者可以简单的使用同样的认证信息发起老的请求,于是,在后续的请求中就有一个随机数计数器(cnonce),而且每次请求必须必前一次使用的打.这样,服务器每次生成新的随机数都会记录下来,计数器增加.在RESPONSE 码中我们可以看出计数器的值会导致不同的值,这样就可以拒绝掉任何错误的请求.</p><p>请求样例(服务端 qop 设置为”auth”)</p><p>客户端 无认证</p><pre><code class="shell">GET / HTTP/1.1Host: localhost</code></pre><p>服务器响应(qop 为 ‘auth’)</p><pre><code class="shell">HTTP/1.1 401 Authorization RequiredDate: Thu, 13 Jun 2013 20:25:37 GMTWWW-Authenticate: Digest realm=&quot;Hi!&quot;, nonce=&quot;HSfb5dy15hKejXAbZ2VXjVbgNC8sC1Gq&quot;, qop=&quot;auth&quot;</code></pre><p>客户端请求(用户名: “tom”, 密码 “123456”)</p><pre><code class="shell">GET / HTTP/1.1Host: localhostAuthorization: Digest username=&quot;tom&quot;,                     realm=&quot;Hi!&quot;,                     nonce=&quot;L4qfzASytyQJAC2B1Lvy2llPpj9R8Jd3&quot;,                     uri=&quot;/&quot;,                     qop=auth,                     nc=00000001,                     cnonce=&quot;c2dc5b32ad69187a&quot;,                     response=&quot;2f22e6d56dabb168702b8bb2d4e72453&quot;</code></pre><p>服务端应答</p><pre><code class="shell">HTTP/1.1 200 OKDate: Thu, 13 Jun 2013 20:25:37 GMTContent-Type: application/json; charset=utf-8Content-Length: 53</code></pre><p>注意qop 设置的时候慎用:auth-int,因为一些常用浏览器和服务端并没有实现这个协议.</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pomelo 一周之旅--星期四</title>
      <link href="/2013/06/06/pomelo/pomelo_study_four/"/>
      <url>/2013/06/06/pomelo/pomelo_study_four/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>今天我们介绍一下Channel 广播机制和RPC 的使用。</p><span id="more"></span><p>##Channel##<br>对于一个游戏服务器，而言，把消息推送给玩家，这是一个很基础的功能，在pomelo 里面用Channel 进行消息的推送服务，要进行消息的推送，Channel提供了两种方式：</p><ul><li>匿名Channel</li><li>具名Channel</li></ul><p>###匿名Channel###<br>什么是匿名Channel？匿名Channel就是直接使用channelService进行消息推送，在api 中提供了两种方式</p><p>这种是指定用户Session 里面的绑定的UID（<code>session.bind(uid);</code>）推送到那个session uid 的方式有四个参数</p><ul><li>route String type</li><li>msg Object type</li><li>uids Array Type <blockquote><p><code>[&#123;uid: userId, sid:  frontendServerId&#125;]</code> 注意数组里面每个对象的属性</p></blockquote></li><li>cb - cb(err) 错误的回调<br>例子:</li></ul><pre><code class="js">var uidArray = new Array();uidObject.uid = &quot;session uid&quot;;uidObject.sid = &quot;connector-server-1&quot;;uidArray.push(uidObject);channelService.pushMessageByUids(&#39;onMsg&#39;,&#123;msg:msg&#125;,uidArray,function(err)&#123;       if(err)&#123;           console.log(err);           return;       &#125;    &#125;);</code></pre><p>第二种就是把消息广播到所有连接在frontend 服务器的客户端.</p><ul><li>stype String type<blockquote><p>指定我们需要广播的frontend 类型，注意这里不是frontend id 而是类型，例如<code>connector</code> 如果你配了多台服务器，消息会广播到所有连接在这种类型frontend的客户端上。</p></blockquote></li><li>route String type<blockquote><p>如 ‘onMsg’</p></blockquote></li><li>msg Object type</li><li>opts Object type<blockquote><p>自0.4.x 的配置只有一个参数 opts.binded Boolean type<br>true 根据session 的uid 进行广播，false 根据session的id 进行广播</p></blockquote></li><li>cb</li></ul><pre><code class="js">channelService.broadcast(&#39;connector&#39; ,&#39;onMsg&#39;, msg, &#123;binded: true&#125;, function(err)&#123;       if(err)&#123;           console.log(err);       &#125;    &#125;);</code></pre><p>###具名Channel###<br>具名Channel 就是我们在pomelo 创建一个推送房间。用于维护需要长期订阅关系的业务，例如，聊天的频道，注意使用具名Channel 如果那个Channel不在使用，需要显式调用销毁接口。</p><p>例子：</p><pre><code class="js"> //创建Channelvar channelName = &#39;allPushChannel&#39;;var channel = this.channelService.getChannel//把用户添加到channel 里面if(!!channel)&#123;        channel.add(uid, sid);&#125;</code></pre><pre><code class="js"> //根据Channel 名字推送消息    var channelName = &#39;allPushChannel&#39;;    var pushChannel = this.channelService.getChannel(channelName, false);    pushChannel.pushMessage(&#39;onMsg&#39;,&#123;msg: msg&#125;, function(err)&#123;        if(err)&#123;            console.log(err);        &#125;else&#123;            console.log(&#39;push ok&#39;);        &#125;    &#125;);</code></pre><p>以上就是pomelo 有关推送的全部内容，用pomelo进行消息的推送就是这么简单！</p><p>##RPC使用##<br>从pomelo 框架图里面我们可以知道，pomelo 是一个多进程相互协作的环境。关于这方面的pomelo是如何实现的可以阅读官方的<a href="https://github.com/NetEase/pomelo/wiki/Pomelo-Framework">Pomelo Framework</a></p><p>这里不再对pomelo如何实现rpc 进行描述，针对原文档的一些不清晰的地方进行补充。</p><p>如何使用rpc 服务，让frontend 能够调用backend 的方法？</p><p>要实现这个目的很简单。<br>根据Pomelo 的相关阅读。首先在handler 同级目录下创建一个remote目录，创建一个<code>backendRemote</code>文件(具体可以参考分布式聊天的例子)</p><p>值得注意的是，我们调用远程方法的时候，第一个参数需要是Session值。</p><pre><code class="js">//远程服务端backend.kick = function(uid, sid)&#123;&#125;//调用远程服务的时候，我们要需要从app 获得rpc服务var rpc = app.rpc;//代理端的完整写法rpc.frontend.kick = function(session, uid, sid)&#123;&#125;</code></pre><p>以上就是pomelo 多进程相互协作的使用方式</p>]]></content>
      
      
      <categories>
          
          <category> pomelo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pomelo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pomelo 一周之旅--星期三</title>
      <link href="/2013/06/05/pomelo/pomelo_study_three/"/>
      <url>/2013/06/05/pomelo/pomelo_study_three/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>今天，我们谈谈Pomelo的会话机制</p><span id="more"></span><p>##会话机制##<br>从pomelo 的api 文档我们可以发现，有三个大类与session有关</p><ul><li>LocalSessionService</li><li>SessionService</li><li>LocalSession</li></ul><p>###Session 介绍###<br>从pomelo 的api文档中我们可以总结出：</p><p>SessionService 是只存在于前端服务器（frontend），session 以每个客户端请求自增1的形式生成 ,用于管理连接 pomelo的客户端，如果在前端服务器不进行相关控制对于每个请求都会产生一个Session，就是说客户端都会在前端的服务器（frontend）里的sessionService产生一个会话，值得注意的是自pomelo0.4.x支持了支持同一账号多处登录，所以seesionService 里面的session 对应的是一个session数组，如果，对session不做任何处理的话，没刷新一次页面，都会对这个session 数组自增 1.从暴露的api，我们可以看出，这个SessionService 可以用于对连接在前端服务器的客户端，踢下线，或者利用session id 直接在前端服务器发消息给客户端。</p><p>LocalSessionService 由于SessionService只存在于前端服务器（frontend），如果想在后端服务器（Backend）操作SessionService的话，就需要一个代理类（因为这是两个进程），从源码中可以看到，这个就是从前端服务器复制出来用于backend进行操作的SessionService，主要用于获取踢客户端下线，或者获取相关客户端Session Id。</p><p>LocalSession 是用于我们自定义的id 与全局 sessionService进行管理的类。主要用于服务端对客户端之间会话的管理。</p><p>从api 文档暴露的接口我们可以得知主要作用：</p><ul><li><p>让我们自定义的id 可以绑定到客户端与服务端之间的会话，用于管理客户端的状态。例如，利用绑定的id实现控制对客户端进行踢掉，监听session的关闭事件。</p></li><li><p>localSession 还提供了一个K&#x2F;V 的数据存取操作 需要用push或者pushAll 对sessionSerive进行更新。但是，根据官方的回复，不建议把session当做内存库。</p></li></ul><p>###Session FAQ##</p><ol><li><p>Session 是否适合当初内存数据库使用？</p><blockquote><p>session里存的是只读的用户状态数据， 不会同步到数据库。 内存数据的同步是另一个模块实现的。<br>不要把session当成内存数据库使用， session会在各服务器节点间传递， 因此session的内容越少、越轻量越好。<br/>问题及答案来自于：<a href="https://github.com/NetEase/pomelo/issues/84">谁能帮我介绍一下 pomelo的session 用法？</a></p></blockquote></li><li><p>localSessionService和sessionService的区别？</p><blockquote><p>如果看完本章节还是不明白的话？<br/>可以参见<a href="https://github.com/NetEase/pomelo/issues/199">有没有文档具体解释localSessionService和sessionService？</a></p></blockquote></li><li><p>如何在connector以外的服务器中获取全局session？</p><blockquote><p><a href="https://github.com/NetEase/pomelo-cn/issues/31">如何在connector以外的服务器中获取全局session</a></p></blockquote></li><li><p>uid 不能为object</p><blockquote><p>问题来源于 ： <a href="https://github.com/NetEase/pomelo-cn/issues/90">fail to send message by uid for session not exist</a></p></blockquote></li></ol><p>##扩展阅读##<br>ES 5的 bind()方法。</p><p>在pomelo的一些demo 里面可能会不理解这么一句话</p><pre><code class="js">session.on(&#39;closed&#39;, onUserLeave.bind(null, this.app));var onUserLeave = function(app, session) &#123;    if(!session || !session.uid) &#123;        return;    &#125;    app.rpc.chat.chatRemote.kick(session, session.uid, app.get(&#39;serverId&#39;), session.get(&#39;rid&#39;), null);&#125;;</code></pre><p>你可能会有这样的疑问</p><ol><li><p>为什么onUserLeave 会有两个参数? </p></li><li><p>函数的bind() 第一个参数null 什么什么意思，结合第一个问题，这里就传了一个参数？那么那个session 还是怎么传过来的？</p></li></ol><p>这个函数 bind() 方法是ES 5 新增的一个特性。用于将函数绑定到某个对象上。</p><p>那么这里bind()的方法的作用是什么呢？</p><p>要明白这里的bind()的用法，首先我们需要了解一种函数式编程技术—柯里化（currying）</p><blockquote><p><a href="http://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96">Wiki是这么定义的: </a>在计算机科学中，柯里化（Currying），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>为了帮助理解这里写一个小例子(来自于Javascript 权威指南第六版 p191)</p><pre><code class="js">var sum = function(x, y)&#123;    return x+y;&#125;//创建一个类似于sum的新函数，但this的值绑定到null//并且第一个参数绑定到1， 这个新函数的期望只传入一个实参var succ = sum.bind(null, 1);console.log(succ(2)); //输出 3； x 绑定到1，并传入2作为实参//另外一个做累计计算的函数var sum2 = function(y ,z)&#123;    return this.x + y + z;&#125;//绑定this 和 yvar bindSum2 = sum2.bind(&#123;x : 1&#125;, 2);console.log(bindSum2(3)); //输出 6； this.x 绑定到1，y绑定到2， z 绑定到3.</code></pre><p>上面这个例子就是柯里化的应用了，现在我们回到pomelo看下，chatpomelo例子里面怎么使用这个柯里化技术。</p><p>现在，应该能解决开头的第一个问题了，那么第二个问题，我们需要阅读一下pomelo的源码</p><p>阅读源码<a href="https://github.com/NetEase/pomelo/blob/master/lib/common/service/sessionService.js">sessionService.js 464-478</a></p><p>从这十几行代码和柯里化的知识，我们就能够明白为什么onUserLeave为什么会有两个参数了。</p><pre><code class="js">var onUserLeave = function(app,  session)&#123;   &#125;</code></pre><p>最后的参数是通过柯里化的技术把单参数 session 传到我们多参数函数里面。</p><p>这里有一篇讲柯里化技术挺有趣的文章：<br><a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/">http://www.zhangxinxu.com/wordpress/2013/02/js-currying/</a></p><p>补充内容：<br>Session</p><p>Session可以看成一个简单的key&#x2F;value对象，主要作用是维护当前玩家状态信息，比如：当前玩家的id，所连的frontend服务器id等。Session对象由客户端所连接的frontend服务器维护。在分发请求给backend服务器时，frontend服务器会克隆session，连同请求一起发送给backend服务器。所以，在backend服务器上，session应该是只读的，或者起码只是本地读写的一个对象。任何直接在session上的修改，只对本服务器进程生效，并不会影响到该玩家的全局状态信息。如需修改全局session里的状态信息，需要调用frontend服务器提供的RPC服务。</p>]]></content>
      
      
      <categories>
          
          <category> pomelo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pomelo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pomelo 一周之旅--星期二</title>
      <link href="/2013/06/04/pomelo/pomelo_study_two/"/>
      <url>/2013/06/04/pomelo/pomelo_study_two/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>昨天，简要的介绍了客户端如何发起对Pomelo的请求和处理pomelo响应，今天，我们说一下，Pomelo服务端如何处理请求响应以及如何开始我们服务端代码的编写。</p><span id="more"></span><p>##Pomelo 请求与响应##</p><p>Pomelo请求响应流程图。</p><p><img src="/images/pomelo/two/request_response.png"></p><p>在pomelo 请求响应模型中，它只有三层。</p><ol><li>发起请求与响应的客户端。</li><li>接受，响应请求的Frontend。</li><li>处理Frontend 请求与响应的Backend。</li></ol><p>在昨天，我们已经知道了如何利用frontend进行与客户端的通信，那么什么是Backend?</p><p>我先来看一下官方的定义：</p><p><strong>Frontend（connector）</strong></p><ul><li>用于面向客户端的连接</li><li>维护Session信息</li><li>分发请求给Backend</li><li>推送消息给客户端</li></ul><p><strong>Backend</strong></p><ul><li>处理来自于Frontend的请求</li><li>通过Channel 或者 Response 推送请求给frontend</li><li>Rpc 服务</li></ul><p>从以上定义中，我们可以这么认为，Frontend 是用于面向客户端请求的服务器，用于维护当前的连接数以及让客户端能够访问Backend 的桥梁，而Backend 用于处理游戏的逻辑。</p><p>为了方便了解，我们可以阅读官方提供的框架图。</p><p><img src="/images/pomelo/two/framework.png"></p><p>###创建Frontend和Backend###<br>Pomelo 有一个特点就是通过对目录和命名约定进行来进行对组件的创建。现在我们去到<code>./game-server/app/servers/</code> 我们所有关于frontend和backend的代码都有在该目录下创建。</p><p><strong>创建规则</strong><br>###Frontend的创建###</p><pre><code class="bash">servers├─connector│  └─handler│          entryHandler.js</code></pre><p>第一级目录为servers Type，就是定义这个在服务端处于什么类型，例如，我们要创建一个<code>gate</code> 类型的服务用于负载均衡的话，我们只需要创建一个把<code>connector</code> 改为<code>gate</code>。</p><p>第二级目录约定为handler,所有处理请求的js文件都放在该目录下面。</p><p><code>entryHandler.js</code> 这个文件为我们处理请求和响应的文件。</p><p>以上规则就是我们在Pomelo 里面要响应对客户端请求的步骤。然后，我们只需要在配置文件上面做一些修改，Pomelo在启动的时候就会加载我们创建好的frontend了。（详情阅读<strong>声明使用Frontend和Backend</strong>）</p><p>对于客户端而言只要在请求的时候对应以上规则即可<code>阅读hello world项目 /public/index.html 大概19 -36行代码</code></p><pre><code class="js">   pomelo.request(&quot;connector.entryHandler.entry&quot;, &quot;hello pomelo&quot;, function(data) &#123;                alert(data.msg);          &#125;);</code></pre><p>假如我们常见了一个gate的 frontend 用于负载均衡我们在客户端只需要做如下修改就能进行对gate的访问了。</p><pre><code class="js">   pomelo.request(&quot;gate.entryHandler.entry&quot;, &quot;hello pomelo&quot;, function(data) &#123;                alert(data.msg);          &#125;);</code></pre><p>###Backend的创建###</p><pre><code class="bash">servers└─testBackend    ├─handler    │      entryHandler.js    │    └─remote            testBackendremote.js</code></pre><p>规则与frontend基本一致，不过多了一个remote目录，用于RPC 的处理。然后，我们只需要在配置文件上面做相关配置，pomelo在启动的时候就会加载我们创建好的Backend。（详情阅读<strong>声明使用frontend，backend</strong>）</p><p>接着客户端如果要访问Backend 需要先连接接Frontend 再从回调中发起对Backend的访问。</p><blockquote><p> client -&gt; frontend -&gt; backend 这个过程不可越过</p></blockquote><p><code>hello world项目 /public/index.html 大概19 -36行代码</code>增加。</p><pre><code class="js">     pomelo.request(&quot;connector.entryHandler.entry&quot;, &quot;hello frontend&quot;, function(data) &#123;         pomelo.request(&quot;testBackend.entryHandler.entry&quot;, &quot;hello backend&quot;, function(data) &#123;                    alert(data.msg);                &#125;);            &#125;);</code></pre><p>做了以上的修改以后，客户端就能对服务端的Backend发起请求并且响应。</p><p>##配置Frontend和Backend##<br>上面我们知道了如何在服务端创建Frontend，Backend规则，那么Pomelo如何加载我们的定义好的的frontend,和backend 呢？</p><p>要让pomelo 加载我们创建好的frontend和backend 需要在 <code>./game-server/config/servers.json</code> 作以下修改。<strong>因为development与production的设置是一样的这里就以development为例</strong></p><pre><code class="js">&#123;    &quot;development&quot;: &#123;        &quot;connector&quot;: [            &#123;                &quot;id&quot;: &quot;connector-server-1&quot;,                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 3150,                &quot;clientPort&quot;: 3010,                &quot;frontend&quot;: true            &#125;        ],        &quot;testBackend&quot;: [            &#123;                &quot;id&quot;: &quot;test-server-1&quot;,                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 3151            &#125;        ]    &#125;&#125;</code></pre><p>###Frontend配置说明###</p><p>对于frontend 对象而言</p><pre><code class="js">&quot;connector&quot;: [            &#123;                &quot;id&quot;: &quot;connector-server-1&quot;,                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 3150,                &quot;clientPort&quot;: 3010,                &quot;frontend&quot;: true            &#125;        ]</code></pre><ul><li>id 就是该frontend的在服务器的名字</li><li>host 服务器的地址</li><li>port 服务器的端口号</li><li>clientPort 客户端用于连接的端口号</li><li>frontend 是否是一个frontend</li></ul><p>###Backend配置说明###<br>backend对象基本与frontend一致，只是少了面向客户端端口的声明</p><pre><code class="js">&quot;testBackend&quot;: [            &#123;                &quot;id&quot;: &quot;test-server-1&quot;,                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 3151            &#125;        ]</code></pre><ul><li>id 就是该frontend的在服务器的名字</li><li>host 服务器的地址</li><li>port 服务器的端口号</li></ul><p>###添加服务器###<br>对于Pomelo而言，添加服务器只需要在配置文件中作如下修改，这样我们就添加多了一台connector的服务器了，如果要添加一台backend服务器，也是一样的道理。</p><pre><code class="js">&quot;connector&quot;: [            &#123;                &quot;id&quot;: &quot;connector-server-1&quot;,                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 3150,                &quot;clientPort&quot;: 3010,                &quot;frontend&quot;: true            &#125;，             &#123;                &quot;id&quot;: &quot;connector-server-2&quot;,                &quot;host&quot;: &quot;127.0.0.1&quot;,                &quot;port&quot;: 3151,                &quot;clientPort&quot;: 3011,                &quot;frontend&quot;: true            &#125;        ]</code></pre><p>##总结##<br>今天，对于Pomelo的理解：</p><p><strong>服务端</strong></p><ul><li>如何进行请求响应。</li><li>如何创建我们一个frontend或者backend。</li><li>如何通过配置文件让pomelo加载我们的frontend和backend。</li></ul><p><strong>客户端</strong></p><ul><li>客户端如何发起对backend请求。</li></ul><p>##资料来源##<br><a href="https://github.com/NetEase/pomelo/wiki/">pomelo 官方wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> pomelo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pomelo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pomelo 一周之旅--星期一</title>
      <link href="/2013/06/03/pomelo/pomelo_study_one/"/>
      <url>/2013/06/03/pomelo/pomelo_study_one/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>由于目前pomelo公开资料没有什么教程类的，所以就简单的写个学习笔记，用来记录一下。</p><p>##通读api##<br>个人认为，竟然要使用一个框架，对于框架提供的api必须要烂熟与心，pomelo的api 还是挺少的，所以量化一下，让初学者感觉读api不是那么可怕的事情。</p><span id="more"></span><p>###7个大类###</p><p>Application (31 个方法)</p><p>由于这块的方法比较多，简单分一下类</p><p>环境</p><p><code>getBase()；</code></p><p><code>set();</code></p><p><code>get</code></p><p><code>enabled();</code></p><p><code>disabled();</code></p><p><code>enbale();</code></p><p><code>disable();</code></p><p><code>configure();</code></p><p>初始化</p><p><code>start();</code></p><p><code>registerAdmin()</code></p><p><code>filter();</code></p><p><code>before()</code></p><p><code>after()</code></p><p><code>load()</code></p><p><code>loadConfig();</code></p><p>组件相关<br><code>route</code></p><p>获取相关配置，组件方法<br><code>getMaster()</code></p><p><code>getCurServer()</code></p><p><code>getServerId()</code></p><p><code>getServerType();</code></p><p><code>getServers();</code></p><p><code>getServersFromConfig();</code></p><p><code>getServerTypes();</code></p><p><code>getServerById();</code></p><p><code>getServerFromConfig();</code></p><p><code>getServersByType();</code></p><p><code>isFrontend()</code></p><p><code>isBackend()</code></p><p><code>isMaster()</code></p><p><code>addServers();</code></p><p><code>removerServers();</code></p><p>下面几个大类，方法比较少就不分类了。</p><p>ChannelService （5 个方法）</p><p>Channel （6 个方法） </p><p>LocalSessionService （ 4个方法）</p><p>LocalSession （6个方法）</p><p>SessionService （4个方法） </p><p>Pomelo（1个方法）</p><p>##Pomelo : Hello world ##</p><p>安装好pomelo 要创建一个项目很简单：</p><p><code>pomelo init heloworld</code></p><p>ok,我们的一个helloworld 就这样完成了。</p><p>###客户端编写###<br>我们来看一下，客户端如何与服务端进行通信的<br>打开<code>web-server/public/index.html</code> 阅读<code>19-32</code></p><pre><code class="js">     var pomelo = window.pomelo;      var host = &quot;127.0.0.1&quot;;      var port = &quot;3010&quot;;      function show() &#123;        pomelo.init(&#123;          host: host,          port: port,          log: true        &#125;, function() &#123;        pomelo.request(&quot;connector.entryHandler.entry&quot;, &quot;hello pomelo&quot;, function(data) &#123;            alert(data.msg);          &#125;);        &#125;);      &#125;</code></pre><p>从request请求<code>connnecor.entryHandler.entry</code>我们在game-server目录<br><code>app/servers/connector/handler/entryHandler.js</code><br>找到这么一个文件，打开这个文件以后我们发现了entry这个方法，现在我们能感叹，对于pomelo的通讯居然能够做到如此简单，为了验证我们的想法。我们在这个js文件里面加入</p><pre><code class="js">Handler.prototype.helloworld = function(msg, session, next)&#123;    console.log(msg);    console.log(session);    next(null,  &#123;code: 200, msg: &#39;Hello world!&#39;&#125;);&#125;</code></pre><p>接着客户端修改：</p><pre><code class="js">  pomelo.request(&quot;connector.entryHandler.helloworld&quot;, &quot;hello pomelo&quot;, function(data) &#123;            alert(data.msg);          &#125;);        &#125;);</code></pre><p>运行项目，然后就能看到我们成功完成服务端与客户端的通讯了。</p><p>今天，我们简单的搞明白了pomelo 如何创建项目，然后，客户端如何发起请求，已经服务端如何编写能够接受客户端请求的方法。</p>]]></content>
      
      
      <categories>
          
          <category> pomelo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> pomelo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 应用的动画实践--View Animation篇</title>
      <link href="/2013/05/30/android/androidan/"/>
      <url>/2013/05/30/android/androidan/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>尝试搜索了一下android 动画的中文资料，很多都是一些枯燥的翻译api的一些文档，很少有系统讲解如何利用动画开发一个应用的资料，忽然，发现很多应用也不怎么注重动画在app的应用，想了想，自己尝试总结一下吧。因为，本人也不是什么动画制作师，没法把动画做得很绚丽，只好，利用内置的效果，进行简单加工，如何发挥，由各位的创意来定。鉴于，很多有关的android的动画资料里面，都是堆代码的，所以，<a href="https://github.com/youxiachai/AnimUtils">全部代码均放在了github上面，查看完整代码可以移步到github上面去</a>。</p><p><strong>特地说明一下，由于android 模拟器和录制工具的原因，例子展示中的gif 的抽筋播放效果不等同于实际效果，自己脑补把抽筋的部分去掉</strong></p><span id="more"></span><p>##android 动画基础##</p><p>在Android 里你能够使用的动画效果：</p><ul><li><p>平移</p></li><li><p>缩放</p></li><li><p>旋转</p></li><li><p>透明</p></li></ul><p>以上动画的基本使用就是本文的内容了。由于，本人的能力问题，实在搞不出让人眼前一亮的动画，就凑合着看着吧。不过，那些令人赞叹的动画效果的基础就是这些。</p><p>###Interpolators（插值器）###</p><p>一般而言，要做动画的，需要封装点物理公式，用作为计算帧与帧间的数值计算，不过，如果，只是，为了搞些动画让app好用一些，倒不需要搞得这么复杂，android 官方api 已经封装好了一些常用的动画插值器。</p><p>默认内置7种类型的插值器，个人觉得，如果只是应用里面的一些动画的话这7个就够用了。</p><ol><li><p>AccelerateInterpolator</p><blockquote><p> 加速 <br/><br><img src="/images/androidanim/AccelerateInterpolator.gif" alt="AccelerateInterpolator"></p></blockquote></li><li><p>Decelerate</p><blockquote><p> 减速 <br/><br><img src="/images/androidanim/decelerate.gif" alt="decelerate"></p></blockquote></li><li><p>AccelerateDecelerateInterpolator</p><blockquote><p>开始，和结尾都很慢，但是，中间加速<br/><br><img src="/images/androidanim/accelerate_decelerate.gif" alt="accelerate_decelerate"></p></blockquote></li><li><p>AnticipateInterpolator</p><blockquote><p>开始向后一点，然后，往前抛<br/><br><img src="/images/androidanim/anticipate.gif" alt="anticipate"></p></blockquote></li><li><p>OvershootInterpolator</p><blockquote><p>往前抛超过一点，然后返回来<br/><br><img src="/images/androidanim/overshoot.gif" alt="overshoot"></p></blockquote></li><li><p>AnticipateOvershootInterpolator</p><blockquote><p>开始向后一点，往前抛过点，然后返回来<br/><br><img src="/images/androidanim/anticipate_overshoot.gif" alt="anticipate_overshoot"></p></blockquote></li><li><p>BounceInterpolator</p><blockquote><p>结束的时候弹一下<br/><br><img src="/images/androidanim/bounce.gif" alt="bounce"></p></blockquote></li><li><p>LinearInterpolator</p><blockquote><p>匀速</p></blockquote></li></ol><p>以上动画都源自android官方api demo，用eclipse adt android 选择例子项目导航，然后，选择APIDEMOS 就能创建（什么没听说过？现在知道了吧。。。）</p><p>好了，虽然截取的gif 动画播放起来有点抽筋的感觉，接下来我们该如何在应用中使用这些知识呢？</p><p>###组合动画###<br><strong>目前讲解动画api 的资料比较多，这里就不在重复那些基础的知识了！</strong></p><p>现在让我们学习一下，如何利用，平移，缩放，旋转创造出让人眼前一亮的动画.</p><p>为了，更有目的的使用动画，下面假想一个使用场景。</p><p>####假想：商品购物车案例####</p><blockquote><p>Notice :为了方便看效果，动画延时时间将会设置的比较长。特地说明一下：假想就是随便想，切勿对号入座。</p></blockquote><p>任务：</p><p>为了，让商城app有更好的交互效果，决定对购物车控件和商品控件上面加一些动画效果。</p><p>购物车动画设计方案：</p><p>利用，透明，平移，对购物车的出现和离开增加动画交互效果。</p><p><a href="https://github.com/youxiachai/AnimUtils/blob/master/AnimUtils/res/anim/in_translate_top.xml">经过一番努力效果如下(凑合着看吧。。)：</a></p><blockquote><p><img src="/images/androidanim/anim1.gif" alt="anim1"></p></blockquote><p>####相关知识点####<br>一些动画常用的通用基础属性：</p><blockquote><p>Notice: 所谓通用就是说所有动画标签都适用于这些属性</p></blockquote><ul><li><code>android:duration</code> 设置动画播放的时间</li><li><code>android:startOffset</code> 设置动画的开始播放时间</li><li><code>andorid:interpolator</code> 设置动画的插值器</li><li><code>android:repeatCount</code> 动画播放的常用次数</li><li><code>android:repeatMode</code> 动画重播的模式，即从头到尾，从头到尾，还是从头到尾，在从尾到头。</li></ul><p>透明的使用:</p><p><code>&lt;alpha /&gt;</code></p><blockquote><p>value 从 0 （透明） 到 1 （不透明）<br>在android中透明主要用于对view 淡入，淡出的效果控制主要有两个属性</p></blockquote><ul><li><code>android:fromAlpha</code> view在动画开始的透明度。</li><li><code>android:toAlpha</code>  view在动画结束的透明度。</li></ul><p>平移的使用：</p><p><code>&lt;translate /&gt;</code></p><blockquote><p>支持使用 %，如 “50%“ 获取的是这个view的百分之50，除此之外还有另外一种写法：”50%p“ 意思是获取这个view的上一级view的百分之50 当然，指定特定值也是支持的“22.2”，不过为了兼容更多的android设备建议还是使用百分比的值。</p></blockquote><ul><li><p><code>android:fromXDelta</code> </p></li><li><p><code>android：fromYDelta</code></p><blockquote><p>from?Delta 意思是开始的轴线</p></blockquote></li><li><p><code>android:toXDelta</code></p></li><li><p><code>android：toYDelta</code> </p><blockquote><p>to?Delta 意思是结束的轴线</p></blockquote></li></ul><p>这次的方案展示了两个插值器的使用：</p><p>用于出现的：BounceInterpolator</p><p>用于离开的： AnticipateInterpolator</p><p>###什么是插值器？###<br>所谓插值器就是用于数值的起始间的变化，就是相当于一个类似于物理引擎的东西。android官方内置了一些简单常用的数值变换，让我们，不需要去学习相关的物理知识。</p><p>例如：</p><p>开始值为1，结束值为 100.那么我们如何控制变化这个值的变化过程呢？这里就是插值器的使用。</p><p>一般匀速的话就是：</p><p>1,2,3,4,5…100。 然后我们就会看到物体以一个匀速的速度进行平移操作。</p><p>那么我们需要物体像汽车那样加速度的前进，我们可以用加速插值器，我们从1到100的过程，就会是：</p><p>1,2,4,5,8，16.。。。。100 展示在我们面前的view对象就会以一个加速度的形式进行平移。</p><p>有很多应用开发者并不熟悉动画制作的一些基础知识，可能不太明白。现在，通过对源码进行分析，来彻底搞明白这个概念。</p><p>我们分析一些Interpolator 类树：</p><p>从api文档<a href="https://developer.android.com/reference/android/animation/TimeInterpolator.html">TimeInterpolator</a> 我们可以知道，这个插值器的实现只有一个方法：</p><blockquote><p><code>getInterpolation(float t);</code></p></blockquote><p>然后我们挑选前面用过的<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/animation/BounceInterpolator.java">BounceInterpolator</a> 看下，它是如何实现这个方法。如果感兴趣的，可以按照这种方法，把其他几个插值器的实现都看一遍。</p><p>最后我们会发现，插值器的作用就是返回值。</p><p>接着我们来看下<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/animation/Animation.java">Animation line:869</a> 是怎么用这个接口的. </p><p>看完这这几个地方，相信应该对android 动画框架怎么对值进行变换的原理应该有所了解。</p><p>有了以上知识，我们对android的动画框架基本上已经完全了解，现在，我们利用学到的知识，进行更好的动画设计。</p><p>我们接着刚才的案例，着手设计商品控件的动画设计</p><p>商品动画设计：</p><p>这次，我们学习一个新的动画标签缩放(<code>&lt;scale&gt;</code>)</p><p>效果如下：</p><p><img src="/images/androidanim/shop1.gif" alt="shop1"></p><p><code>&lt;scale /&gt;</code></p><blockquote><p>使view 大点或者小点</p></blockquote><ul><li><p><code>android:fromXScale</code> </p></li><li><p><code>android：fromYScale</code></p><blockquote><p>from?Scale 意思是开始轴线的缩放比例（默认 1.0）</p></blockquote></li><li><p><code>android:toXScale</code></p></li><li><p><code>android：toYScale</code> </p><blockquote><p>to?Scale 意思是结束轴线的缩放比例（默认 1.0）</p></blockquote></li><li><p><code>android:pivotX</code></p></li><li><p><code>android:pivotX</code></p><blockquote><p> 旋转用的轴点坐标</p></blockquote></li></ul><p>最后我们把购物车的动画，和商品的动画在组合起来。效果如下：</p><p>添加商品的时候，如果购物车还没出现，先出现购物车显示的动画，在进行商品的动画播放。<a href="https://github.com/youxiachai/AnimUtils/blob/master/AnimUtilsExample/src/com/youxiachai/animutils/example/MainActivity.java">具体实现 line: 77 -104</a></p><p><img src="/images/androidanim/shop2.gif" alt="shop2"></p><p>这次我们学习一下如何监听动画的动作，对于<code>AnimationListener()</code>主要有三个</p><ul><li><p><code>onAnimationStart(Animation animation)</code></p></li><li><p><code>onAnimationRepeat(Animation animation)</code></p></li><li><p><code>onAnimationEnd(Animation animation)</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Gradle 构建你的android程序-依赖管理篇</title>
      <link href="/2013/05/22/android/android4gradledenp/"/>
      <url>/2013/05/22/android/android4gradledenp/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>续上一篇《用Gradle 构建你的android程序》，这次把上次没写的关于，如何用gralde 构建带有依赖的项目补全吧。</p><span id="more"></span><p>##Gradle android 插件现况##<br>个人感觉还是说说，目前android gradle 插件的现况，如无意外应该是最新的。</p><p>目前最新的官方gradle android 是0.4，除了android 官方的gralde的插件，也有一些开发者很早以前开发的gradle 插件，不过现在基本不维护了，所以这里不对这些第三方的gradle插件进行介绍。</p><p><a href="http://search.maven.org/#artifactdetails|com.android.tools.build|gradle|0.4|jar">android Gradle 0.4 插件maven中央库</a>,目前新的android gradle 构建系统基本完善，现在已知的问题有</p><ol><li>不支持android library 与 android library 的互相引用。</li><li>不支持 NDK</li><li>不支持android library 打包文件（*.aar） 的本地引用</li></ol><p>如果，以上问题的你都碰到不到的话，从现在开始，用gradle来构建android程序是一个不错的选择。</p><p>##引用依赖##<br><strong>这里阅读的前提是你已经把上一篇已经看过。</strong></p><p>###本地依赖###<br>gradle 作为构建工具，能够很方便的使用本地jar包，以下为使用的代码块。</p><pre><code class="groovy">dependencies &#123;    //单文件依赖    compile files(&#39;libs/android-support-v4.jar&#39;)    //某个文件夹下面全部依赖    compile fileTree(dir: &#39;libs&#39;, include: &#39;*.jar&#39;)&#125;android &#123;    &#125;</code></pre><p>###远程依赖###<br>gradle 同时支持maven，ivy，由于ivy我没用过，所以用maven 作为例子，以下为代码块：</p><pre><code class="groovy">repositories &#123;    //从中央库里面获取依赖    mavenCentral()    //或者使用指定的本地maven 库    maven&#123;        url &quot;file://F:/githubrepo/releases&quot;    &#125;    //或者使用指定的远程maven库    maven&#123;        url &quot;https://github.com/youxiachai/youxiachai-mvn-repo/raw/master/releases&quot;    &#125;&#125;dependencies &#123;    //应用格式: packageName:artifactId:version    compile &#39;com.google.android:support-v4:r13&#39;&#125;android &#123;&#125;</code></pre><p>###android library 依赖###<br>对于项目依赖 android library的话，就不是依赖一个jar，那么简单了，在这里需要使用gradle  mulit project 机制。<br>例子的话，我就不重复写了，具体参考上一篇提到的德国人写的例子。<strong>记得把插件版本改为 0.4</strong><br><a href="https://github.com/Goddchen/Android-Gradle-Examples/tree/master/Gradle%20Library%20Projects">https://github.com/Goddchen/Android-Gradle-Examples/tree/master/Gradle%20Library%20Projects </a></p><p><strong>注意对于android library <code>build.gradle</code> 记得要把</strong></p><blockquote><p>apply plugin: ‘android’ 改为 apply plugin: ‘android-library’</p></blockquote><p>####Mulit project 设置####<br>Mulit project 设置是gradle 约定的一种格式，如果你需要编译某个项目之前，要先编译另外一个项目的时候，就需要用到，结构如下图（来自于官方文档）：</p><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><div><span style="line-height:1.6;font-size:10pt;font-style:normal"><font face="courier new, monospace">MyProject/</font></span></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp;| settings.gradle</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp;+ app/</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp; &nbsp; | build.gradle</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp;+ libraries/</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp; &nbsp; + lib1/</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp; &nbsp; &nbsp; &nbsp;| build.gradle</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp; &nbsp; + lib2/</font></div><div><font face="courier new, monospace" style="font-style:normal">&nbsp; &nbsp; &nbsp; &nbsp;| build.gradle</font></div></blockquote><p>你需要在你的workplace 目录下面创建settings.gradle 的文件，然后在里面写上：</p><blockquote><p>include ‘:app’, ‘:libraries:lib1’, ‘:libraries:lib2’</p></blockquote><p>那样，gradle mutil project 就设置完毕。</p><p>对于app project 如果需要应用libraries 目录下的 lib1 ，你只需要在app project <code>build.gradle</code> 里面的依赖中这么写：</p><pre><code class="groovy">compile project(&#39;:libraries:lib1&#39;)</code></pre><p>即可完成，写完以后可以用<code>gradle AndroidDependencies</code> 来检查依赖状况。</p><p>###需要注意的地方###</p><pre><code class="python">buildscript &#123;    repositories &#123;        mavenCentral()    &#125;        dependencies &#123;        classpath &#39;com.android.tools.build:gradle:0.4&#39;    &#125;&#125;</code></pre><p>对于<code>buildscript&#123;&#125;</code> 在android gradle是用来预置插件环境，一般不建议把依赖写着里面，推荐的依赖写法是：</p><pre><code class="python">buildscript &#123;    repositories &#123;        mavenCentral()    &#125;        dependencies &#123;        classpath &#39;com.android.tools.build:gradle:0.4&#39;    &#125;&#125;repositories &#123;    //从中央库里面获取依赖    mavenCentral()    //或者使用指定的本地maven 库    maven&#123;        url &quot;file://F:/githubrepo/releases&quot;    &#125;&#125;dependencies &#123;    //应用格式: packageName:artifactId:version    compile &#39;com.google.android:support-v4:r13&#39;&#125;</code></pre><p>##使用Maven 管理库##<br>gradle 对于包的管理，支持filesystem，maven，ivy，这里我重点说说如何利用maven 进行android 依赖包的管理</p><p>###利用Gradle 发布本地maven 库###<br>对于如何打包一个jar 包并且发布到maven，这是java 的基本知识，这里就不说了。</p><p>我们现在要学习的是，例如发布一个android library 包。</p><p>在过去，android library并没有一个很好的包管理方式，简单来说，在gradle出现以前，官方并没有一种用于管理android library 依赖包的方式，一般我们都是直接下载别人的android library project 源码进行集成，而对于第三方的android-maven-plugin 用的是apklib 格式。</p><p>而现在，官方终于推出一种android library的打包格式，扩展名为<code>*.aar</code>。前面提到，目前android gradle插件并不支持本地直接使用<code>*.aar</code>文件，不过，支持包管理库的引用方式，下面，我为大家说一下，怎么对android library 发布使用。</p><ol><li><p>打包android library </p><blockquote><p>对android library 进行打包直接在library项目下面使用<code>gradle build</code> 即可，然后，你就会在 build&#x2F;libs 目录下看到两个<code>*.aar</code>文件，一个debug包用的，一个是release 下用的，看个人需求使用，这里我们用的是release 版本的 .aar 文件。</p></blockquote></li><li><p>发布脚本</p><blockquote><p>android library project 目录的  build&#x2F;libs 下创建一个build.gradle 文件</p></blockquote></li></ol><pre><code class="groovy">apply plugin: &#39;maven&#39;group = &#39;com.youxiachai&#39;artifacts &#123;    //当前aar 文件名    archives file(&#39;Gradlelib.aar&#39;)&#125;uploadArchives &#123;      repositories &#123;        mavenDeployer &#123;            repository(url: &quot;file://F:/githubrepo/releases&quot;)            pom.version  = &#39;r1&#39;            pom.artifactId = &#39;gradletest&#39;        &#125;    &#125;&#125;``` `gradle uploadArchives`即可完成包的发布。完成以上两步就可以直接用maven 引用jar的依赖那样，引用android library 的依赖。##扩展阅读##[Google I/O 2013 上面介绍的android Gralde build System‎ （已经转载到优酷）](http://v.youku.com/v_show/id_XNTYwMzY0NDYw.html)[Xavier Ducrohet](https://plus.google.com/+XavierDucrohet/posts) Android SDK Tech Lead,上面那个视频就是这个人演讲的。[adt-dev社区](https://groups.google.com/forum/#!topic/adt-dev/) 因为用gradle 构建android 是新系统，一般而言有问题是搜索不到的，有问题还是上社区直接问吧，一般[Xavier Ducrohet](https://plus.google.com/+XavierDucrohet/posts) 都会帮你解决。</code></pre>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动应用使用场景边界测试笔记</title>
      <link href="/2013/05/22/android/androidaccess/"/>
      <url>/2013/05/22/android/androidaccess/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>移动应用使用场景的，程序运行考虑。</p><span id="more"></span><p>##网络##</p><p>###无网络连接###<br>友好提示没有网络连接。</p><p>###连接类型###</p><ol><li><p>3&#x2F;2 G网络</p><blockquote><p> 提示注意流量使用</p></blockquote></li><li><p>wifi</p><blockquote><p> 就不提示了</p></blockquote></li></ol><p>###网络切换###</p><ol><li><p>由移动网络转向WIFI网络</p><blockquote><p>不提示了</p></blockquote></li><li><p>由WIFI转向移动网络</p><blockquote><p>注意流量使用</p></blockquote></li></ol><p>###连接超时###<br>提示，检查网络，或者重试</p><p>###网络中断###<br>提示，检查网络，或者重试</p><p>###网络恢复###<br>考虑是否自动重练</p><p>###数据读取中的中断###</p><ol><li>文件下载考虑自动断点恢复</li><li>优化提示继续下载</li></ol><p>##存储##<br>一般检查存储的大小，是否可用</p><p>###系统应用空间###<br>应用安装使用的空间</p><p>###内置存储空间###<br>内部rom 划分的空间</p><p>###外置存储空间###<br>一般为sd</p><p>##电池##<br>暂时没这个需求，不想这个场景。。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Gradle 构建你的android程序</title>
      <link href="/2013/05/19/android/android4gradle/"/>
      <url>/2013/05/19/android/android4gradle/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>android gradle 的插件终于把混淆代码的task集成进去了，加上最近，android studio 用的是gradle 来构建项目， 下定决心把android gralde 构建项目的用户指南全部看完， 让不会用gradle 的人也用gradle构建android项目，让打包（注意，打包和构建是两码事）多版本android不再痛苦。最后，题外话：珍惜生命，远离ant….</p><span id="more"></span><p>##Gradle build android 历史##<br><a href="http://tools.android.com/">Android Tools 主页</a> ，大概是今年2月份发布 adt21.1 的时候，忽然在主页发现了<a href="http://tools.android.com/tech-docs/new-build-system">New Build System</a> 原来是可以用gradle 来构建android项目，至于<a href="http://en.wikipedia.org/wiki/Gradle">gradle</a>是什么（既然点击进来看了应该都知道了吧。） 。然后，又看了一下<a href="http://tools.android.com/tech-docs/new-build-system/roadmap">RoadMap</a> 那时候，还并不支持Proguard 打包，于是就没看了。。。</p><p>最近，android studio 发布，终于gradle 0.4 也跟着出来了，于是，先把gradle 学了一遍，然后把<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Gradle Plugin User Guide</a>也认真阅读了一下，根据我的个人体验，如果你对gradle 毫无了解就去看<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Gradle Plugin User Guide</a> 可能很多地方都一头雾水，但是并不妨碍你用gradle 打包android 应用，只是，出现问题，你就可能很头疼。不过，本篇博文就是让不会gradle 也能用上 gradle 打包android 程序，因为，我也不懂gradle，所以，我把我碰到的问题的解决方案都一一列出。</p><p>顺便贴上官方为什么使用gradle 的理由</p><ul><li>Domain Specific Language (DSL) to describe and manipulate the build logic</li><li>Build files are Groovy based and allow mixing of declarative elements through the DSL and using code to manipulate the DSL elements to provide custom logic.</li><li>Built-in dependency management through Maven and&#x2F;or Ivy.</li><li>Very flexible. Allows using best practices but doesn’t force its own way of doing things.</li><li>Plugins can expose their own DSL and their own API for build files to use.</li><li>Good Tooling API allowing IDE integration</li></ul><p>##Gradle 基本概念##<br>首先我们学习几个gradle 的脚本语法，掌握了这几个语法，你就能非常简单的用gradle构建打包android项目了。<br>首先，我们来看下一个最简单android <code>build.gradle</code></p><pre><code>buildscript {        repositories {            mavenCentral()        }        dependencies {            classpath &#39;com.android.tools.build:gradle:0.4&#39;        }    }    apply plugin: &#39;android&#39;    android {        compileSdkVersion 17    }</code></pre><p><strong>英语的介绍都来自与 gradle官方文档， 主要后边的中文不是翻译，是补充介绍。。</strong></p><p><code>buildscript&#123;&#125;</code></p><blockquote><p>Configures the build script classpath for this project.<br>说白了就是设置脚本的运行环境</p></blockquote><p><code>repositories&#123;&#125;</code></p><blockquote><p>Returns a handler to create repositories which are used for retrieving dependencies and uploading artifacts produced by the project. 大意就是支持java 依赖库管理（maven&#x2F;ivy）,用于项目的依赖。这也是gradle 强力的地方。。。 </p></blockquote><p><code>dependencies&#123;&#125;</code></p><blockquote><p>The dependency handler of this project. The returned dependency handler instance can be used for adding new dependencies. For accessing already declared dependencies, the configurations can be used.  依赖包的定义。支持maven&#x2F;ivy，远程，本地库，也支持单文件，如果前面定义了<code>repositories&#123;&#125;</code>maven 库，使用maven的依赖（我没接触过ivy。。）的时候只需要按照用类似于<code>com.android.tools.build:gradle:0.4</code>，gradle 就会自动的往远程库下载相应的依赖。</p></blockquote><p><code>apply plugin:</code></p><blockquote><p>声明构建的项目类型，这里当然是android了。。。</p></blockquote><p><code>android&#123;&#125;</code></p><blockquote><p>设置编译android项目的参数，接下来，我们的构建android项目的所有配置都在这里完成。</p></blockquote><p>##构建一个Gradle android项目##<br>首先，你要安装<a href="http://www.gradle.org/downloads">Gradle 1.6</a> 并且，写进系统的环境变量里面，所有的命令都是默认你已经配好了gradle 的环境。而且，已经已经升级了android sdk 22</p><p>要用gradle构建你的有两种方式：（<strong>build.gradle 放到项目目录下</strong>）</p><ol><li>利用adt 22导出 build.gradle.</li><li>复制别人写好的build.gradle 文件.</li><li>根据gradle 规则，手写android 的build.gradle 文件。</li></ol><p>个人推荐1,2 方法。。。。</p><p>一个android build.gradle 最基本基本文件</p><pre><code>buildscript {    repositories {        mavenCentral()    }    dependencies {        classpath &#39;com.android.tools.build:gradle:0.4&#39;    }}apply plugin: &#39;android&#39;dependencies {}android {    compileSdkVersion 17    buildToolsVersion &quot;17&quot;    defaultConfig {        minSdkVersion 8        targetSdkVersion 17    }    sourceSets {        main {            manifest.srcFile &#39;AndroidManifest.xml&#39;            java.srcDirs &#x3D; [&#39;src&#39;]            resources.srcDirs &#x3D; [&#39;src&#39;]            aidl.srcDirs &#x3D; [&#39;src&#39;]            renderscript.srcDirs &#x3D; [&#39;src&#39;]            res.srcDirs &#x3D; [&#39;res&#39;]            assets.srcDirs &#x3D; [&#39;assets&#39;]        }        instrumentTest.setRoot(&#39;tests&#39;)    }}</code></pre><p>接着在命令行cd 到项目目录下</p><blockquote><p>例如: cd e:\workplace\andoridGradle</p></blockquote><p>如果你是第一次使用gradle 构建android项目建议你先使用<code>gradle clean</code> 把android gradle 插件，还有相关依赖包下载下来并且对环境进行初始化，如果出错了，一般可能是下载超时，试多几次即可，最后你会看到如下提示：<code>BUILD SUCCESSFUL</code></p><p>The TaskContainer.add() method has been deprecated and is scheduled to be remove<br>d in Gradle 2.0. Please use the create() method instead.</p><p>:clean UP-TO-DATE</p><p>BUILD SUCCESSFUL</p><p>Total time: 7.847 secs</p><p>完成以上的步骤，就可以正式使用gralde 构建你的android项目了。</p><p>然后使用<code>gradle build</code> 就完成了android 项目的构建了。如果，你是照着以上步骤走的话，你将会想项目目录里面看到一个build 的目录，里面就是用gradle 构建android项目的全部例如了，结构目录看附录。</p><p>最终打包的apk 就在build&#x2F;apk 目录下了。然后，你会发现，两个apk 一个是</p><ul><li>[项目名]-debug-unaligned</li><li>[项目名]-release-unsigned</li></ul><p>如果以上内容你都掌握的话，接下来就将详细说说如何利用gralde 打包android apk。<br>##Gralde 打包参数详解##<br>上面说了一大堆东西，其实并不吸引人去使用gradle，如果只是构建项目的话，adt不是更合适吗？如果，你看完以下内容还是这么觉得的话，你就没必要折腾gradle了。。。。。。</p><p>###打签名包###</p><p>看附录 默认输出 <em>release</em> apk 是没有签名的，那么我们需要签名的很简单，只需要在android{}里面补充加上加上即可。完整<a href="https://gist.github.com/youxiachai/5608223">build.gradle 请点击我的gist</a></p><pre><code>signingConfigs {   myConfig{     storeFile file(&quot;gradle.keystore&quot;)    storePassword &quot;gradle&quot;    keyAlias &quot;gradle&quot;    keyPassword &quot;gradle&quot;    }}       buildTypes{     release {    signingConfig  signingConfigs.myConfig     }    } </code></pre><p>然后，运行<code>gradle clean</code> <code>gradle build</code> ,这次在build&#x2F;apk  你看到了多了一个[项目名]-release-unaligned， 从字面上面我就可以知道，这个只是没有进行zipAlign 优化的版本而已。而[项目名]-release 就是我们签名，并且zipAlign 的apk包了.</p><p>###打混淆包###</p><p>只需要在原来的基础上加上，完整的<a href="https://gist.github.com/youxiachai/5608223">proguad.gradle 代码</a></p><pre><code>buildTypes{   release {   signingConfig  signingConfigs.myConfig     runProguard true     proguardFile &#39;proguard-android.txt&#39;   }}</code></pre><p><code>gradle clean</code></p><p><code>gradle build</code></p><p>###打多渠道包(Product Flavor)###</p><p>现在来解释一下上一节的问题，<strong>apk目录下的两个apk 的含义</strong></p><p><strong>为什么产生了两个apk？</strong></p><p>默认的android gralde 插件定义了两种apk 的类型<strong>debug</strong>, <strong>release</strong>，这两种类型的详细对比看附录。</p><p>这个是android gralde 插件 <code>buildTypes&#123;&#125;</code> 方法产生的，默认配置好了两个默认模板，当然你也可以修改，前面我们就是在修改默认的release 的配置，让输出release类型的的apk，具有签名和混淆。</p><p>对于多渠道包，android 插件提供了一个名为<code>Product Flavor&#123;&#125;</code> 的配置，用于进行多渠道打包。</p><p>例如，我的android应用有海外版，和国内版本，而且这两个版本的包名是不一样的！！（我就举两个市场的例子安装这个思路，你要打包100个不同的市场只是几行代码的事情。）。</p><p>你只需要在<code>android&#123;&#125;</code> 补充上</p><pre><code>productFlavors {playstore {packageName&#x3D;&#39;com.youxiachai.androidgradle.playstore&#39;}hiapk {packageName&#x3D;&#39;com.youxiachai.androidgradle.amazonappstore&#39;}}</code></pre>   <p>然后<code>gradle clean</code>,<code>gradle build</code>,在build&#x2F;apk 下面你会看到一堆的包，命名格式[项目名]-[渠道名]-release</p><p><strong>仅此而已?</strong></p><p><code>Product Flavor&#123;&#125;</code> 不只是能改包名那么简单，还能够对编译的源码目录进行切换。</p><p>什么意思? 不知道各位有没有用过友盟做用户统计，如果，你用的是分发渠道分析，你需要修改AndroidManifest.xml 添加上<br><code> &lt;meta-data android:value=&quot;hiapk&quot; android:name=&quot;UMENG_CHANNEL&quot;/&gt;</code></p><p>如果，你很多渠道，，然后你就会很痛苦，现在用gradle 就非常舒服，你只需要在<code>android.sourceSets</code>指定我们的渠道名就行，android  gradle 插件，会自动打包！！！例如</p><pre><code>sourceSets {    main {        manifest.srcFile &#39;AndroidManifest.xml&#39;        java.srcDirs &#x3D; [&#39;src&#39;]        resources.srcDirs &#x3D; [&#39;src&#39;]        aidl.srcDirs &#x3D; [&#39;src&#39;]        renderscript.srcDirs &#x3D; [&#39;src&#39;]        res.srcDirs &#x3D; [&#39;res&#39;]        assets.srcDirs &#x3D; [&#39;assets&#39;]    }            hiapk {      manifest.srcFile &#39;hiapk&#x2F;AndroidManifest.xml&#39;    }           playstore {       manifest.srcFile &#39;hiapk&#x2F;AndroidManifest.xml&#39;    }       instrumentTest.setRoot(&#39;tests&#39;)        }</code></pre><p>然后运行<code>gradle clean</code>,<code>gradle build</code>,省下的时间去喝杯咖啡，睡个觉什么的都好。。。</p><p>###外部依赖###<br>android gradle 对于外部jar 包的应用支持maven&#x2F;ivy 管理的包，也支持指定具体文件，前面已经在上文说过。上面演示的完整 build.gradle gist 里面也有写。你需要加上如下代码即可：</p><pre><code>dependencies {compile files(&#39;libs&#x2F;android-support-v4.jar&#39;)}</code></pre> <p>##结语##</p><p>至此，对于用android gradle 构建android应用程序，打包android 程序，所需要的所有知识，在以上已经说明，只要你是认真看上面文章的，对于，如何打依赖于android library project 的包，可以看附录提供的那个德国人写的例子，而对于<code>build.gradle</code> 里面的代码你需要把<code>0.2</code>, 改为<code>0.4</code>即可。至于用gradle 运行android test case部分的教程，个人感觉写了也白写（我写过关于andorid 测试相关的文章，也录制过视频，所以有这个感觉。），估计不会有人关注，所以，如果你对用gradle 进行android test的话，可以看附录里面提供的官方gradle手册。</p><p>##扩展阅读##</p><p> 对于这部分内容，你读与不读，并不影响你使用gradle 打包android 项目。至于读了的好处就是你能够更好的使用gradle。。</p><ul><li><p>完整的<a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Gradle Plugin User Guide</a> 其中里面有个错误是<code>compile files(&#39;libs/android-support-v4.jar&#39;)</code> 不是<code>compile file(&#39;libs/android-support-v4.jar&#39;)</code> 教程是基于android gradle0.3 ，在0.4中只是多了<strong>混淆打包，这块已经在文中补充了。</strong></p></li><li><p>一个德国人写的<a href="https://github.com/Goddchen/Android-Gradle-Examples">Android-Gradle-Examples</a></p></li><li><p><a href="http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html"><code>dependencies&#123;&#125;</code></a> 更多的介绍。</p></li><li><p><strong>debug</strong>, <strong>release</strong>,这两种类型的默认配置如下：</p><table cellspacing="0" bordercolor="#888" border="1" style="border-collapse:collapse;border-color:rgb(136,136,136);border-width:1px"><tbody><tr><td style="width:198px;height:19px">&nbsp;Property name</td><td style="width:195px;height:19px">&nbsp;Default values for debug</td><td style="width:241px;height:19px">&nbsp;Default values for release / other</td></tr><tr><td style="width:198px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>debuggable</b></font></td><td style="width:195px;height:20px">&nbsp;true</td><td style="width:241px;height:20px">&nbsp;false</td></tr><tr><td style="width:198px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>jniDebugBuild</b></font></td><td style="width:195px;height:20px">&nbsp;false</td><td style="width:241px;height:20px">&nbsp;false</td></tr><tr><td style="width:198px;height:19px">&nbsp;<b><font face="courier new, monospace" color="#38761d">renderscriptDebugBuild</font></b></td><td style="width:195px;height:19px">&nbsp;false</td><td style="width:241px;height:19px">&nbsp;false</td></tr><tr><td style="width:198px;height:20px">&nbsp;<b><font face="courier new, monospace" color="#38761d">renderscriptOptimLevel</font></b></td><td style="width:195px;height:20px">&nbsp;3</td><td style="width:241px;height:20px">&nbsp;3</td></tr><tr><td style="width:198px;height:20px">&nbsp;<b><font face="courier new, monospace" color="#38761d">packageNameSuffix</font></b></td><td style="width:195px;height:20px">&nbsp;null</td><td style="width:241px;height:20px">&nbsp;null</td></tr><tr><td style="width:198px;height:20px">&nbsp;<b><font face="courier new, monospace" color="#38761d">versionNameSuffix</font></b></td><td style="width:195px;height:20px">&nbsp;null</td><td style="width:241px;height:20px">&nbsp;null</td></tr><tr><td style="width:198px;height:20px">&nbsp;<b><font face="courier new, monospace" color="#38761d">signingConfig</font></b></td><td style="width:195px;height:20px">&nbsp;android.signingConfigs.debug</td><td style="width:241px;height:20px">&nbsp;null</td></tr><tr><td style="width:198px;height:20px">&nbsp;<b><font face="courier new, monospace" color="#38761d">zipAlign</font></b></td><td style="width:195px;height:20px">&nbsp;false</td><td style="width:241px;height:20px">&nbsp;true</td></tr></tbody></table></li><li><p><strong>defaultConfig {}</strong> 配置参数列表</p><table cellspacing="0" bordercolor="#888" border="1" style="border-collapse:collapse;border-color:rgb(136,136,136);border-width:1px"><tbody><tr><td style="width:208px;height:19px">&nbsp;Property Name</td><td style="width:168px;height:19px">&nbsp;Default value in DSL object</td><td style="width:251px;height:19px">&nbsp;Default value</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>versionCode</b></font></td><td style="width:168px;height:20px">&nbsp;-1</td><td style="width:251px;height:20px">&nbsp;value from manifest if present</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>versionName</b></font></td><td style="width:168px;height:20px">&nbsp;null</td><td style="width:251px;height:20px">&nbsp;value from manifest if present</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>minSdkVersion</b></font></td><td style="width:168px;height:20px">&nbsp;-1</td><td style="width:251px;height:20px">&nbsp;value from manifest if present</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>targetSdkVersion</b></font></td><td style="width:168px;height:20px">&nbsp;-1</td><td style="width:251px;height:20px">&nbsp;value from manifest if present</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>packageName</b></font></td><td style="width:168px;height:20px">&nbsp;null</td><td style="width:251px;height:20px">&nbsp;value from manifest if present</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>testPackageName</b></font></td><td style="width:168px;height:20px">&nbsp;null</td><td style="width:251px;height:20px">&nbsp;app package name + “.test”</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>testInstrumentationRunner</b></font></td><td style="width:168px;height:20px">&nbsp;null</td><td style="width:251px;height:20px">&nbsp;android.test.InstrumentationTestRunner</td></tr><tr><td style="width:208px;height:19px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>signingConfig</b></font></td><td style="width:168px;height:19px">&nbsp;null</td><td style="width:251px;height:19px">&nbsp;null</td></tr><tr><td style="width:208px;height:20px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>runProguard</b></font></td><td style="width:168px;height:20px">&nbsp;false</td><td style="width:251px;height:20px">&nbsp;false</td></tr><tr><td style="width:208px;height:19px">&nbsp;<font face="courier new, monospace" color="#38761d"><b>proguardFile</b></font></td><td style="width:168px;height:19px">&nbsp; 'proguard-android.txt' or 'proguard-android-optimize.txt'</td><td style="width:251px;height:19px">&nbsp; 'proguard-android.txt' or 'proguard-android-optimize.txt'</td></tr></tbody></table></li><li><p>build 结构目录</p><pre><code>build&#x2F;├── apk├── assets│   ├── debug│   └── release├── classes│   ├── debug│   │   └── com│   │       └── example│   │           └── gradle│   └── release│       └── com│           └── example│               └── gradle├── dependency-cache│   ├── debug│   └── release├── incremental│   ├── aidl│   │   ├── debug│   │   └── release│   ├── dex│   │   ├── debug│   │   └── release│   ├── mergeAssets│   │   ├── debug│   │   └── release│   └── mergeResources│       ├── debug│       └── release├── libs├── manifests│   ├── debug│   └── release├── res│   ├── all│   │   ├── debug│   │   │   ├── drawable-hdpi│   │   │   ├── drawable-mdpi│   │   │   ├── drawable-xhdpi│   │   │   ├── drawable-xxhdpi│   │   │   ├── layout│   │   │   ├── menu│   │   │   ├── values│   │   │   ├── values-sw720dp-land│   │   │   ├── values-v11│   │   │   └── values-v14│   │   └── release│   │       ├── drawable-hdpi│   │       ├── drawable-mdpi│   │       ├── drawable-xhdpi│   │       ├── drawable-xxhdpi│   │       ├── layout│   │       ├── menu│   │       ├── values│   │       ├── values-sw720dp-land│   │       ├── values-v11│   │       └── values-v14│   └── rs│       ├── debug│       └── release├── source│   ├── aidl│   │   ├── debug│   │   └── release│   ├── buildConfig│   │   ├── debug│   │   │   └── com│   │   │       └── example│   │   │           └── gradle│   │   └── release│   │       └── com│   │           └── example│   │               └── gradle│   ├── r│   │   ├── debug│   │   │   └── com│   │   │       └── example│   │   │           └── gradle│   │   └── release│   │       └── com│   │           └── example│   │               └── gradle│   └── rs│       ├── debug│       └── release└── symbols    ├── debug    └── release88 directories</code></pre></li></ul><p>##最后的吐槽##<br>吐槽一下。。。用ant脚本的（也许你没有接触过。。）。在以前你用ant 脚本打包apk的时候需要打包不同包名，你需要用ant 读取<code>AndroidManifest.xml</code> 然后又正则匹配替换里面packagename 参数。。虽然描述得过程很简单，你真去写的时候你就蛋疼了（对于一个ant外行人来说，个人感觉ant的学习曲线太陡峭了，如果是两年前的我，可能还写得出这样的ant脚本（当年费了很大的功夫学习了一个多星期），不过，因为很少用到（后来知道maven了。。果断放弃了ant，为什么不在android使用maven？ 因为，android 的maven 插件式非官方的，而且现在看来maven 的xml实在很复杂，看起来就头疼））*</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 新Notification api 介绍</title>
      <link href="/2013/05/10/android/andoridnotifylesson/"/>
      <url>/2013/05/10/android/andoridnotifylesson/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>最近，翻android api 手册的时候，发现Notification 篇里面的内容全部改了，提供了一种新的方式进行Notification 的生成，把源码看了以后，实际上提供了一种更好的封装，特地写篇文章普及一下这个新api 的用法</p><span id="more"></span><p>##使用##<br>要在3.x 以下使用这个新api需要导入，<a href="https://developer.android.com/tools/extras/support-library.html">support v4 r12 包</a> 这个包现在搞android的人不会不知道吧？</p><p>###NotificationCompat 介绍###</p><p>###TaskStackBuilder 介绍###</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AdapterView 源码分析以及其相关回收机制的分析</title>
      <link href="/2013/05/10/android/androidpageradapter/"/>
      <url>/2013/05/10/android/androidpageradapter/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>忽然，发现，网上的公开资料都是教你怎么继承一个baseadapter，然后重写那几个方法，再调用相关view的 setAdpater()方法， 接着，你的item 就显示在手机屏幕上了。很少有人关注android adpater模式机制的实现原理，比较深入的也不过是说说adapter getview()中的回收情况。今天把相关的源码看了一遍，把自己的理解记录下来。</p><span id="more"></span><p>##AdpaterView 概览##</p><p><a href="https://developer.android.com/reference/android/widget/AdapterView.html">AdpaterView</a></p><blockquote><p>api手册的说明：An AdapterView is a view whose children are determined by an Adapter.</p></blockquote><p>实际上android里面ListView, GridView, Spinner ， Gallery等view都是基于设计模式上的设配器模式实现的，只要熟悉设配器模式的相关知识，就知道如何从源码里面找到相关的实现线索。</p><p>##认识AdapterView##<br>源码链接<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AdapterView.java">https://github.com/android/platform_frameworks_base&#x2F;blob&#x2F;master&#x2F;core&#x2F;java&#x2F;android&#x2F;widget&#x2F;AdapterView.java</a></p><p>要理解listview等的实现，其父类是不得不看。源码有1200多行。阅读完AdapterView,能搞明白以下问题</p><ol><li><p>响应数据的更改。</p><blockquote><p>（793 - 842）</p></blockquote></li><li><p>知道点击view的时候，获得对应的位置.</p><blockquote><p>（593 - 615）</p></blockquote></li></ol><p>###响应数据的更改###<br>这里假设你已经打开了<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AdapterView.java">AdpaterView</a> 的 793 到 842 行。。</p><p>在我刚开始用adapterview 的时候，最让我费劲的就是，为什么我调用adpater 的 notifyDataSetChanged() 就能更新view 的状态了呢，然后跟调用notifyDataSetInvalidated() 两者之间又有什么区别呢？以前，找了一下资料，没找到很详细的说明，现在从源码里面找答案的话，就很清晰了。</p><p>首先，我们要明白一种设计模式：<a href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者设计模式</a>。</p><p>我相信你，应该能明白观察者模式是个什么样的实现了。。。</p><p>AdapterView 之所以能对Adapter 的数据更新进行响应，就是因为其在Adapter上注册了一个数据观察者（AdapterDataSetObserver(793 - 842 )）的内部类，所以，我们只要对adpater 状态的改变发送一个通知，就能让AdapterView调用相应的方法了。</p><blockquote><p>DataSetObservable 的源码，记得要把其父类也看了。 <a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/database/DataSetObservable.java">https://github.com/android/platform_frameworks_base&#x2F;blob&#x2F;master&#x2F;core&#x2F;java&#x2F;android&#x2F;database&#x2F;DataSetObservable.java</a></p></blockquote><p>现在我们就能解决我们一开始的疑问notifyDataSetChanged() 与notifyDataSetInvalidated() 具体回到AdapterView 产生什么影响？</p><p>我们对比一下<code>onChange()</code> 与 <code>onInvalidated()</code> 方法，就能对比得出，前者会对当前位置的状态进行同步，而后者会重置所有位置的状态。从代码的注释里面还可以获取得到更多的信息。</p><p>这样，我们以后调用notifyDataSetChanged()和notifyDataSetInvalidated() 就更加明白会发生什么情况了。</p><p>###点击item 怎么能够获取到当前的位置###<br>这里假设你已经打开了<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AdapterView.java">AdpaterView</a> 的 593 - 615 行。。</p><p>对于<code>getPositionForView()</code> 这个方法，你肯定没用过，要搞明白为什么我们能够获取到adapterView 里面item view对应的位置，我们需要看<br>其直接子类：<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AbsListView.java">AbsListView.class</a></p><blockquote><p> 源码相关：（2130-2197） （2196 - 2279）</p></blockquote><p>这里又用到一种设计模式：<a href="http://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F">委托模式</a></p><p>假设你已经搞懂委托模式的概念，首先我们来看源码（2130 - 2197）。</p><p>从<code>obtainView()</code> 方法名中我们可以知道，这是一个用于生成itemView的方法。把这块代码看完，以后，会不会有个疑问呢（先不用管回收那块）？ <strong>position</strong> 到哪里了？我们可以看到这个方法实际上并没有对我们的itemview 设置了任何的监听器，那为什么最后能对我们的itemview的动作进行反应呢？ </p><p>接下来我们看：源码（2196 - 2279）</p><p>从代码里面我们可以看出这是一个委托类，对item 的动作进行初始化，以及响应对应的操作，从源码里面我们可以获知得到，一个item view 为什么能对click，longclick，select 动作进行响应，然后，通过调用<code>performItemClick()</code> 最终把事件调用到AdapterView（292-303）的<code>performItemClick()</code> 里面的监听器方法.</p><p>如果，你对委托模式不熟的话，要明白这里的话，需要花点时间。</p><p>##认识 AbsListView 回收机制##</p><blockquote><p>源码： <a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AbsListView.java">AbsListView.class</a></p></blockquote><p>长期以来，都有这么一个说法，listview 会自动把不可见的view进行回收，但是长期以来，我都没看到有人对其回收机制进行分析说明</p><p>###回收执行者：RecycleBin###<br>我们回到之前看过的<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AbsListView.java">AbsListView.class</a>  </p><blockquote><p><code>obtainView()（2130-2197）</code></p></blockquote><p>你会看到一个</p><blockquote><p><code>mRecycler</code> 的变量。</p></blockquote><p>接下来，通过搜索我们可以得知这个变量是在（308）进行初始化，这是一个内部类的</p><blockquote><p>RecycleBin的实例（6139 - 6507） </p></blockquote><p>看到这类，我们大致可以知道，这个类是这个absListView 回收机制的实现者。</p><blockquote><p>请 跳转到（6139）</p></blockquote><p>现在，我们来看一下这个类的注释，大体的意思这个类是用来帮助复用view的，用2个不同级别的方式进行存储（The RecycleBin has two levels of storage）（个人感觉描述得挺变扭的，还是看原文好了。。）</p><ol><li>ActiveViews ： 一开始显示在屏幕的view</li><li>ScrapViews： 潜在的一些可以让adpater 使用的old views。</li></ol><p>然后，注释里面已经说了，ActiveViews 怎么变成 ScrapViews。就注释提供的信息这里我们有两个疑问。</p><ol><li>什么时候产生 ActiveViews。</li><li>什么时候产生 ScrapViews。</li></ol><p>这要把这两点搞清楚了，整个回收体系也就清楚了。</p><p>###AbsListView的回收机制具体实现###<br>从RecycleBin类的注释里面我们获知，回收机制的第一步就是屏幕的view 放在ActiveViews，然后通过对ActiveViews进行降级变成ScrapViews,然后通过scrapViews 进行view 的复用</p><p>通过，一番的检索，我们在<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/ListView.java">Listview.class</a>(1562行里面找到<code>fillActiveViews()</code>的调用）。</p><p>我们观察一下<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/ListView.java">Listview.class</a>（1460 - 1713） 看一下<code>layoutChildren()</code>这个方法是干嘛用的。</p><p>当我们看到（1550）行的时候，就会发现了这个回收类的赋值。接下来我们看下<br>listview是如何利用回收机制：</p><ol><li>当数据发生改变的时候，把当前的view放到scrapviews里面，否则标记为activeViews（1557 - 1562）</li><li><code>recycleBin.removeSkippedScrap();</code> 移除所有old views</li><li><code> recycleBin.scrapActiveViews();</code> 刷新缓存，将当前的ActiveVies 移动到 ScrapViews。</li></ol><p>这里干了些事情呢？我们回到（1557 - 1562） 我们可以看到一个变量dataChanged，从单词的意思我们就可以，这里的优化规则就是基于数据是否有变化，我们通过搜索成员变量<code>mDataChanged</code>在 (1693) 的时候变成了false 接着我们在<code>makeAndAddView</code>（1751 - 1775）发现了这个变量的使用。</p><p>阅读（1756 - 1766） 我们可以看到回收机制的第一次使用，如果数据没有发生改变，通过判断ActiveViews(这些些view来自（1557 - 1562）) 列表里面有没有当前 活动view，有的话直接复用已经存在的view。这样的好处就是直接复用当前已经存在的view，不需要通过adapter.getview()里面获取子view。</p><p>好了，接下来我们来看下<code>makeAndAddView</code>（1751 - 1775） 是如何通过<code>adapter.getview()</code>中 获取到view。我们回到<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AbsListView.java">AbsListView.class</a>（2130 - 2194）</p><p>在 （2134） 中我们看到一个很神秘的方法<code> scrapView = mRecycler.getTransientStateView(position);</code> 从单词的意思里面我们可以得知这是获取一个瞬间状态的view，这里就有个疑问什么是瞬间状态的view？通过对源码的层层分析终于在View 类的 hasTransientState()方法里面找到描述。从描述中我们得知这个方法是用来标记这个view的瞬时状态，用来告诉app无需关心其保存和恢复。从注释中，官方告诉我这种具有瞬时状态的view，用于在view动画播放等情况中。</p><p>那么，我们就可以明白这句话优化的是absListView 的列表动画.</p><p>接着阅读到一下代码的时候，我就困惑了</p><blockquote><p><code>scrapView = mRecycler.getScrapView(position);</code></p></blockquote><p>从这行代码里面我们可知，复用的review是跟位置有关的，我们回去在看看(ListView 1557-1563)</p><blockquote><pre><code>       if (dataChanged) &#123;            for (int i = 0; i &lt; childCount; i++) &#123;                recycleBin.addScrapView(getChildAt(i), firstPosition+i);            &#125;        &#125; else &#123;            recycleBin.fillActiveViews(childCount, firstPosition);        &#125;</code></pre></blockquote><p>我们可以发现，实际上这里放进回收类里面的只有当前的显示的view，并没有产生当前屏幕没有的view，但是，实际使用中，当我们进行滚屏的时候，显示下个view的时候，就已经能发现getView 第二个参数已经不为null了，那实际实现在哪里了，我们通过搜索用到RecycleBin 的方法，找到</p><blockquote><p><code>layoutChildren()</code></p></blockquote><blockquote><p><code>scrollListItemsBy()</code></p></blockquote><blockquote><p><code>onMeasure()</code></p></blockquote><blockquote><p><code>measureHeightOfChildren()</code></p></blockquote><p>通过查看</p><blockquote><p><code>scrollListItemsBy()</code> </p></blockquote><p>我们就能够明白，当我们进行滚屏的时候，在listview 移除item view 的时候，把移除的item view放进了</p><blockquote><p><code>  recycleBin.addScrapView(last, mFirstPosition+lastIndex);</code></p></blockquote><p>于是生成下一个view的时候就能够复用之前的view了，搞清楚这个机制以后我们回到</p><blockquote><p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/AbsListView.java">AbsListView.class</a>（2139 - 2168）</p></blockquote><p>接下来代码， 解答了我们一个经典的adapter 优化方法的由来</p><blockquote><pre><code>  View child;    if (scrapView != null) &#123;        child = mAdapter.getView(position, scrapView, this);</code></pre></blockquote><pre><code>        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);        &#125;        if (child != scrapView) &#123;            mRecycler.addScrapView(scrapView, position);            if (mCacheColorHint != 0) &#123;                child.setDrawingCacheBackgroundColor(mCacheColorHint);            &#125;        &#125; else &#123;            isScrap[0] = true;            child.dispatchFinishTemporaryDetach();        &#125;    &#125; else &#123;        child = mAdapter.getView(position, null, this);        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);        &#125;        if (mCacheColorHint != 0) &#123;            child.setDrawingCacheBackgroundColor(mCacheColorHint);        &#125;    &#125;</code></pre><p>实际上所谓的优化，就是通过利用已有产生的View进行复用，减少在Adapter.getView()进行类的实例化操作优化性能。</p><blockquote><p>从某年google io的文档中我们得知这个回收机制的效率能够提供listview 300%的效率。</p></blockquote><p>接着我们还明白了</p><blockquote><p>getView(int position, View convertView, ViewGroup parent) 这个三个参数的由来了。</p></blockquote><p>通过，对回收机制的分析，我们可以查看</p><blockquote><p>listview scrollListItemsBy()</p></blockquote><p>的时候应该注意到，实际上不可见的 item 是会被自动移除，那样为什么当滚动过多的item的时候会发生oom的情况了？</p><p>在我们阅读完整个回收机制的时候，我们会发现回收机制实际上是通过在内存里面缓存view对象，让listview能够快速的获取view使listview的显示流畅。而导致OOM的问题也出在这里，由于整个回收机制把所有的imageview中的bitmap对象也保存下来，在进行不断的滑屏操作中，RecycleBin 类越来越大，最终导致OOM 的发生。</p><p>当然，根据整个思路，要避免OOM实际上也很简单，我们只需要在虚拟机中开辟一个内存块，专门用于保存bitmap对象的 map对象（一般而言用LRU算法实现），所有的imageview的应用都通过这个map 对象进行引用，当这个map对象大于一定程度的时候释放部分bitmap，这就可以保证RecycleBin在保存这些imageview的时候，而这些imageview里面的bitmap对象时通过一个固定的内存块里面获取，只要我们开辟的用于引用的bitmap 的内存块的大小合理，那样就永远也不会发生oom了。</p><p>至于其他继承自AbsListView 的View 其回收机制都一样。。</p><p>##感想##<br>花了，几个小时，把AdapterView 相关源码看完，大致计算了行数有3w 来行代码了，当然，不会是一行不漏的看过去。 这里分享一个看源码的方法。首先，有接口和，抽象类的地方，一定要把所有方法看全，这一块基本上是属于要一行不漏的看完。实际上这些接口，和抽象类是我们看源码重要的索引，那些4，5k行的代码，实际上，里面的关键，都是这些接口，和相应的抽象类的扩展。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用nodejs 改造一个移动版本的网站</title>
      <link href="/2013/05/05/nodejs/nodescrapingpage/"/>
      <url>/2013/05/05/nodejs/nodescrapingpage/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>在浏览移动版本的oschina的时候,发现,怎么要找不到我最喜欢的翻译频道,正好我作为一个打杂的会一点node, 正愁着拿着node 不知道干什么东西好,就试着用node 做一个壳的移动版本翻译频道,如果你只对代码有兴趣的话,可以直接去 下载下来运行看看效果<a href="https://github.com/youxiachai/nodeScrapeOscTranslationChannel">https://github.com/youxiachai/nodeScrapeOscTranslationChannel</a></p><span id="more"></span><p>##准备##<br>其实,所谓的套壳,就是我们俗称的采集类网站,把别人网站的数据,变成自己的网站,虽然,不是上得了台面的东西,不过,如果不是用现成的采集工具,而是自己动手来干的话,你会对dom树的操作,网页的处理有更好的理解.基于某种考虑,特别写上.</p><p>###运用的技术与库###</p><ol><li><a href="http://nodejs.org/">nodejs</a></li><li><a href="https://github.com/tmpvar/jsdom">jsdom</a></li><li><a href="https://github.com/flesler/hashmap">hashmap</a></li><li><a href="https://github.com/visionmedia/express">express</a></li><li><a href="https://github.com/substack/node-mkdirp">mkdirp</a></li><li><a href="https://github.com/lockerfish/Downloader">downloader</a></li></ol><p>###分析###<br>我们要从外部改造一个网站,首先需要熟悉我们要改造对象的网站结构,将oschina 翻译频道进行草稿化,如下图<br><img src="/images/nodescrapingpage/oschina2.jpg"></p><p>经过我简单分析以后然后转换为移动版本的话<br><img src="/images/nodescrapingpage/oschina3.jpg"></p><p>在我的设计中只保留了分类,和列表,而在接下来的代码实现中,我只实现了列表的部分…</p><p>##译文列表部分##<br><a href="https://gist.github.com/youxiachai/5521332">翻译频道译文列表的解析转换代码</a> 请移步到gist 查看..为了方便阅读,修改了一下跟最后源码的实现会有点不同.</p><p>幸好翻译频道的结构挺简单的,由于刚上手js不久,这个第一版的dom解析代码还可以进行简化,虽然,现在这个版本挺难看的但是,可以跑起来.</p><p>这段代码的主要干了以下事情:</p><ol><li>迭代每个div.article 结点获取列表的信息,并且用<code>&lt;li /&gt;</code>标签进行包装</li><li>把链接转换为相对链接.</li></ol><p>最终的效果:左边为原页面,右边为移动版本</p><p><img src="/images/nodescrapingpage/oschina5.png" alt="原来的页面"><br><img src="/images/nodescrapingpage/oschina4.png" alt="改造好的页面"></p><p>好了,这就完成了web -&gt; mobile 页面的转换,接下来我们转化一下内容页.</p><p>##译文部分</p><p>草稿部分忽略,拍照什么的挺麻烦的..<br><a href="https://gist.github.com/youxiachai/5521332">翻译频道译文内容的解析转换代码</a> 请移步到gist 查看..为了方便阅读,修改了一下跟最后源码的实现会有点不同.</p><p>这部分就比较简单了,dom的操作</p><ol><li>获取译文内容</li><li>移除了译者信息..</li></ol><p>最终的效果:左边为原页面,右边为移动版本</p><p><img src="/images/nodescrapingpage/oschina6.png" alt="原来的页面"><br><img src="/images/nodescrapingpage/oschina7.png" alt="改造好的页面"></p><p>内容方面我们就搞定了.下面的部分就是如何部署一个套壳的网站</p><p>##建立属于自己的移动网站##<br>前提: 对express 有一定了解</p><p>要web 化很简单,只需要把刚才的解析代码放到路由里面即可,详细实现看源码..</p><p><code>app.get(&#39;/&#39;, callback);</code></p><p><code>app.get(&#39;/translate/:title&#39;, callback);</code></p><p>最终演示用地址挂在我自己的服务器上:<a href="http://goo.gl/K3Dc8">演示网址:http://goo.gl/K3Dc8</a> <strong>用了google的短网址服务可能有转换慢,或者无法访问的情况</strong></p><p>最近,kindle入华貌似变成了事实,特此贴上kindle浏览的效果..图片压缩了一下,可能效果差了不少,不过对于kindle3 而言中文字体的确很难看,有kpw可否贴下?</p><p><img src="/images/nodescrapingpage/osckindle1.gif" alt="原来的页面"><br><img src="/images/nodescrapingpage/osckindle2.gif" alt="改造好的页面"></p><p>##展望##<br>由于整个程序虽然代码不多,不过需要的知识的广度不少,例如,dom树,jsdom ,express, html5, 每个知识都只是用了那么一点…写起来真不好下手,有兴趣的朋友,可以fork 我github的项目,地址,开头就给了.</p><p>当然,这个程序是一个半成品(一个晚上的代码,再花了一个晚上写这篇博文),很多东西都还没加上…接下来,我应该会着手实现webapp离线化….</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSDMO 使用笔记</title>
      <link href="/2013/05/04/nodejs/jsdomlessonone/"/>
      <url>/2013/05/04/nodejs/jsdomlessonone/</url>
      
        <content type="html"><![CDATA[<p>##jsdom.env##<br>简单使用</p><ol><li>html</li><li>scripts</li><li>config</li><li>callback <blockquote><p>function(errors ,window)</p></blockquote><span id="more"></span></li></ol><p>config</p><p>#出来dom 用,加属性,改文本之类#<br>##jsdom.jsdom##<br>控制dom的所有属性</p><p>##jsdom.jQueryify##</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android OneXlistview 1.0.0 说明</title>
      <link href="/2013/05/03/opensource/onexlistview/"/>
      <url>/2013/05/03/opensource/onexlistview/</url>
      
        <content type="html"><![CDATA[<p>##前言##</p><p>##原始组件说明##<br>整合和扩展了如下项目</p><ol><li><p><a href="https://github.com/Maxwin-z/XListView-Android">XListview</a></p><blockquote><p>上拉加载,下拉刷新,listview</p></blockquote></li><li><p><a href="https://github.com/huewu/PinterestLikeAdapterView">PinterestLikeAdapterView</a></p><blockquote><p> 类似于pinterest瀑布流实现</p></blockquote></li><li><p><a href="https://github.com/emilsjolander/StickyListHeaders">https://github.com/emilsjolander/StickyListHeaders</a></p><blockquote><p>列表头部固定的</p></blockquote></li><li><p><a href="https://github.com/woozzu/IndexableListView">https://github.com/woozzu/IndexableListView</a></p><blockquote><p>列表快速索引</p></blockquote></li></ol><p><strong>以上项目的版权声明均为 Apache License 2.0</strong></p><span id="more"></span><p>##扩展说明##<br>在这些原始项目,并不是所有项目都支持上拉加载,下拉刷新,于是,我在原始项目的基础上扩展出一系列XXlistview, 把xlistview上拉,下拉机制对相应项目进行改造,是这些原本不具备上拉,下拉机制的listview都拥有这个功能. 并且对原xlistview 的存在的bug 也进行了相应的修复.</p><p>###xListview changlog###<br>bugfix: 刷新,加载更多,还没加载完毕的时候在进行上下拉导致的重复加载</p><p>bugfix: item 数目不满一屏幕的时候显示更多加载按钮</p><p>improve: 正在刷新,或者加载更多的时候不应该可以继续拉<br>##扩展的view##<br>以下view 如无特殊说明都支持上下拉</p><ol><li><p>XIndexableView</p><blockquote><p>具有快速索引的listview</p></blockquote></li><li><p>XMultiColumnListView</p><blockquote><p>扩展自原瀑布流</p></blockquote></li><li><p>XStickyListHeadersIndexableView</p><blockquote><p>具有固定头部,且支持快速索引</p></blockquote></li><li><p>XStickyListHeadersView</p><blockquote><p>固定头部</p></blockquote></li></ol><p>##使用##<br>要开启上下拉很简单</p><p>开启上拉</p><p><code>mListView.setPullLoadEnable(true);</code></p><p>开启下拉(默认开启)</p><p><code>mListView.setPullRefreshEnable(true);</code></p><p>监听器</p><p><code>mListView.setXListViewListener(this);</code></p><p>由于demo 可能需要点时间,用法跟listview一样,等不及演示demo可以去看原项目的demo,基本没有区别.<br>##ToDo list##</p><ol><li>实现跟便捷的自定义上下拉view机制</li><li>演示用demo</li><li>写相应的文档</li></ol><p>##License##<br>Copyright 2012 youxiachai</p><p>&#96;Licensed under the Apache License, Version 2.0 (the “License”);<br>you may not use this file except in compliance with the License.<br>You may obtain a copy of the License at</p><p>   <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p><p>Unless required by applicable law or agreed to in writing, software<br>distributed under the License is distributed on an “AS IS” BASIS,<br>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br>See the License for the specific language governing permissions and<br>limitations under the License.&#96;</p>]]></content>
      
      
      <categories>
          
          <category> opensource </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国红会开发的&#39;信息公开&#39;项目</title>
      <link href="/2013/05/01/other/cnredcross/"/>
      <url>/2013/05/01/other/cnredcross/</url>
      
        <content type="html"><![CDATA[<p>##前言##<br>最近,关于红会的负面消息,还真不少,甚至波及到了香港红会,然后,我今天,特意上了一下<a href="http://www.redcross.org.cn/hhzh/">中国红会</a>的网站,发现多了一个信息公开的栏目,左上角括号试运行…从这里很明显可以看出,这个栏目的开放就是为了回应群众对于红会的不信任而开发的,我很奇怪的发现,除了<strong>青海泥石流</strong>其他都是建设中,财务审计报告也只有2010 年.因为,上面没有开发时间,于是,我查了一下,查到了这篇2011 年写人民网的这篇报道<a href="http://hm.people.com.cn/GB/15070448.html">港澳红十字会年报长达50页 超5000元需审批</a>里面提到,<strong>中国红十字会日前表示，目前正在研发的“中国红十字会捐款信息管理系统”，将在近期向社会推出.</strong> 我大致估算了一下这个平台应该大约开发了1年半的时间开发,然后除了青海玉树地震全部都是建设中….不过反过来对比,香港,澳门,台湾红会的相关系统,咱们的系统是最好看的(不愧花了这么长时间).不知道该觉得自豪,还是可悲…</p><span id="more"></span><p>##平台概览##<br>###技术分析###<br>服务端: Microsoft-IIS&#x2F;6.0 ,c# asp.net 2.0</p><p>数据库: Oracle(要不是报错了,还真查不到)</p><p>前端: jquery 1.4.4 ,flash</p><p>其中让我比较惊讶的是,里面项目查询用的地图居然用的是google 地图,我访问的时候,好像数据库连接超时了查不了那些项目在地图上面的显示.</p><p>##疑问##<br>我很难理解,花了一年半的时间开发的系统,居然只做好了,青海玉树地震部分,跟让我理解不能的是,这样的一个查询系统为什么要做4套.</p><p>###非技术的问题###<br>其实,对比香港红会,台湾红会,咱们的查询系统是在是太长面子的,但是,红会需要的是这样的系统?我觉得不是,就拿香港红会而言,从2000年起每年的年报最后都有一个很长很长的核算报告,这样才是最实在的方法.其实,如果这个机构如果值得信赖的话,一般都不会在意自己捐款的去向,因为,信赖你才会捐给你,那么你回应这种信赖就是以最快的方式发布如何使用了这个捐款,这样的话,及时面临信赖危机,因为有账在这里,谣言不攻自破.都是些很浅显的道理,但是,执行起来就是特别的困难.</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社科人文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Formatter 阅读心得</title>
      <link href="/2013/04/28/java/javaformattips/"/>
      <url>/2013/04/28/java/javaformattips/</url>
      
        <content type="html"><![CDATA[<p>##导言##<br>阅读java util 包的源码的时候,忽然发现了,一个格式化类的使用,看完以后,发现,以前写代码太没有思考了,copy 过来就来用,其实,如果,只是多了解一点的话,也算是给自己多一种方式.</p><span id="more"></span><p>##一个简单的例子##<br>question 1</p><blockquote><p>我要输出一个当前时间的年月日时间格式的字符串 <br/><br>  2013-04-28 22:20:12</p></blockquote><p>一般而言我们可能会这么干</p><blockquote><p><code>SimpleDateFormat dateFormater = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code><br><code>Calendar cal = Calendar.getInstance();</code><br/><br><code>System.out.println(dateFormater.format(cal.getTime()));</code></p></blockquote><p>不过,如果能是一个C语言程序员的话,肯定会知道一个叫做格式化字符的机制,java很好的继承了这点,并且把这个机制做了一个加强,不但支持常规类型 而且也支持日期类型</p><blockquote><p><code>System.out.println(String.format(&quot;%1$tF %1$tT&quot;, Calendar.getInstance()));</code></p></blockquote><p>可能这段代码不太好动,如同正则一样那些复杂不太友好的字符,亮瞎了咱们的眼,但是,相对于正则的博大精深,java Formatter 机制明显简单很多,也许上面的那个例子,并不能打动你,不过,如果你的代码只需要进行字符的格式输出的话,并不需要解析的话,而你又不怎么熟悉正则的话,我推荐,java formatter 是你值得去了解使用的东西.虽然不是什么高深的东西,但是的确很常用.</p><p>##语法简讲##</p><p>###格式说明符组成说明###<br>中括号标注([])的为可选参数.</p><ol><li><p>常规类型、字符类型和数值类型的格式说明符的语法如下： </p><blockquote><p> %[argument_index$][flags][width][.precision]conversion <br/><br> %[参数索引][标识集][输出宽度][.限制字符]标明如何格式化字符</p></blockquote></li><li><p>用来表示日期和时间类型的格式说明符的语法如下： </p><blockquote><p>%[argument_index$][flags][width]conversion <br/><br>conversion 是一个由两字符组成的序列。第一个字符是 ‘t’ 或 ‘T’。第二个字符表明所使用的格式。</p></blockquote></li><li><p>与参数不对应</p><blockquote><p> %[flags][width]conversion</p></blockquote></li></ol><p>###标识集(flags)###<br>在整个Formatter 让我最难懂的就是标识集的用法.限制大,功能看上去不强大.</p><p>以下为官方原档</p><blockquote><p>下表总结了受支持的标志。y 表示该标志受指示参数类型支持。<br><br/>标志 常规  字符 整数  浮点  日期&#x2F;时间  说明<br>‘-‘  y  y  y  y  y  结果将是左对齐的。<br>‘#’  y1  -  y3  y  -  结果应该使用依赖于转换类型的替换形式<br>‘+’  -  -  y4  y  -  结果总是包括一个符号<br>‘  ‘  -  -  y4  y  -  对于正值，结果中将包括一个前导空格<br>‘0’  -  -  y  y  -  结果将用零来填充<br>‘,’  -  -  y2  y5  -  结果将包括特定于语言环境的组分隔符<br>‘(‘  -  -  y4  y5  -  结果将是用圆括号括起来的负数<br>1 取决于 Formattable 的定义。 <br/><br>2 只适用于 ‘d’ 转换。 <br/><br>3 只适用于 ‘o’、’x’ 和 ‘X’ 转换。 <br/><br>4 对 BigInteger 应用 ‘d’、’o’、’x’ 和 ‘X’ 转换时，或者对 byte 及 Byte、short 及 Short、int 及 Integer、long 及 Long 分别应用 ‘d’ 转换时适用。 <br/><br>5 只适用于 ‘e’、’E’、’f’、’g’ 和 ‘G’ 转换。 </p></blockquote><p>内置有7个标识位,而且限制多多,后来经过一番折腾,终于发现,这个标识位其实最大的作用用于实现Formattable 接口使用.</p><p>举一个使用场景:</p><p>例如符号数的显示</p><blockquote><p><code>String.format(&quot;%1$+d&quot;,1 )</code> <br/><br>输出 <code>+1</code></p></blockquote><p>这个例子…不过,没什么特殊要求的话可以忽略这个标识位的使用</p><p>###转换类型###</p><ol><li><p>常规 - 可应用于任何参数类型 </p></li><li><p>字符 - 可应用于表示 Unicode 字符的基本类型：char、Character、byte、Byte、short 和 Short。当 Character.isValidCodePoint(int) 返回 true 时，可将此转换应用于 int 和 Integer 类型 </p></li><li><p>数值 </p><blockquote><ol><li>整数 - 可应用于 Java 的整数类型：byte、Byte、short、Short、int、Integer、long、Long 和 BigInteger <br/></li><li>浮点 - 可用于 Java 的浮点类型：float、Float、double、Double 和 BigDecimal</li></ol></blockquote></li><li><p>日期&#x2F;时间 - 可应用于 Java 的、能够对日期或时间进行编码的类型：long、Long、Calendar 和 Date。 </p></li><li><p>百分比 - 产生字面值 ‘%’ (‘\u0025’) </p></li><li><p>行分隔符 - 产生特定于平台的行分隔符</p></li></ol><p>更多参考源文档<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">java.util.Formatter</a></p><p>###附录###<br><strong>可能日期的格式化处理用得比较多,我就把api doc里面的文档直接复制过来</strong></p><p>以下日期和时间转换的后缀字符是为 ‘t’ 和 ‘T’ 转换定义的。这些类型相似于但不完全等同于那些由 GNU date 和 POSIX strftime(3c) 定义的类型。提供其他转换类型是为了访问特定于 Java 的功能（如将 ‘L’ 用作秒中的毫秒）。 </p><p>以下转换字符用来格式化时间： ‘H’  24 小时制的小时，被格式化为必要时带前导零的两位数，即 00 - 23。<br>‘I’  12 小时制的小时，被格式化为必要时带前导零的两位数，即 01 - 12。<br>‘k’  24 小时制的小时，即 0 - 23。<br>‘l’  12 小时制的小时，即 1 - 12。<br>‘M’  小时中的分钟，被格式化为必要时带前导零的两位数，即 00 - 59。<br>‘S’  分钟中的秒，被格式化为必要时带前导零的两位数，即 00 - 60 （”60” 是支持闰秒所需的一个特殊值）。<br>‘L’  秒中的毫秒，被格式化为必要时带前导零的三位数，即 000 - 999。<br>‘N’  秒中的毫微秒，被格式化为必要时带前导零的九位数，即 000000000 - 999999999。<br>‘p’  特定于语言环境的 上午或下午 标记以小写形式表示，例如 “am” 或 “pm”。使用转换前缀 ‘T’ 可以强行将此输出转换为大写形式。<br>‘z’  相对于 GMT 的 RFC 822 格式的数字时区偏移量，例如 -0800。<br>‘Z’  表示时区缩写形式的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。<br>‘s’  自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的秒数，即 Long.MIN_VALUE&#x2F;1000 与 Long.MAX_VALUE&#x2F;1000 之间的差值。<br>‘Q’  自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的毫秒数，即 Long.MIN_VALUE 与 Long.MAX_VALUE 之间的差值。  </p><p>以下转换字符用来格式化日期： ‘B’  特定于语言环境的月份全称，例如 “January” 和 “February”。<br>‘b’  特定于语言环境的月份简称，例如 “Jan” 和 “Feb”。<br>‘h’  与 ‘b’ 相同。<br>‘A’  特定于语言环境的星期几全称，例如 “Sunday” 和 “Monday”<br>‘a’  特定于语言环境的星期几简称，例如 “Sun” 和 “Mon”<br>‘C’  除以 100 的四位数表示的年份，被格式化为必要时带前导零的两位数，即 00 - 99<br>‘Y’  年份，被格式化为必要时带前导零的四位数（至少），例如，0092 等于格里高利历的 92 CE。<br>‘y’  年份的最后两位数，被格式化为必要时带前导零的两位数，即 00 - 99。<br>‘j’  一年中的天数，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。<br>‘m’  月份，被格式化为必要时带前导零的两位数，即 01 - 13。<br>‘d’  一个月中的天数，被格式化为必要时带前导零两位数，即 01 - 31<br>‘e’  一个月中的天数，被格式化为两位数，即 1 - 31。  </p><p>以下转换字符用于格式化常见的日期&#x2F;时间组合。 ‘R’  24 小时制的时间，被格式化为 “%tH:%tM”<br>‘T’  24 小时制的时间，被格式化为 “%tH:%tM:%tS”。<br>‘r’  12 小时制的时间，被格式化为 “%tI:%tM:%tS %Tp”。上午或下午标记 (‘%Tp’) 的位置可能与语言环境有关。<br>‘D’  日期，被格式化为 “%tm&#x2F;%td&#x2F;%ty”。<br>‘F’  ISO 8601 格式的完整日期，被格式化为 “%tY-%tm-%td”。<br>‘c’  日期和时间，被格式化为 “%ta %tb %td %tT %tZ %tY”，例如 “Sun Jul 20 16:17:00 EDT 1969”。  </p><p>任何未明确定义为转换的字符都是非法字符，并且都被保留，以供将来扩展使用。 </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT 折腾笔记之协议简读</title>
      <link href="/2013/04/25/mqtt/mqttlessone/"/>
      <url>/2013/04/25/mqtt/mqttlessone/</url>
      
        <content type="html"><![CDATA[<p>##导言##</p><p>第一次听说MQTT 这玩意是由于要找个做手机推送的方案,后来发现,JPush这家伙做的实在不错,然后就不折腾了,最近,忽然心血来潮,把<a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe">MQTT 协议</a> 看了一遍,网上的很多<strong>中文</strong>的资料都是坑爹的,全部都是说MQTT 做推送,我按图索骥全部都是转载翻译自<a href="http://tokudu.com/2010/how-to-implement-push-notifications-for-android/">老外2010写的这篇文章</a>实在汗颜…后来,我改用全英文关键字,搜索总算发现了MQTT 的用处.如果,你不愿意看我的长篇大论我建议你去wiki那里看下 <a href="https://en.wikipedia.org/wiki/MQ_Telemetry_Transport">MQTT 详细介绍</a></p><span id="more"></span><p>##MQTT 解决什么事情?##</p><p>对于需要要了解一个什么玩意,我们需要这玩意,解决我们什么事情.从WIKI 来看MQTT 协议主要解决的是机器与机器之间数据通信,各位想到什么没?有接触过物联网的话,可能有所了解了,当我们所有机器都能在一个网络上面分配的一个地址的话,由于,设备间的性能差异,低到可能就是一个插座,而你需要这个插座能进行数据通信,例如,控制这个插座的开-闭这类的,就需要一个极其轻量级的协议而MQTT 协议就是为此目的诞生的.</p><p>比较有趣的是,MQTT这个协议在1999 年就有了最新的版本是<a href="http://www.ibm.com/developerworks/cn/webservices/ws-mqtt/">v3.1(2010&#x2F;12&#x2F;06</a>),其适用于如下但不限于这几点:</p><ol><li>即时传输的轻量级协议</li><li>专门设计用于低带宽或者高昂的网络费用</li><li>具备三种服务品质层级</li></ol><p>##MQTT 协议简读##<br>MQTT 协议相对某些协议来说,实在是简短的令人发指,整个协议只用42页就说完了.</p><p>MQTT v3 到 v3.1 有几点比较重要的变化个人感觉最重要的是从ascii 码转向 utf8的支持,不过我估计没人用过v3 所有我这里不多说了,有兴趣的,请翻阅一下协议文档…..</p><p>###传输开销的比较###<br>MQTT 最引以为豪的就是最小的2 byte 头部传输开销.我们看下其他流行的协议的message format的设计</p><ul><li><p><a href="http://www.ietf.org/rfc/rfc3920.txt">XMPP</a> 消息体用的是xml</p><blockquote><p>&#96;|——————–|</p><table><thead><tr><th><stream></th></tr></thead><tbody><tr><td><presence></td></tr><tr><td><show/></td></tr><tr><td></presence></td></tr><tr><td>——————–</td></tr><tr><td><message to='foo'></td></tr><tr><td><body/></td></tr><tr><td></message></td></tr><tr><td>——————–</td></tr><tr><td><iq to='bar'></td></tr><tr><td><query/></td></tr><tr><td></iq></td></tr><tr><td>——————–</td></tr><tr><td>…</td></tr><tr><td>——————–</td></tr><tr><td></stream></td></tr><tr><td>——————–</td></tr></tbody></table></blockquote></li><li><p><a href="https://tools.ietf.org/html/rfc2616">HTTP</a>  </p><blockquote><p>HTTP-message   &#x3D; Request | Response ; HTTP&#x2F;1.1 messages</p></blockquote></li></ul><p>还有很多协议,就不一样细说了,就举两个我比较了解的.就目前通用的协议来看很少有比MQTT 还要低的传输开销了.如果,你有了解的希望介绍一下.</p><p>###消息体的设计简说###</p><table class="bits">    <thead>        <tr>            <th>bit</th>            <th align="center">7</th>            <th align="center">6</th>            <th align="center">5</th><pre><code>        &lt;th align=&quot;center&quot;&gt;4&lt;/th&gt;        &lt;th align=&quot;center&quot;&gt;3&lt;/th&gt;        &lt;th align=&quot;center&quot;&gt;2&lt;/th&gt;        &lt;th align=&quot;center&quot;&gt;1&lt;/th&gt;        &lt;th align=&quot;center&quot;&gt;0&lt;/th&gt;    &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;byte 1&lt;/td&gt;        &lt;td align=&quot;center&quot; colspan=&quot;4&quot;&gt;Message Type&lt;/td&gt;        &lt;td&gt;DUP flag&lt;/td&gt;        &lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;QoS level&lt;/td&gt;        &lt;td&gt;RETAIN&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;byte 2&lt;/td&gt;        &lt;td align=&quot;center&quot; colspan=&quot;8&quot;&gt;Remaining Length&lt;/td&gt;    &lt;/tr&gt;&lt;/tbody&gt;</code></pre></table><p>第一个byte 用于说明消息体的信息.</p><p>第二个byte 用于传输我们需要传输的数据.</p><p><a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#msg-format">更多详情请看协议 msg-format 部分</a></p><p>接下来,结合一个最简例子来对这个消息体进行说明</p><p>##MQTT 最简例子##<br>为了方便进行MQTT的了解与使用,目前MQTT的资料极其匮乏,也找不到什么给力的例子所以,随着我研究的深度,来慢慢提高这些例子的难度.</p><p><strong>准备</strong></p><p>服务端: </p><ul><li>nodejs: <a href="https://github.com/adamvr/MQTT.js/">MQTT.js</a></li></ul><p>客户端: </p><ul><li>nodejs: <a href="https://github.com/adamvr/MQTT.js/">MQTT.js</a></li><li>java: <a href="http://www.eclipse.org/paho/">Paho</a></li></ul><p>例子地址:<a href="https://github.com/youxiachai/mqttlesson/tree/master/LessonOne">https://github.com/youxiachai/mqttlesson/tree/master/LessonOne</a> java 版本暂未提供,晚些时候写个android的客户端….</p><p>###例子设计###<br>为了简单,方便理解,这个例子:</p><ol><li><p>服务器是一个广播模型</p></li><li><p>对于<strong>订阅</strong>&#x2F;<strong>发布</strong>没有限制使用<strong>topic</strong>(主要是为了后面的知识做准备)</p></li><li><p><strong>订阅者</strong>获取到一次<strong>发布者</strong>消息就断开连接</p></li><li><p>首先服务端启动,接着启动 mqttClientSub</p></li></ol><blockquote><p>例子流程图:  clientA -&gt;(connect)  server</p></blockquote><ol start="2"><li>启动发布者:mqttClientPub<blockquote><p>例子流程图:  clientB -&gt;(publish)  server -&gt;(pub) clientA</p></blockquote></li></ol><p>以上就是整个例子的流程</p>]]></content>
      
      
      <categories>
          
          <category> mqtt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 主题制作</title>
      <link href="/2013/04/09/hexo/hexolessontwo/"/>
      <url>/2013/04/09/hexo/hexolessontwo/</url>
      
        <content type="html"><![CDATA[<p>##主题相关变量##<br>###site <code>&lt;% site %&gt;</code>###</p><pre><code class="js">&#123;&quot;posts&quot;: &quot; 所有文章，根据发表日期降序排列 [Collection事件](http://zespia.tw/hexo/zh-CN/docs/collection.html#collection)&quot;,&quot;pages&quot;: &quot; 所有页面，根据发表日期降序排列 [Collection事件](http://zespia.tw/hexo/zh-CN/docs/collection.html#collection)&quot;,&quot;categories &quot;: &quot;所有分类，根据字母顺序排列, [Taxonomy 事件](http://zespia.tw/hexo/zh-CN/docs/collection.html#taxonomy)&quot;,&quot;tags &quot;: &quot;所有标签，根据字母顺序排列[ Taxonomy 事件](http://zespia.tw/hexo/zh-CN/docs/collection.html#taxonomy)&quot;&#125;</code></pre><span id="more"></span><p>例如获取所有文章标题:</p><p><code>&lt;% site.posts.each(function(item)&#123; %&gt;  &lt;%= item.title%&gt; &lt;% &#125;); %&gt;</code></p><p>###Page <code>&lt;% page %&gt;</code>###<br>注意 <strong>页面的资料，内容根据不同页面而有所差异，由 Generator 所控制</strong></p><p>####下面为page,post 对象内容:####</p><p><strong>post</strong></p><pre><code class="js">&#123;&quot;title&quot;: &quot;文章标题&quot;,&quot;date&quot;: &quot;文章的发布日期（[Moment.js 库](http://momentjs.com/)）&quot;,&quot;updated&quot;: &quot;文章的更新日期（[Moment.js 库](http://momentjs.com/)）&quot;,&quot;comments&quot;: &quot; 开启此文章的留言功能 boolean 值&quot;,&quot;layout&quot;: &quot; 文章布局&quot;,&quot;content&quot;: &quot;文章内文&quot;,&quot;excerpt&quot;: &quot; 文章摘要（内文中 &lt;!-- more --&gt; 之前的内容）&quot;,&quot;source&quot;: &quot;about/index.html 文件的相对路径&quot;,&quot;path&quot;: &quot;about/index.html 文章的相对路径&quot;,&quot;ctime&quot;: &quot;2013-04-05T14:38:36.000Z&quot;,&quot;mtime&quot;: &quot;2013-04-05T14:38:41.000Z&quot;,&quot;permalink&quot;: &quot;http://yoursite.com/about/index.html 完整的网络访问路径&quot;,&quot;full_path&quot;: &quot;D:\\hexo11/source/about/index.html 原始文件路径&quot;,&quot;categories&quot; : &quot;&#123;&#125;&quot;,&quot;tags&quot;: &quot;&#123;&#125;&quot;&quot;_id&quot;: 1&#125;</code></pre><p>page 和 post 的差别不大，仅在于 page 没有categories和tags变量。<br>有些变量貌似文档没写,这里就补充了一下…</p><p><strong>注意,这里的page属于单个 collection 迭代的单个对象</strong></p><p><strong>Generator控制 的page</strong></p><p>基础布局模板:</p><p><strong>page为  <a href="http://zespia.tw/hexo/zh-CN/docs/collection.html#collection">Collection事件</a></strong></p><ul><li>layout</li><li>archive</li><li>category</li><li>index</li><li>tag</li></ul><p>例如在以上模板中可以用collection事件来获得具体的page内容:</p><p><code>&lt;% page.posts.each(function(item)&#123; %&gt;  &lt;%= item.title%&gt; &lt;% &#125;); %&gt;</code></p><p><strong>page为  post的内容的</strong></p><ul><li>page</li><li>post</li><li>自定义模板</li></ul><p>在以上模板中可以直接<code>&lt;%= page.title %&gt;</code>获得对应的内容.</p><p>###config <code>&lt;% config %&gt;</code>###</p><p> 全局设定，即<a href="http://zespia.tw/hexo/zh-CN/docs/configure.html">_config.yml</a>的内容</p><p>###theme <code>&lt;% theme %&gt;</code>###<br>主题设定，即主题文件夹内_config.yml的内容，根据不同主题而有所差异</p><p>###__（双底线）<code>&lt;% __(&#39;string&#39;) %&gt;</code>###</p><ul><li>取得 <a href="http://zespia.tw/hexo/zh-CN/docs/global-variables.html#i18n">国际化</a>（i18n） 字串 参考默认主题的 <code>languages/</code>下的文件</li></ul><p>例如:</p><p><code>&lt;%= __(&#39;home&#39;)%&gt;</code></p><p>##渲染流程##<br>hexo v1.1.2的主题渲染,有两种渲染方式</p><p>###第一种基础布局渲染###</p><p><img src="/images/renderpage1.png"><br>你也可以在主题中自定其他布局，例如link或photo之类的，若找不到自定的布局的话，则会根据 Generator 的不同，使用相对应的布局代替。<br>（至少要有index布局)</p><p>###第二种带layout 布局###<br>与第一种不同的是,多了一个全局的模板,layout.ejs 文件可以用这个代码<code>&lt;%- body %&gt;</code>把<strong>page对象传递到下面的模板</strong></p><p><img src="/images/renderpage2.png"></p><p>##加载动态组件##<br>对于一个静态博客而言,最大的不便就是无法进行评论,不过关于这块,其实,已经有很多解决方案,下面以中国的多说为例</p><p>我们只需要在相应的模板加载对应的代码即可…例如</p><script src="https://gist.github.com/youxiachai/5349668.js" async="true"></script>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 简明入门教程（一）</title>
      <link href="/2013/04/04/hexo/hexolessonone/"/>
      <url>/2013/04/04/hexo/hexolessonone/</url>
      
        <content type="html"><![CDATA[<p>##导言##<br>对于个人独立博客的搭建，或者一些产品网站的介绍我个人比较推崇直接用静态网站生成器来完成这个事情，对于，静态网页部署方便，浏览速度快。</p><p>以下为部分静态网站生成器简要列表</p><p>###Ruby###</p><ol><li>Jekyll （github 默认pages 引擎）</li><li>Octopress （兼容jekyll）</li></ol><p>###Python###</p><ol><li>Hyde Jekyll的Python语言实现版本</li><li>Cyrax 使用Jinja2模板引擎的生成器</li></ol><p>###PHP###</p><ol><li>Phrozn PHP语言实现的静态网站</li></ol><p>###JS###</p><ol><li>Hexo</li></ol><span id="more"></span><p>如果你只是想了解什么是静态网站生成器，</p><p>##Hexo 介绍##<br><a href="https://github.com/tommy351/hexo">Hexo</a> 是一款基于node 的静态博客网站生成器</p><p>作者 ：<a href="https://twitter.com/tommy351">@tommy351</a>是一个台湾的在校大学生。。。</p><p>相比其他的静态网页生成器而言有着，生成静态网页最快，插件丰富（已经移植了Octopress 插件）。</p><p>关于如何建立一个Hello World级别的Hexo 官方github主页已经很清晰的说明了，不做重复，直接跳过。</p><p><a href="https://github.com/tommy351/hexo">https://github.com/tommy351/hexo</a></p><p>##配置介绍##<br>在学会了，如何运行Hello World 的Hexo 我们要开始进行自定义化了，首先我们要了解hexo的静态化规则。<br>打开项目文件的根目录你会看到这个文件：</p><p>_config.yml</p><p>关于设定的文档 <a href="http://zespia.tw/hexo/zh-CN/docs/configure.html">http://zespia.tw/hexo/zh-CN/docs/configure.html</a></p><p>这里值得注意的配置参数</p><p>###部分配置说明###<br>#####URL 部分####<br><strong>root</strong> 这个参数是用于配置网站的根目录，与最终生成的网页资源链接相关的。例如有一个js文件默认的</p><p><code>root: /</code></p><p>最终网页里面的资源文件会链接到 </p><p><code>/fancybox/jquery.fancybox.pack.js</code></p><p>改为 <code>root: hello</code></p><p><code>/hello/fancybox/jquery.fancybox.pack.js</code></p><p><strong>permalink</strong> 这个是用于设置文件的存放规则。例如</p><p>默认的配置 <code>:year/:month/:day/:title/</code></p><p>最终生成的文章存放于public 文件下的<br>2013&#x2F;04&#x2F;04&#x2F;xxx.html</p><p>改为<code>:year-:month-:day/:title/</code> 将会变成2013-04-04&#x2F;xxx.html</p><p>需要改变文件的存放规则记得注意。</p><p>###写作###</p><p><a href="http://zespia.tw/hexo/zh-CN/docs/writing.html">官网的入门资料</a></p><p>由于，整个网页的生成规则是基于目标的关系，所以在写作部分你只要专注于文章的编写就行，写好的文章直接放在<code>source/_posts/</code> 下即可。更多的设定记得认真参考官方的设定。</p><p><strong>任一页面生成</strong></p><p>有些时候，对于非文章类的页面，例如一个aboutme的页面，其实我们只有直接放到<code>source/</code> 即可，路径的规则由创建的文件夹路径一致。</p><p><strong>Read more长度的控制</strong></p><p>hexo 的readmore 是由自己在写文章的时候设定的，在文章正文里面部分的合适位置加上<code>&lt;!-- more --&gt;</code> 首页的预览就会到标识的位置</p><p>###总结###<br>上面提到的内容，已经足够利用hexo搭建一个完整的博客网站，下次，我会说说如何自定义hexo的主题。</p><p>实例网站：该教程的实例演示 <a href="http://blog.gfdsa.net/">http://blog.gfdsa.net</a> 部署在github pages 上</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
